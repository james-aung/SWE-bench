{"repo": "pytest-dev/pytest", "pull_number": 12704, "instance_id": "pytest-dev__pytest-12704", "issue_numbers": ["12667"], "base_commit": "ae7959a2a72e43d6c97a47450eac3011e2519184", "patch": "diff --git a/changelog/12667.bugfix.rst b/changelog/12667.bugfix.rst\nnew file mode 100644\nindex 0000000000..eceee86cb5\n--- /dev/null\n+++ b/changelog/12667.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed a regression where type change in `ExceptionInfo.errisinstance` caused `mypy` to fail.\n", "test_patch": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex e745282575..8fac39ea29 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -56,7 +56,7 @@\n \n TracebackStyle = Literal[\"long\", \"short\", \"line\", \"no\", \"native\", \"value\", \"auto\"]\n \n-EXCEPTION_OR_MORE = Union[Type[Exception], Tuple[Type[Exception], ...]]\n+EXCEPTION_OR_MORE = Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n \n \n class Code:\n", "problem_statement": "Too tight a type constraint on ExceptionInfo.errisinstance\n- [x] a detailed description of the bug or problem you are having\r\n- [ ] output of `pip list` from the virtual environment you are using\r\n- [ ] pytest and operating system versions (pytest versions; error should be OS-independent)\r\n- [x] minimal example if possible\r\n\r\nWith pytest 8.2.2 the declaration of `ExceptionInfo.errisinstance` was\r\n\r\n```Python\r\n     def errisinstance(\r\n        self, exc: Union[Type[BaseException], Tuple[Type[BaseException], ...]]\r\n    ) -> bool:\r\n```\r\n\r\nWith 8.3.1, this has changed, first by introducing a type spec, and then using that typespec for the function signature\r\n\r\n```Python\r\nEXCEPTION_OR_MORE = Union[Type[Exception], Tuple[Type[Exception], ...]]\r\n    ...\r\n    def errisinstance(self, exc: EXCEPTION_OR_MORE) -> bool:\r\n```\r\n\r\nVersion 8.2.2 would pass a `mypy` check with the following reproducer. Version 8.3.1 fails (I didn't test with 8.3.0 but I'd expect that to also fail). I tested this with mypy versions 1.10.1 and 1.11.0, but I'd expect it to fail for pretty much any supported version of mypy.\r\n\r\n```Python\r\nimport sys\r\nimport pytest\r\n\r\n\r\ndef test_iserrinstance() -> None:\r\n    def bad() -> None:\r\n        sys.exit()\r\n\r\n    with pytest.raises(BaseException) as exc:\r\n        bad()\r\n    assert exc.errisinstance(SystemExit)\r\n\r\n# Error output:\r\npython3.10 -m mypy reproducer.py\r\nreproducer.py:12: error: \"ExceptionInfo[BaseException]\" has no attribute \"iserrinstance\"; maybe \"errisinstance\"?  [attr-defined]\r\nFound 1 error in 1 file (checked 1 source file)\r\n```\r\n\r\nThe change was made in [this commit ](https://github.com/pytest-dev/pytest/commit/9295f9ffffc11595cc4d7241008f60783f1f46c2#diff-ac2099a172465905236568f8c175328fb75ebc1b80ce39f4799e61373d355418) but I'm not finding an explanation there as to why the type was changed from `BaseException` to `Exception`.\r\n\r\nTo me, it looks like the best fix is to change EXCEPTION_OR_MORE to\r\n\r\n```Python\r\nEXCEPTION_OR_MORE = Union[Type[BaseException], Tuple[Type[BaseException], ...]]\r\n```\r\n\r\nrestoring backward compatibility.\n", "hints_text": "This is a oversight on my part,it needs a fix \nJust to clarify @RonnyPfannschmidt is that something you will tackle, or PRs are welcome?\nPrs Welcome, I'm not at capacity ATM ", "created_at": "2024-08-09T15:26:45Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12700, "instance_id": "pytest-dev__pytest-12700", "issue_numbers": ["12667"], "base_commit": "ef9b8f9d748b6f50eab5d43e32d93008f7880899", "patch": "diff --git a/changelog/12667.bugfix.rst b/changelog/12667.bugfix.rst\nnew file mode 100644\nindex 0000000000..eceee86cb5\n--- /dev/null\n+++ b/changelog/12667.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed a regression where type change in `ExceptionInfo.errisinstance` caused `mypy` to fail.\n", "test_patch": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex e745282575..8fac39ea29 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -56,7 +56,7 @@\n \n TracebackStyle = Literal[\"long\", \"short\", \"line\", \"no\", \"native\", \"value\", \"auto\"]\n \n-EXCEPTION_OR_MORE = Union[Type[Exception], Tuple[Type[Exception], ...]]\n+EXCEPTION_OR_MORE = Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n \n \n class Code:\n", "problem_statement": "Too tight a type constraint on ExceptionInfo.errisinstance\n- [x] a detailed description of the bug or problem you are having\r\n- [ ] output of `pip list` from the virtual environment you are using\r\n- [ ] pytest and operating system versions (pytest versions; error should be OS-independent)\r\n- [x] minimal example if possible\r\n\r\nWith pytest 8.2.2 the declaration of `ExceptionInfo.errisinstance` was\r\n\r\n```Python\r\n     def errisinstance(\r\n        self, exc: Union[Type[BaseException], Tuple[Type[BaseException], ...]]\r\n    ) -> bool:\r\n```\r\n\r\nWith 8.3.1, this has changed, first by introducing a type spec, and then using that typespec for the function signature\r\n\r\n```Python\r\nEXCEPTION_OR_MORE = Union[Type[Exception], Tuple[Type[Exception], ...]]\r\n    ...\r\n    def errisinstance(self, exc: EXCEPTION_OR_MORE) -> bool:\r\n```\r\n\r\nVersion 8.2.2 would pass a `mypy` check with the following reproducer. Version 8.3.1 fails (I didn't test with 8.3.0 but I'd expect that to also fail). I tested this with mypy versions 1.10.1 and 1.11.0, but I'd expect it to fail for pretty much any supported version of mypy.\r\n\r\n```Python\r\nimport sys\r\nimport pytest\r\n\r\n\r\ndef test_iserrinstance() -> None:\r\n    def bad() -> None:\r\n        sys.exit()\r\n\r\n    with pytest.raises(BaseException) as exc:\r\n        bad()\r\n    assert exc.errisinstance(SystemExit)\r\n\r\n# Error output:\r\npython3.10 -m mypy reproducer.py\r\nreproducer.py:12: error: \"ExceptionInfo[BaseException]\" has no attribute \"iserrinstance\"; maybe \"errisinstance\"?  [attr-defined]\r\nFound 1 error in 1 file (checked 1 source file)\r\n```\r\n\r\nThe change was made in [this commit ](https://github.com/pytest-dev/pytest/commit/9295f9ffffc11595cc4d7241008f60783f1f46c2#diff-ac2099a172465905236568f8c175328fb75ebc1b80ce39f4799e61373d355418) but I'm not finding an explanation there as to why the type was changed from `BaseException` to `Exception`.\r\n\r\nTo me, it looks like the best fix is to change EXCEPTION_OR_MORE to\r\n\r\n```Python\r\nEXCEPTION_OR_MORE = Union[Type[BaseException], Tuple[Type[BaseException], ...]]\r\n```\r\n\r\nrestoring backward compatibility.\n", "hints_text": "This is a oversight on my part,it needs a fix \nJust to clarify @RonnyPfannschmidt is that something you will tackle, or PRs are welcome?\nPrs Welcome, I'm not at capacity ATM ", "created_at": "2024-08-09T03:04:25Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12687, "instance_id": "pytest-dev__pytest-12687", "issue_numbers": ["6682"], "base_commit": "32f995188cf4c7e398bfa734985e7309cd0a8626", "patch": "diff --git a/changelog/6682.bugfix.rst b/changelog/6682.bugfix.rst\nnew file mode 100644\nindex 0000000000..7f756cbd9c\n--- /dev/null\n+++ b/changelog/6682.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed bug where the verbosity levels where not being respected when printing the \"msg\" part of failed assertion (as in ``assert condition, msg``).\n", "test_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex bfcbcbd3f8..f7ff4f6f7a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -451,7 +451,7 @@ def _format_assertmsg(obj: object) -> str:\n     # However in either case we want to preserve the newline.\n     replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n     if not isinstance(obj, str):\n-        obj = saferepr(obj)\n+        obj = saferepr(obj, _get_maxsize_for_saferepr(util._config))\n         replaces.append((\"\\\\n\", \"\\n~\"))\n \n     for r1, r2 in replaces:\ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 5ee40ee656..11688acb6f 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -341,6 +341,34 @@ def test_assertion_messages_bytes(self, pytester: Pytester) -> None:\n         assert result.ret == 1\n         result.stdout.fnmatch_lines([\"*AssertionError: b'ohai!'\", \"*assert False\"])\n \n+    def test_assertion_message_verbosity(self, pytester: Pytester) -> None:\n+        \"\"\"\n+        Obey verbosity levels when printing the \"message\" part of assertions, when they are\n+        non-strings (#6682).\n+        \"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            class LongRepr:\n+\n+                def __repr__(self):\n+                    return \"A\" * 500\n+\n+            def test_assertion_verbosity():\n+                assert False, LongRepr()\n+            \"\"\"\n+        )\n+        # Normal verbosity: assertion message gets abbreviated.\n+        result = pytester.runpytest()\n+        assert result.ret == 1\n+        result.stdout.re_match_lines(\n+            [r\".*AssertionError: A+\\.\\.\\.A+$\", \".*assert False\"]\n+        )\n+\n+        # High-verbosity: do not abbreviate the assertion message.\n+        result = pytester.runpytest(\"-vv\")\n+        assert result.ret == 1\n+        result.stdout.re_match_lines([r\".*AssertionError: A+$\", \".*assert False\"])\n+\n     def test_boolop(self) -> None:\n         def f1() -> None:\n             f = g = False\n", "problem_statement": "Document way to customize abbreviation (elipsis) on AssertionError\nI keep getting errors that I cannot debug because the printed `AssertionError` is censored so much that makes impossible to see what was the difference.\r\n\r\nAdding `-vvvv` did not help at all changing the way exceptions are rendered.\r\n\r\n> >           assert l in out\r\n> E           AssertionError: assert 'instance         docker         ansible             default          false      false' in 'Instance Name    Driver Name    Provisioner Name    Scenario Name    Created    Converged\\n---------------  ---------...i-node       false      false\\ninstance-2       docker         ansible             multi-node       false      false\\n'\r\n> \r\n\r\nI did try to research the subject a lot online but I was not able to find any solution that would allow me to disable or customize when abbreviation happens, to make the limit upwards.\r\n\r\nI raised this to PyTest because I am looking for a solution that can enable this at the entire test-suite and not on a specific file with tests, being able to do it globally is key for big projects.\r\n\r\nSome resources I found:\r\n* https://stackoverflow.com/questions/50608443/how-do-i-get-pycharm-to-show-entire-error-diffs-from-pytest -- I was not able to find a way to hack DEFAULT_MAX_CHARS \r\n* https://stackoverflow.com/questions/38000993/how-can-i-get-my-assertions-in-pytest-to-stop-being-abbreviated-with-ellipsis\r\n\r\n\n", "hints_text": "~~Try `env CI=true \u2026`, but it does not help here.~~\r\n(It is an annoying thing, I know - there are some issues/ideas in that regard open already)\r\nRelated: https://github.com/blueyed/pytest/pull/63\r\nThe problem here is that the internal `pytest_assertrepr_compare` hook does nothing here (for `op = \"in\"), and the assertion rewrite having it truncated already anyway.\r\nSomehow related docs: https://github.com/blueyed/pytest/blob/49f6aaf725610acf67087b0a38dc69e636c7402f/doc/en/assert.rst#defining-your-own-explanation-for-failed-assertions\nOne year later and I am facing again the same issue, a bug caused by an incomplete feature, one that cannot be disabled, the truncation.\r\n\r\nCan we please do something about it? For some projects this is testing PITA as the comparisons are almost always bigger than the limit and the user is left clueless to face the `what is behind those ellipses?` questions.\nIndeed this is frustrating, thanks @ssbarnea for bringing it to light again.\r\n\r\nI've opened #8391 as an attempt to fix this, feedback welcome.\nI think it was #8391 -- going to test it now.\nOops yes, fixed my comment.\n@nicoddemus I think that we need to reopen this issue because current behavior is still not ok. I found multiple similar unanswered question online such https://stackoverflow.com/questions/38000993/how-can-i-get-my-assertions-in-pytest-to-stop-being-abbreviated-with-ellipsis \r\n\r\nIMHO, I think that we need to make these values configurable regardless of the verbosity level, especially as we know that changing general verbosity level has other side effects.\r\n\r\nMy opinion is that most people would want to run in minimal verbosity level (especially) on ci but have verbose errors for failed tests.\r\n\r\nIf I run in verbose by default displaying the console log in the browser can be problematic, true for github actions and also most CI/CD system I know (none behaves nice with very long console logs).\n@ssbarnea Check out https://docs.pytest.org/en/stable/reference/reference.html#confval-verbosity_assertions, added in pytest 8.\n@bluetech That issue seems to never want to be go away... :p --- I tried, still same output with ellipses, in fact even calling `pytest -vvvv` does ellipsis....\r\n\r\n```toml\r\n[tool.pytest.ini_options]\r\nverbosity_assertions = 4\r\nverbosity_test_cases = 4\r\n```\r\n\r\nOutput:\r\n```\r\n>       assert len(results) == len(expected), results\r\nE       AssertionError: [[no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:10 Task/Handler: Foo, [no...hould not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:37 Task/Handler: Should not trigger no-tabs rules]\r\nE       assert 3 == 2\r\nE        +  where 3 = len([[no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:10 Task/Handler: Foo, [no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:13 Task/Handler: Key has a tab, [no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:37 Task/Handler: Should not trigger no-tabs rules])\r\nE        +  and   2 = len((13, 'Most files should not contain tabs.'))\r\n```\r\n\r\nUsing latest 8.2.0. I put some breakpoints and tried to find what happens. Apparently the `DEFAULT_REPR_MAX_SIZE = 240` and `saferepr()` is causing it to happen anyway:\r\n\r\n```\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/python.py(162)pytest_pyfunc_call()\r\n    161     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\r\n--> 162     result = testfunction(**testargs)\r\n    163     if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\r\n\r\n  /Users/ssbarnea/c/a/ansible-lint/src/ansiblelint/rules/no_tabs.py(92)test_no_tabs_rule()\r\n     90             assert results[i].lineno == expected[0]\r\n     91             assert results[i].message == expected[1]\r\n---> 92         assert len(results) == len(expected), results\r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/assertion/rewrite.py(454)_format_assertmsg()\r\n    453     if not isinstance(obj, str):\r\n--> 454         obj = saferepr(obj)\r\n    455         replaces.append((\"\\\\n\", \"\\n~\"))\r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(112)saferepr()\r\n    111     \"\"\"\r\n--> 112     return SafeRepr(maxsize, use_ascii).repr(obj)\r\n    113 \r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(62)repr()\r\n     61             else:\r\n---> 62                 s = super().repr(x)\r\n     63 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(59)repr()\r\n     58     def repr(self, x):\r\n---> 59         return self.repr1(x, self.maxlevel)\r\n     60 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(67)repr1()\r\n     66         if hasattr(self, 'repr_' + typename):\r\n---> 67             return getattr(self, 'repr_' + typename)(x, level)\r\n     68         else:\r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(110)repr_list()\r\n    109     def repr_list(self, x, level):\r\n--> 110         return self._repr_iterable(x, level, '[', ']', self.maxlist)\r\n    111 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(98)_repr_iterable()\r\n     97             repr1 = self.repr1\r\n---> 98             pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]\r\n     99             if n > maxiter:\r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(69)repr1()\r\n     68         else:\r\n---> 69             return self.repr_instance(x, level)\r\n     70 \r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(80)repr_instance()\r\n     79         if self.maxsize is not None:\r\n---> 80             s = _ellipsize(s, self.maxsize)\r\n     81         return s\r\n\r\n> /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(29)_ellipsize()\r\n     28     breakpoint()\r\n---> 29     if len(s) > maxsize:\r\n     30         i = max(0, (maxsize - 3) // 2)\r\n```\r\n\r\n\r\n\nI became sufficiently frustrated with this limitation that I'm currently porting some tests over to `unittest` specifically to reliably obtain comprehensive diffs when the tests fail (the tests are comparing metadata structs, so they're not useful if the diffs get truncated)\r\n\r\nOne of the many issues I encountered while trying to find a definitive answer on how to get native `pytest` tests to reliably print full diffs (akin to `unittest`'s `maxDiff=None` without dialling up the entire test suite execution to \"spam me now\" with `-vv` had suggested that `assert_truncate_level=0` should work, but it turned out that was just a suggestion in a PR rather than a change that actually landed (the explicit warning about an unknown config setting was very useful in that regard, so thank you for that feature!).\r\n\r\nIt also isn't clear whether *any* of the suggested workarounds affect the error summary report at the end of the test suite execution (that is getting truncated even when the tests are implemented in `unittest`)\nSorry folks, seems we dropped the ball on this one. Opened #12662 with a proposed fix.\nThanks @nicoddemus!\r\n\r\nI agree that combined with the previous reference to https://docs.pytest.org/en/stable/reference/reference.html#confval-verbosity_assertions that change should cover both this issue and #12307 ", "created_at": "2024-08-05T13:40:54Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12665, "instance_id": "pytest-dev__pytest-12665", "issue_numbers": ["6985"], "base_commit": "f0a0436dd0b2c2fa2a3adea0f4a7cb388ec54af9", "patch": "diff --git a/changelog/6985.improvement.rst b/changelog/6985.improvement.rst\nnew file mode 100644\nindex 0000000000..34ee8edc77\n--- /dev/null\n+++ b/changelog/6985.improvement.rst\n@@ -0,0 +1,21 @@\n+Improved :func:`pytest.approx` to enhance the readability of value ranges and tolerances between 0.001 and 1000.\n+  * The `repr` method now provides clearer output for values within those ranges, making it easier to interpret the results.\n+  * Previously, the output for those ranges of values and tolerances was displayed in scientific notation (e.g., `42 \u00b1 1.0e+00`). The updated method now presents the tolerance as a decimal for better readability (e.g., `42 \u00b1 1`).\n+\n+    Example:\n+\n+    **Previous Output:**\n+\n+    .. code-block:: console\n+\n+        >>> pytest.approx(42, abs=1)\n+        42 \u00b1 1.0e+00\n+\n+    **Current Output:**\n+\n+    .. code-block:: console\n+\n+        >>> pytest.approx(42, abs=1)\n+        42 \u00b1 1\n+\n+  -- by :user:`fazeelghafoor`\n", "test_patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 4174a55b58..d2107c2fc7 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -406,7 +406,11 @@ def __repr__(self) -> str:\n         # If a sensible tolerance can't be calculated, self.tolerance will\n         # raise a ValueError.  In this case, display '???'.\n         try:\n-            vetted_tolerance = f\"{self.tolerance:.1e}\"\n+            if 1e-3 <= self.tolerance < 1e3:\n+                vetted_tolerance = f\"{self.tolerance:n}\"\n+            else:\n+                vetted_tolerance = f\"{self.tolerance:.1e}\"\n+\n             if (\n                 isinstance(self.expected, Complex)\n                 and self.expected.imag\ndiff --git a/testing/python/approx.py b/testing/python/approx.py\nindex 69743cdbe1..21932059cc 100644\n--- a/testing/python/approx.py\n+++ b/testing/python/approx.py\n@@ -92,6 +92,7 @@ def do_assert(lhs, rhs, expected_message, verbosity_level=0):\n \n SOME_FLOAT = r\"[+-]?([0-9]*[.])?[0-9]+\\s*\"\n SOME_INT = r\"[0-9]+\\s*\"\n+SOME_TOLERANCE = rf\"({SOME_FLOAT}|[+-]?[0-9]+(\\.[0-9]+)?[eE][+-]?[0-9]+\\s*)\"\n \n \n class TestApprox:\n@@ -103,7 +104,7 @@ def test_error_messages_native_dtypes(self, assert_approx_raises_regex):\n                 \"\",\n                 \"  comparison failed\",\n                 f\"  Obtained: {SOME_FLOAT}\",\n-                f\"  Expected: {SOME_FLOAT} \u00b1 {SOME_FLOAT}\",\n+                f\"  Expected: {SOME_FLOAT} \u00b1 {SOME_TOLERANCE}\",\n             ],\n         )\n \n@@ -119,9 +120,9 @@ def test_error_messages_native_dtypes(self, assert_approx_raises_regex):\n                 r\"  comparison failed. Mismatched elements: 2 / 3:\",\n                 rf\"  Max absolute difference: {SOME_FLOAT}\",\n                 rf\"  Max relative difference: {SOME_FLOAT}\",\n-                r\"  Index \\| Obtained\\s+\\| Expected           \",\n-                rf\"  a     \\| {SOME_FLOAT} \\| {SOME_FLOAT} \u00b1 {SOME_FLOAT}\",\n-                rf\"  c     \\| {SOME_FLOAT} \\| {SOME_FLOAT} \u00b1 {SOME_FLOAT}\",\n+                r\"  Index \\| Obtained\\s+\\| Expected\\s+\",\n+                rf\"  a     \\| {SOME_FLOAT} \\| {SOME_FLOAT} \u00b1 {SOME_TOLERANCE}\",\n+                rf\"  c     \\| {SOME_FLOAT} \\| {SOME_FLOAT} \u00b1 {SOME_TOLERANCE}\",\n             ],\n         )\n \n@@ -334,6 +335,11 @@ def test_repr_string(self):\n             \"approx({'b': 2.0 \u00b1 2.0e-06, 'a': 1.0 \u00b1 1.0e-06})\",\n         )\n \n+        assert repr(approx(42, abs=1)) == \"42 \u00b1 1\"\n+        assert repr(approx(5, rel=0.01)) == \"5 \u00b1 0.05\"\n+        assert repr(approx(24000, abs=500)) == \"24000 \u00b1 500\"\n+        assert repr(approx(1500, abs=555)) == \"1500 \u00b1 555\"\n+\n     def test_repr_complex_numbers(self):\n         assert repr(approx(inf + 1j)) == \"(inf+1j)\"\n         assert repr(approx(1.0j, rel=inf)) == \"1j \u00b1 inf\"\n@@ -347,7 +353,7 @@ def test_repr_complex_numbers(self):\n         assert repr(approx(3 + 4 * 1j)) == \"(3+4j) \u00b1 5.0e-06 \u2220 \u00b1180\u00b0\"\n \n         # absolute tolerance is not scaled\n-        assert repr(approx(3.3 + 4.4 * 1j, abs=0.02)) == \"(3.3+4.4j) \u00b1 2.0e-02 \u2220 \u00b1180\u00b0\"\n+        assert repr(approx(3.3 + 4.4 * 1j, abs=0.02)) == \"(3.3+4.4j) \u00b1 0.02 \u2220 \u00b1180\u00b0\"\n \n     @pytest.mark.parametrize(\n         \"value, expected_repr_string\",\n", "problem_statement": "pytest.approx: Please improve repr readability\nIt seems that pytest.approx repr is optimized for very high or very low tolerances, but is not as easily readable as it could be for values in between.\r\nSome examples:\r\n\r\n- `pytest.approx(42, abs=1)` repr is `42 \u00b1 1.0e+00`, which could be just `42 \u00b1 1`.\r\n- `pytest.approx(5, rel=0.01)` repr is `5 \u00b1 5.0e-02`, but could be `5 \u00b1 0.05` or maybe even `5 \u00b1 1%`\r\n- `pytest.approx(24000, abs=500)` repr is `24000 \u00b1 5.0e+02` and could be `24000 \u00b1 500`\r\n- removing accuracy example: `pytest.approx(1500, abs=555)` repr is `1500 \u00b1 5.6e+02` and could be `1500 \u00b1 555`\r\n\r\nIn these number ranges using the exact number instead of the exponential notation is both more accurate **and** easier readable for humans. Please adapt pytest.approx to switch it's repr style according to the input value ranges.\n", "hints_text": "Hey, my team and I would like to look over this issue and resolve it if that's okay.\nOf course, PRs are always welcome!  Hopefully this one won't be too hard, either.\nSee https://docs.python.org/3/library/string.html#format-specification-mini-language - you probably want to use the `n` format specifier.\nAny news on this?\n@Zac-HD is this issue still open, I would like to work on it", "created_at": "2024-07-29T01:27:11Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12662, "instance_id": "pytest-dev__pytest-12662", "issue_numbers": ["6682"], "base_commit": "6c806b499ddbb844753b5c8c4d70a8b98b9d1c3a", "patch": "diff --git a/changelog/6682.bugfix.rst b/changelog/6682.bugfix.rst\nnew file mode 100644\nindex 0000000000..7f756cbd9c\n--- /dev/null\n+++ b/changelog/6682.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed bug where the verbosity levels where not being respected when printing the \"msg\" part of failed assertion (as in ``assert condition, msg``).\n", "test_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex bfcbcbd3f8..f7ff4f6f7a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -451,7 +451,7 @@ def _format_assertmsg(obj: object) -> str:\n     # However in either case we want to preserve the newline.\n     replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n     if not isinstance(obj, str):\n-        obj = saferepr(obj)\n+        obj = saferepr(obj, _get_maxsize_for_saferepr(util._config))\n         replaces.append((\"\\\\n\", \"\\n~\"))\n \n     for r1, r2 in replaces:\ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 5ee40ee656..11688acb6f 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -341,6 +341,34 @@ def test_assertion_messages_bytes(self, pytester: Pytester) -> None:\n         assert result.ret == 1\n         result.stdout.fnmatch_lines([\"*AssertionError: b'ohai!'\", \"*assert False\"])\n \n+    def test_assertion_message_verbosity(self, pytester: Pytester) -> None:\n+        \"\"\"\n+        Obey verbosity levels when printing the \"message\" part of assertions, when they are\n+        non-strings (#6682).\n+        \"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            class LongRepr:\n+\n+                def __repr__(self):\n+                    return \"A\" * 500\n+\n+            def test_assertion_verbosity():\n+                assert False, LongRepr()\n+            \"\"\"\n+        )\n+        # Normal verbosity: assertion message gets abbreviated.\n+        result = pytester.runpytest()\n+        assert result.ret == 1\n+        result.stdout.re_match_lines(\n+            [r\".*AssertionError: A+\\.\\.\\.A+$\", \".*assert False\"]\n+        )\n+\n+        # High-verbosity: do not abbreviate the assertion message.\n+        result = pytester.runpytest(\"-vv\")\n+        assert result.ret == 1\n+        result.stdout.re_match_lines([r\".*AssertionError: A+$\", \".*assert False\"])\n+\n     def test_boolop(self) -> None:\n         def f1() -> None:\n             f = g = False\n", "problem_statement": "Document way to customize abbreviation (elipsis) on AssertionError\nI keep getting errors that I cannot debug because the printed `AssertionError` is censored so much that makes impossible to see what was the difference.\r\n\r\nAdding `-vvvv` did not help at all changing the way exceptions are rendered.\r\n\r\n> >           assert l in out\r\n> E           AssertionError: assert 'instance         docker         ansible             default          false      false' in 'Instance Name    Driver Name    Provisioner Name    Scenario Name    Created    Converged\\n---------------  ---------...i-node       false      false\\ninstance-2       docker         ansible             multi-node       false      false\\n'\r\n> \r\n\r\nI did try to research the subject a lot online but I was not able to find any solution that would allow me to disable or customize when abbreviation happens, to make the limit upwards.\r\n\r\nI raised this to PyTest because I am looking for a solution that can enable this at the entire test-suite and not on a specific file with tests, being able to do it globally is key for big projects.\r\n\r\nSome resources I found:\r\n* https://stackoverflow.com/questions/50608443/how-do-i-get-pycharm-to-show-entire-error-diffs-from-pytest -- I was not able to find a way to hack DEFAULT_MAX_CHARS \r\n* https://stackoverflow.com/questions/38000993/how-can-i-get-my-assertions-in-pytest-to-stop-being-abbreviated-with-ellipsis\r\n\r\n\n", "hints_text": "~~Try `env CI=true \u2026`, but it does not help here.~~\r\n(It is an annoying thing, I know - there are some issues/ideas in that regard open already)\r\nRelated: https://github.com/blueyed/pytest/pull/63\r\nThe problem here is that the internal `pytest_assertrepr_compare` hook does nothing here (for `op = \"in\"), and the assertion rewrite having it truncated already anyway.\r\nSomehow related docs: https://github.com/blueyed/pytest/blob/49f6aaf725610acf67087b0a38dc69e636c7402f/doc/en/assert.rst#defining-your-own-explanation-for-failed-assertions\nOne year later and I am facing again the same issue, a bug caused by an incomplete feature, one that cannot be disabled, the truncation.\r\n\r\nCan we please do something about it? For some projects this is testing PITA as the comparisons are almost always bigger than the limit and the user is left clueless to face the `what is behind those ellipses?` questions.\nIndeed this is frustrating, thanks @ssbarnea for bringing it to light again.\r\n\r\nI've opened #8391 as an attempt to fix this, feedback welcome.\nI think it was #8391 -- going to test it now.\nOops yes, fixed my comment.\n@nicoddemus I think that we need to reopen this issue because current behavior is still not ok. I found multiple similar unanswered question online such https://stackoverflow.com/questions/38000993/how-can-i-get-my-assertions-in-pytest-to-stop-being-abbreviated-with-ellipsis \r\n\r\nIMHO, I think that we need to make these values configurable regardless of the verbosity level, especially as we know that changing general verbosity level has other side effects.\r\n\r\nMy opinion is that most people would want to run in minimal verbosity level (especially) on ci but have verbose errors for failed tests.\r\n\r\nIf I run in verbose by default displaying the console log in the browser can be problematic, true for github actions and also most CI/CD system I know (none behaves nice with very long console logs).\n@ssbarnea Check out https://docs.pytest.org/en/stable/reference/reference.html#confval-verbosity_assertions, added in pytest 8.\n@bluetech That issue seems to never want to be go away... :p --- I tried, still same output with ellipses, in fact even calling `pytest -vvvv` does ellipsis....\r\n\r\n```toml\r\n[tool.pytest.ini_options]\r\nverbosity_assertions = 4\r\nverbosity_test_cases = 4\r\n```\r\n\r\nOutput:\r\n```\r\n>       assert len(results) == len(expected), results\r\nE       AssertionError: [[no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:10 Task/Handler: Foo, [no...hould not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:37 Task/Handler: Should not trigger no-tabs rules]\r\nE       assert 3 == 2\r\nE        +  where 3 = len([[no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:10 Task/Handler: Foo, [no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:13 Task/Handler: Key has a tab, [no-tabs] (Most files should not contain tabs.) matched examples/playbooks/rule-no-tabs.yml:37 Task/Handler: Should not trigger no-tabs rules])\r\nE        +  and   2 = len((13, 'Most files should not contain tabs.'))\r\n```\r\n\r\nUsing latest 8.2.0. I put some breakpoints and tried to find what happens. Apparently the `DEFAULT_REPR_MAX_SIZE = 240` and `saferepr()` is causing it to happen anyway:\r\n\r\n```\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/python.py(162)pytest_pyfunc_call()\r\n    161     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\r\n--> 162     result = testfunction(**testargs)\r\n    163     if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\r\n\r\n  /Users/ssbarnea/c/a/ansible-lint/src/ansiblelint/rules/no_tabs.py(92)test_no_tabs_rule()\r\n     90             assert results[i].lineno == expected[0]\r\n     91             assert results[i].message == expected[1]\r\n---> 92         assert len(results) == len(expected), results\r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/assertion/rewrite.py(454)_format_assertmsg()\r\n    453     if not isinstance(obj, str):\r\n--> 454         obj = saferepr(obj)\r\n    455         replaces.append((\"\\\\n\", \"\\n~\"))\r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(112)saferepr()\r\n    111     \"\"\"\r\n--> 112     return SafeRepr(maxsize, use_ascii).repr(obj)\r\n    113 \r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(62)repr()\r\n     61             else:\r\n---> 62                 s = super().repr(x)\r\n     63 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(59)repr()\r\n     58     def repr(self, x):\r\n---> 59         return self.repr1(x, self.maxlevel)\r\n     60 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(67)repr1()\r\n     66         if hasattr(self, 'repr_' + typename):\r\n---> 67             return getattr(self, 'repr_' + typename)(x, level)\r\n     68         else:\r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(110)repr_list()\r\n    109     def repr_list(self, x, level):\r\n--> 110         return self._repr_iterable(x, level, '[', ']', self.maxlist)\r\n    111 \r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(98)_repr_iterable()\r\n     97             repr1 = self.repr1\r\n---> 98             pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]\r\n     99             if n > maxiter:\r\n\r\n  /Users/ssbarnea/.asdf/installs/python/3.12.2/lib/python3.12/reprlib.py(69)repr1()\r\n     68         else:\r\n---> 69             return self.repr_instance(x, level)\r\n     70 \r\n\r\n  /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(80)repr_instance()\r\n     79         if self.maxsize is not None:\r\n---> 80             s = _ellipsize(s, self.maxsize)\r\n     81         return s\r\n\r\n> /Users/ssbarnea/c/os/pytest/src/_pytest/_io/saferepr.py(29)_ellipsize()\r\n     28     breakpoint()\r\n---> 29     if len(s) > maxsize:\r\n     30         i = max(0, (maxsize - 3) // 2)\r\n```\r\n\r\n\r\n\nI became sufficiently frustrated with this limitation that I'm currently porting some tests over to `unittest` specifically to reliably obtain comprehensive diffs when the tests fail (the tests are comparing metadata structs, so they're not useful if the diffs get truncated)\r\n\r\nOne of the many issues I encountered while trying to find a definitive answer on how to get native `pytest` tests to reliably print full diffs (akin to `unittest`'s `maxDiff=None` without dialling up the entire test suite execution to \"spam me now\" with `-vv` had suggested that `assert_truncate_level=0` should work, but it turned out that was just a suggestion in a PR rather than a change that actually landed (the explicit warning about an unknown config setting was very useful in that regard, so thank you for that feature!).\r\n\r\nIt also isn't clear whether *any* of the suggested workarounds affect the error summary report at the end of the test suite execution (that is getting truncated even when the tests are implemented in `unittest`)", "created_at": "2024-07-25T23:04:40Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12661, "instance_id": "pytest-dev__pytest-12661", "issue_numbers": ["6649"], "base_commit": "6c806b499ddbb844753b5c8c4d70a8b98b9d1c3a", "patch": "diff --git a/changelog/6649.doc.rst b/changelog/6649.doc.rst\nnew file mode 100644\nindex 0000000000..cf5bb781b8\n--- /dev/null\n+++ b/changelog/6649.doc.rst\n@@ -0,0 +1,1 @@\n+Added :class:`~pytest.TerminalReporter` to the :ref:`api-reference` documentation page.\ndiff --git a/changelog/6649.misc.rst b/changelog/6649.misc.rst\nnew file mode 100644\nindex 0000000000..cec8c3f450\n--- /dev/null\n+++ b/changelog/6649.misc.rst\n@@ -0,0 +1,1 @@\n+Added :class:`~pytest.TerminalReporter` to the public pytest API, as it is part of the signature of the :hook:`pytest_terminal_summary` hook.\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 099c8a0026..3a5063b6b5 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1013,6 +1013,13 @@ PytestPluginManager\n     :inherited-members:\n     :show-inheritance:\n \n+TerminalReporter\n+~~~~~~~~~~~~~~~~\n+\n+.. autoclass:: pytest.TerminalReporter\n+    :members:\n+    :inherited-members:\n+\n TestReport\n ~~~~~~~~~~\n \n", "test_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 8c722124d0..cdda5a90ea 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -1340,7 +1340,7 @@ def build_summary_stats_line(self) -> tuple[list[tuple[str, dict[str, bool]]], s\n         The summary stats line is the line shown at the end, \"=== 12 passed, 2 errors in Xs===\".\n \n         This function builds a list of the \"parts\" that make up for the text in that line, in\n-        the example above it would be:\n+        the example above it would be::\n \n             [\n                 (\"12 passed\", {\"green\": True}),\ndiff --git a/src/pytest/__init__.py b/src/pytest/__init__.py\nindex 90abcdab03..92152b7c7b 100644\n--- a/src/pytest/__init__.py\n+++ b/src/pytest/__init__.py\n@@ -68,6 +68,7 @@\n from _pytest.runner import CallInfo\n from _pytest.stash import Stash\n from _pytest.stash import StashKey\n+from _pytest.terminal import TerminalReporter\n from _pytest.terminal import TestShortLogReport\n from _pytest.tmpdir import TempPathFactory\n from _pytest.warning_types import PytestAssertRewriteWarning\n@@ -161,6 +162,7 @@\n     \"version_tuple\",\n     \"TempdirFactory\",\n     \"TempPathFactory\",\n+    \"TerminalReporter\",\n     \"Testdir\",\n     \"TestReport\",\n     \"TestShortLogReport\",\n", "problem_statement": "doc: TerminalReporter is not documented\nIt could be added as follows, but only `rewrite` has a docstring and would be included.\r\n\r\nIt is used with the `pytest_terminal_summary` hook at least, and therefore is public API it seems.\r\n\r\n```diff\r\ndiff --git i/doc/en/reference.rst w/doc/en/reference.rst\r\nindex 50e32d660..552ad895b 100644\r\n--- i/doc/en/reference.rst\r\n+++ w/doc/en/reference.rst\r\n@@ -838,6 +838,13 @@ Session\r\n     :members:\r\n     :show-inheritance:\r\n\r\n+TerminalReporter\r\n+~~~~~~~~~~~~~~~~\r\n+\r\n+.. autoclass:: _pytest.terminal.TerminalReporter\r\n+    :members:\r\n+    :inherited-members:\r\n+\r\n TestReport\r\n ~~~~~~~~~~\r\n\r\n```\n", "hints_text": "I would like to work on this. What exactly do I have to do? \n@shankarj67 \r\nMy patch from above might be enough to make it show up in the docs.\r\nCheck `tox -e docs` to generate them (or `make -C doc/en` if you have deps installed).\r\nThen create a PR for it.\r\n\r\n(but it is only my understanding that it should be documented / included, might be worth waiting for feedback from others)\nI build the documentation. You can see the result here:\r\n![grafik](https://user-images.githubusercontent.com/48606431/83338625-7f3ab680-a2c6-11ea-9b06-c2330bb5d0de.png)\r\nThe page is already very long so this addition should not hurt the usability. Of course it is also properly added in the table of contents with all the links (including to source) working properly.\r\n![grafik](https://user-images.githubusercontent.com/48606431/83339073-616f5080-a2ca-11ea-9e57-8b1f01d69747.png)\r\n\r\nI assume the reason why only `rewrite` is shown is because it is the only method with a docstring in the class as the source indicates. Adding relevant docstrings would be great but sadly that is beyond my skills and knowledge.\r\n\r\nI am happy to open a PR for the fix.\r\nCommit: mcsitter/pytest@5c3296ca21500581224a2e4becefc74995b6752b \nsame issue here: I was looking into hook `pytest_terminal_summary` at https://docs.pytest.org/en/latest/reference/reference.html#pytest.hookspec.pytest_terminal_summary but \"TerminalReporter\" there is a bit of dead end at the moment. \r\n\r\nI think even the minimal docs from the quickfix mentioned above would be useful as it would at least link to the appropriate source code at  https://docs.pytest.org/en/latest/_modules/_pytest/terminal.html, which, while spartan, is a lot better than the current dead end.\r\n\r\n", "created_at": "2024-07-25T16:30:23Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12657, "instance_id": "pytest-dev__pytest-12657", "issue_numbers": ["12652", "12652"], "base_commit": "ae6034a781a50b572fa700911e5d8e0eb074ca17", "patch": "diff --git a/changelog/12652.bugfix.rst b/changelog/12652.bugfix.rst\nnew file mode 100644\nindex 0000000000..da7644df06\n--- /dev/null\n+++ b/changelog/12652.bugfix.rst\n@@ -0,0 +1,3 @@\n+Resolve regression `conda` environments where no longer being automatically detected.\n+\n+-- by :user:`RonnyPfannschmidt`\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 8ec2690600..befc7ccce6 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -370,9 +370,20 @@ def pytest_runtestloop(session: Session) -> bool:\n def _in_venv(path: Path) -> bool:\n     \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n     checking for the existence of the pyvenv.cfg file.\n-    [https://peps.python.org/pep-0405/]\"\"\"\n+\n+    [https://peps.python.org/pep-0405/]\n+\n+    For regression protection we also check for conda environments that do not include pyenv.cfg yet --\n+    https://github.com/conda/conda/issues/13337 is the conda issue tracking adding pyenv.cfg.\n+\n+    Checking for the `conda-meta/history` file per https://github.com/pytest-dev/pytest/issues/12652#issuecomment-2246336902.\n+\n+    \"\"\"\n     try:\n-        return path.joinpath(\"pyvenv.cfg\").is_file()\n+        return (\n+            path.joinpath(\"pyvenv.cfg\").is_file()\n+            or path.joinpath(\"conda-meta\", \"history\").is_file()\n+        )\n     except OSError:\n         return False\n \ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex f582224033..aba8f8ea48 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -3,6 +3,7 @@\n \n import os\n from pathlib import Path\n+from pathlib import PurePath\n import pprint\n import shutil\n import sys\n@@ -152,8 +153,17 @@ def test_ignored_certain_directories(self, pytester: Pytester) -> None:\n         assert \"test_notfound\" not in s\n         assert \"test_found\" in s\n \n-    def test_ignored_virtualenvs(self, pytester: Pytester) -> None:\n-        ensure_file(pytester.path / \"virtual\" / \"pyvenv.cfg\")\n+    known_environment_types = pytest.mark.parametrize(\n+        \"env_path\",\n+        [\n+            pytest.param(PurePath(\"pyvenv.cfg\"), id=\"venv\"),\n+            pytest.param(PurePath(\"conda-meta\", \"history\"), id=\"conda\"),\n+        ],\n+    )\n+\n+    @known_environment_types\n+    def test_ignored_virtualenvs(self, pytester: Pytester, env_path: PurePath) -> None:\n+        ensure_file(pytester.path / \"virtual\" / env_path)\n         testfile = ensure_file(pytester.path / \"virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n \n@@ -167,11 +177,12 @@ def test_ignored_virtualenvs(self, pytester: Pytester) -> None:\n         result = pytester.runpytest(\"virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n+    @known_environment_types\n     def test_ignored_virtualenvs_norecursedirs_precedence(\n-        self, pytester: Pytester\n+        self, pytester: Pytester, env_path\n     ) -> None:\n         # norecursedirs takes priority\n-        ensure_file(pytester.path / \".virtual\" / \"pyvenv.cfg\")\n+        ensure_file(pytester.path / \".virtual\" / env_path)\n         testfile = ensure_file(pytester.path / \".virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n         result = pytester.runpytest(\"--collect-in-virtualenv\")\n@@ -180,13 +191,14 @@ def test_ignored_virtualenvs_norecursedirs_precedence(\n         result = pytester.runpytest(\"--collect-in-virtualenv\", \".virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n-    def test__in_venv(self, pytester: Pytester) -> None:\n+    @known_environment_types\n+    def test__in_venv(self, pytester: Pytester, env_path: PurePath) -> None:\n         \"\"\"Directly test the virtual env detection function\"\"\"\n-        # no pyvenv.cfg, not a virtualenv\n+        # no env path, not a env\n         base_path = pytester.mkdir(\"venv\")\n         assert _in_venv(base_path) is False\n-        # with pyvenv.cfg, totally a virtualenv\n-        base_path.joinpath(\"pyvenv.cfg\").touch()\n+        # with env path, totally a env\n+        ensure_file(base_path.joinpath(env_path))\n         assert _in_venv(base_path) is True\n \n     def test_custom_norecursedirs(self, pytester: Pytester) -> None:\n", "problem_statement": "`pytest==8.3.1` collects tests from Python dependencies within `conda` environments (regression from `8.2.2`)\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n   - NB: Before and after failing CI runs: https://www.diffchecker.com/SReU8wCR/ \r\n- [X] pytest and operating system versions\r\n   - 8.3.1, multiple different GitHub Actions runners (`windows-2019`, `ubuntu-2022`, etc.) \r\n- [X] minimal example if possible\r\n\r\n----\r\n\r\nWe have the following `setup.cfg` file:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\npython_files = testing/**/test_*.py\r\n# NB: norecursedirs is *not* set\r\n```\r\n\r\nWhen running `pytest` (with no additional options) in the [root of our repository](https://github.com/spinalcordtoolbox/spinalcordtoolbox), we see the following behavior:\r\n\r\n- `pytest==8.2.2`: Only our tests are collected.\r\n- `pytest==8.3.1`: Our tests _and_ the tests of our dependencies are collected, leading to many errors.\r\n    - `collecting ... collected 367457 items / 408 errors / 100 skipped` (Woof!) \r\n\r\n----\r\n\r\nChanging our `setup.cfg` to the following didn't fix the problem either:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\ntestpaths = testing\r\npython_files = test_*.py\r\n```\r\n\r\nThe fix I used was adding `norecursedirs = {name_of_venv}`\r\n\r\n----\r\n\r\nSince this involves collection in virtual environments, the reason for the regression might be related to changes in:\r\n\r\n- https://github.com/pytest-dev/pytest/pull/12545\r\n\r\nNotably, we use a `conda` env with `pip` packages installed inside, which may subvert the expectations of the changes in the above PR.\n`pytest==8.3.1` collects tests from Python dependencies within `conda` environments (regression from `8.2.2`)\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n   - NB: Before and after failing CI runs: https://www.diffchecker.com/SReU8wCR/ \r\n- [X] pytest and operating system versions\r\n   - 8.3.1, multiple different GitHub Actions runners (`windows-2019`, `ubuntu-2022`, etc.) \r\n- [X] minimal example if possible\r\n\r\n----\r\n\r\nWe have the following `setup.cfg` file:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\npython_files = testing/**/test_*.py\r\n# NB: norecursedirs is *not* set\r\n```\r\n\r\nWhen running `pytest` (with no additional options) in the [root of our repository](https://github.com/spinalcordtoolbox/spinalcordtoolbox), we see the following behavior:\r\n\r\n- `pytest==8.2.2`: Only our tests are collected.\r\n- `pytest==8.3.1`: Our tests _and_ the tests of our dependencies are collected, leading to many errors.\r\n    - `collecting ... collected 367457 items / 408 errors / 100 skipped` (Woof!) \r\n\r\n----\r\n\r\nChanging our `setup.cfg` to the following didn't fix the problem either:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\ntestpaths = testing\r\npython_files = test_*.py\r\n```\r\n\r\nThe fix I used was adding `norecursedirs = {name_of_venv}`\r\n\r\n----\r\n\r\nSince this involves collection in virtual environments, the reason for the regression might be related to changes in:\r\n\r\n- https://github.com/pytest-dev/pytest/pull/12545\r\n\r\nNotably, we use a `conda` env with `pip` packages installed inside, which may subvert the expectations of the changes in the above PR.\n", "hints_text": "Does the venv directory contain a `pyvenv.cfg` file?\nYes! \r\n\r\n```console\r\n# In root of project folder (where tests are located at `./testing`)\r\nmaster|joshua@monarch:~/repos/spinalcordtoolbox/$ find . -name pyvenv.cfg\r\n./python/envs/venv_sct/pyvenv.cfg\r\n```\nInteresting. Any chance you can poke the `_in_venv` function https://github.com/pytest-dev/pytest/blob/8.3.1/src/_pytest/main.py#L370 to see why it fails for this path `./python/envs/venv_sct/`?\nIn a Python console:\r\n\r\n```python\r\n>>> from pathlib import Path\r\n>>> def _in_venv(path: Path) -> bool:\r\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\r\n    checking for the existence of the pyvenv.cfg file.\r\n    [https://peps.python.org/pep-0405/]\"\"\"\r\n    try:\r\n        return path.joinpath(\"pyvenv.cfg\").is_file()\r\n    except OSError:\r\n        return False\r\n    \r\n>>> import os\r\n>>> os.getcwd()\r\n'/home/joshua/repos/spinalcordtoolbox'\r\n>>> _in_venv(Path(\"./python/envs/venv_sct/\"))\r\nTrue\r\n```\r\n\r\nExploring more on my end too... :thinking: \nHmm. On my local Linux machine, I get fewer errors. Windows specifically reports many more errors... so I might have to test on a Windows machine. See:\r\n\r\n- https://github.com/spinalcordtoolbox/spinalcordtoolbox/issues/4570\nJust chiming in. We run automated tested in a docker container and on that container, we load the conda prefix inside the project folder. We could probably have done this better, but it was working for us in the past.\r\n\r\n/projects/projectX: the git repository location\r\n/projects/projectX/conda: the conda prefix\r\n\r\nSince version 8.3.1 we notice the same issue as described above. Tests from included packages are being discovered.\r\n\r\nWith pytest 8.2.2: collected 190 items / 1 deselected / 189 selected\r\nWith pytest 8.3.1: collected 85611 items / 157 errors / 1 deselected / 29 skipped / 85610 selected\r\n\r\nWe solved it by adding to pytest.ini\r\n```\r\naddopts = \r\n   --ignore=conda\r\n```\nit seems like checking only for modern venv left us wanting for conda - is there a similar easy check we could do for conda prefixes/envs -- i'll reach out to conda on fosstodon to get input on fixing this, we might have to undo the steamlining for now\nFor the record, I'm responding to @RonnyPfannschmidt reaching out on Mastodon (https://fosstodon.org/@ossronny/112837662322781627), we'll take a look at this ASAP.\n@RonnyPfannschmidt Can you provide more details other than what was said here, which feature was added in 8.3.1 that triggered this?\nI've filed https://github.com/conda/conda/issues/14069\nLooks like #12544/#12545 is the culprit that reduces virtualenv detection to look for `pyvenv.cfg` only and effectively removes conda environment detection.\r\n\r\nGiven that we can't easily retrofit existing conda environments out there, and a significant number of users are using `pytest` within conda environments, I'd appreciate it, if you could revert the patch, or at least retrofit it with the previous detection mechanism.\nas per https://github.com/pytest-dev/pytest/pull/12545#issuecomment-2246298479 - i'd slightly prefer adding explicit conda detection over reverting - in case thats not easy/feasible quickly we go with a revert\n@jezdez so the key question - is there a easy foolproof way to check for conda explicitly - even if a `pyvenv.cfg` was not yet retrofitted\n> @jezdez is there a good way to check for conda prior to that change? im happy to roll back for now, but if a consistent bugfix that ensures compatibility with older conda is easy, i'd prefer landing that over a revert dance\r\n\r\nThe best course of action would probably be checking for `path.joinpath(\"conda-meta\", \"history\").is_file()` for now, as that's required to exist for conda envs to use the conda environment revision system (`conda list --revisions` and [`conda install --revision REV`](https://docs.conda.io/projects/conda/en/stable/user-guide/tasks/manage-environments.html#restoring-an-environment)).\nworking on a bugfix now, venv detection will be expanded to (\"conda-meta\", \"history\")\nDoes the venv directory contain a `pyvenv.cfg` file?\nYes! \r\n\r\n```console\r\n# In root of project folder (where tests are located at `./testing`)\r\nmaster|joshua@monarch:~/repos/spinalcordtoolbox/$ find . -name pyvenv.cfg\r\n./python/envs/venv_sct/pyvenv.cfg\r\n```\nInteresting. Any chance you can poke the `_in_venv` function https://github.com/pytest-dev/pytest/blob/8.3.1/src/_pytest/main.py#L370 to see why it fails for this path `./python/envs/venv_sct/`?\nIn a Python console:\r\n\r\n```python\r\n>>> from pathlib import Path\r\n>>> def _in_venv(path: Path) -> bool:\r\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\r\n    checking for the existence of the pyvenv.cfg file.\r\n    [https://peps.python.org/pep-0405/]\"\"\"\r\n    try:\r\n        return path.joinpath(\"pyvenv.cfg\").is_file()\r\n    except OSError:\r\n        return False\r\n    \r\n>>> import os\r\n>>> os.getcwd()\r\n'/home/joshua/repos/spinalcordtoolbox'\r\n>>> _in_venv(Path(\"./python/envs/venv_sct/\"))\r\nTrue\r\n```\r\n\r\nExploring more on my end too... :thinking: \nHmm. On my local Linux machine, I get fewer errors. Windows specifically reports many more errors... so I might have to test on a Windows machine. See:\r\n\r\n- https://github.com/spinalcordtoolbox/spinalcordtoolbox/issues/4570\nJust chiming in. We run automated tested in a docker container and on that container, we load the conda prefix inside the project folder. We could probably have done this better, but it was working for us in the past.\r\n\r\n/projects/projectX: the git repository location\r\n/projects/projectX/conda: the conda prefix\r\n\r\nSince version 8.3.1 we notice the same issue as described above. Tests from included packages are being discovered.\r\n\r\nWith pytest 8.2.2: collected 190 items / 1 deselected / 189 selected\r\nWith pytest 8.3.1: collected 85611 items / 157 errors / 1 deselected / 29 skipped / 85610 selected\r\n\r\nWe solved it by adding to pytest.ini\r\n```\r\naddopts = \r\n   --ignore=conda\r\n```\nit seems like checking only for modern venv left us wanting for conda - is there a similar easy check we could do for conda prefixes/envs -- i'll reach out to conda on fosstodon to get input on fixing this, we might have to undo the steamlining for now\nFor the record, I'm responding to @RonnyPfannschmidt reaching out on Mastodon (https://fosstodon.org/@ossronny/112837662322781627), we'll take a look at this ASAP.\n@RonnyPfannschmidt Can you provide more details other than what was said here, which feature was added in 8.3.1 that triggered this?\nI've filed https://github.com/conda/conda/issues/14069\nLooks like #12544/#12545 is the culprit that reduces virtualenv detection to look for `pyvenv.cfg` only and effectively removes conda environment detection.\r\n\r\nGiven that we can't easily retrofit existing conda environments out there, and a significant number of users are using `pytest` within conda environments, I'd appreciate it, if you could revert the patch, or at least retrofit it with the previous detection mechanism.\nas per https://github.com/pytest-dev/pytest/pull/12545#issuecomment-2246298479 - i'd slightly prefer adding explicit conda detection over reverting - in case thats not easy/feasible quickly we go with a revert\n@jezdez so the key question - is there a easy foolproof way to check for conda explicitly - even if a `pyvenv.cfg` was not yet retrofitted\n> @jezdez is there a good way to check for conda prior to that change? im happy to roll back for now, but if a consistent bugfix that ensures compatibility with older conda is easy, i'd prefer landing that over a revert dance\r\n\r\nThe best course of action would probably be checking for `path.joinpath(\"conda-meta\", \"history\").is_file()` for now, as that's required to exist for conda envs to use the conda environment revision system (`conda list --revisions` and [`conda install --revision REV`](https://docs.conda.io/projects/conda/en/stable/user-guide/tasks/manage-environments.html#restoring-an-environment)).\nworking on a bugfix now, venv detection will be expanded to (\"conda-meta\", \"history\")", "created_at": "2024-07-24T06:09:39Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12656, "instance_id": "pytest-dev__pytest-12656", "issue_numbers": ["12652", "12652"], "base_commit": "8061af84b8f80a82045095d0df9da54eba5a01d8", "patch": "diff --git a/changelog/12652.bugfix.rst b/changelog/12652.bugfix.rst\nnew file mode 100644\nindex 0000000000..da7644df06\n--- /dev/null\n+++ b/changelog/12652.bugfix.rst\n@@ -0,0 +1,3 @@\n+Resolve regression `conda` environments where no longer being automatically detected.\n+\n+-- by :user:`RonnyPfannschmidt`\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 8ec2690600..befc7ccce6 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -370,9 +370,20 @@ def pytest_runtestloop(session: Session) -> bool:\n def _in_venv(path: Path) -> bool:\n     \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n     checking for the existence of the pyvenv.cfg file.\n-    [https://peps.python.org/pep-0405/]\"\"\"\n+\n+    [https://peps.python.org/pep-0405/]\n+\n+    For regression protection we also check for conda environments that do not include pyenv.cfg yet --\n+    https://github.com/conda/conda/issues/13337 is the conda issue tracking adding pyenv.cfg.\n+\n+    Checking for the `conda-meta/history` file per https://github.com/pytest-dev/pytest/issues/12652#issuecomment-2246336902.\n+\n+    \"\"\"\n     try:\n-        return path.joinpath(\"pyvenv.cfg\").is_file()\n+        return (\n+            path.joinpath(\"pyvenv.cfg\").is_file()\n+            or path.joinpath(\"conda-meta\", \"history\").is_file()\n+        )\n     except OSError:\n         return False\n \ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex f582224033..aba8f8ea48 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -3,6 +3,7 @@\n \n import os\n from pathlib import Path\n+from pathlib import PurePath\n import pprint\n import shutil\n import sys\n@@ -152,8 +153,17 @@ def test_ignored_certain_directories(self, pytester: Pytester) -> None:\n         assert \"test_notfound\" not in s\n         assert \"test_found\" in s\n \n-    def test_ignored_virtualenvs(self, pytester: Pytester) -> None:\n-        ensure_file(pytester.path / \"virtual\" / \"pyvenv.cfg\")\n+    known_environment_types = pytest.mark.parametrize(\n+        \"env_path\",\n+        [\n+            pytest.param(PurePath(\"pyvenv.cfg\"), id=\"venv\"),\n+            pytest.param(PurePath(\"conda-meta\", \"history\"), id=\"conda\"),\n+        ],\n+    )\n+\n+    @known_environment_types\n+    def test_ignored_virtualenvs(self, pytester: Pytester, env_path: PurePath) -> None:\n+        ensure_file(pytester.path / \"virtual\" / env_path)\n         testfile = ensure_file(pytester.path / \"virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n \n@@ -167,11 +177,12 @@ def test_ignored_virtualenvs(self, pytester: Pytester) -> None:\n         result = pytester.runpytest(\"virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n+    @known_environment_types\n     def test_ignored_virtualenvs_norecursedirs_precedence(\n-        self, pytester: Pytester\n+        self, pytester: Pytester, env_path\n     ) -> None:\n         # norecursedirs takes priority\n-        ensure_file(pytester.path / \".virtual\" / \"pyvenv.cfg\")\n+        ensure_file(pytester.path / \".virtual\" / env_path)\n         testfile = ensure_file(pytester.path / \".virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n         result = pytester.runpytest(\"--collect-in-virtualenv\")\n@@ -180,13 +191,14 @@ def test_ignored_virtualenvs_norecursedirs_precedence(\n         result = pytester.runpytest(\"--collect-in-virtualenv\", \".virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n-    def test__in_venv(self, pytester: Pytester) -> None:\n+    @known_environment_types\n+    def test__in_venv(self, pytester: Pytester, env_path: PurePath) -> None:\n         \"\"\"Directly test the virtual env detection function\"\"\"\n-        # no pyvenv.cfg, not a virtualenv\n+        # no env path, not a env\n         base_path = pytester.mkdir(\"venv\")\n         assert _in_venv(base_path) is False\n-        # with pyvenv.cfg, totally a virtualenv\n-        base_path.joinpath(\"pyvenv.cfg\").touch()\n+        # with env path, totally a env\n+        ensure_file(base_path.joinpath(env_path))\n         assert _in_venv(base_path) is True\n \n     def test_custom_norecursedirs(self, pytester: Pytester) -> None:\n", "problem_statement": "`pytest==8.3.1` collects tests from Python dependencies within `conda` environments (regression from `8.2.2`)\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n   - NB: Before and after failing CI runs: https://www.diffchecker.com/SReU8wCR/ \r\n- [X] pytest and operating system versions\r\n   - 8.3.1, multiple different GitHub Actions runners (`windows-2019`, `ubuntu-2022`, etc.) \r\n- [X] minimal example if possible\r\n\r\n----\r\n\r\nWe have the following `setup.cfg` file:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\npython_files = testing/**/test_*.py\r\n# NB: norecursedirs is *not* set\r\n```\r\n\r\nWhen running `pytest` (with no additional options) in the [root of our repository](https://github.com/spinalcordtoolbox/spinalcordtoolbox), we see the following behavior:\r\n\r\n- `pytest==8.2.2`: Only our tests are collected.\r\n- `pytest==8.3.1`: Our tests _and_ the tests of our dependencies are collected, leading to many errors.\r\n    - `collecting ... collected 367457 items / 408 errors / 100 skipped` (Woof!) \r\n\r\n----\r\n\r\nChanging our `setup.cfg` to the following didn't fix the problem either:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\ntestpaths = testing\r\npython_files = test_*.py\r\n```\r\n\r\nThe fix I used was adding `norecursedirs = {name_of_venv}`\r\n\r\n----\r\n\r\nSince this involves collection in virtual environments, the reason for the regression might be related to changes in:\r\n\r\n- https://github.com/pytest-dev/pytest/pull/12545\r\n\r\nNotably, we use a `conda` env with `pip` packages installed inside, which may subvert the expectations of the changes in the above PR.\n`pytest==8.3.1` collects tests from Python dependencies within `conda` environments (regression from `8.2.2`)\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n   - NB: Before and after failing CI runs: https://www.diffchecker.com/SReU8wCR/ \r\n- [X] pytest and operating system versions\r\n   - 8.3.1, multiple different GitHub Actions runners (`windows-2019`, `ubuntu-2022`, etc.) \r\n- [X] minimal example if possible\r\n\r\n----\r\n\r\nWe have the following `setup.cfg` file:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\npython_files = testing/**/test_*.py\r\n# NB: norecursedirs is *not* set\r\n```\r\n\r\nWhen running `pytest` (with no additional options) in the [root of our repository](https://github.com/spinalcordtoolbox/spinalcordtoolbox), we see the following behavior:\r\n\r\n- `pytest==8.2.2`: Only our tests are collected.\r\n- `pytest==8.3.1`: Our tests _and_ the tests of our dependencies are collected, leading to many errors.\r\n    - `collecting ... collected 367457 items / 408 errors / 100 skipped` (Woof!) \r\n\r\n----\r\n\r\nChanging our `setup.cfg` to the following didn't fix the problem either:\r\n\r\n```ini\r\n[tool:pytest]\r\naddopts = --verbose --show-capture=stderr --tb=native\r\ntestpaths = testing\r\npython_files = test_*.py\r\n```\r\n\r\nThe fix I used was adding `norecursedirs = {name_of_venv}`\r\n\r\n----\r\n\r\nSince this involves collection in virtual environments, the reason for the regression might be related to changes in:\r\n\r\n- https://github.com/pytest-dev/pytest/pull/12545\r\n\r\nNotably, we use a `conda` env with `pip` packages installed inside, which may subvert the expectations of the changes in the above PR.\n", "hints_text": "Does the venv directory contain a `pyvenv.cfg` file?\nYes! \r\n\r\n```console\r\n# In root of project folder (where tests are located at `./testing`)\r\nmaster|joshua@monarch:~/repos/spinalcordtoolbox/$ find . -name pyvenv.cfg\r\n./python/envs/venv_sct/pyvenv.cfg\r\n```\nInteresting. Any chance you can poke the `_in_venv` function https://github.com/pytest-dev/pytest/blob/8.3.1/src/_pytest/main.py#L370 to see why it fails for this path `./python/envs/venv_sct/`?\nIn a Python console:\r\n\r\n```python\r\n>>> from pathlib import Path\r\n>>> def _in_venv(path: Path) -> bool:\r\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\r\n    checking for the existence of the pyvenv.cfg file.\r\n    [https://peps.python.org/pep-0405/]\"\"\"\r\n    try:\r\n        return path.joinpath(\"pyvenv.cfg\").is_file()\r\n    except OSError:\r\n        return False\r\n    \r\n>>> import os\r\n>>> os.getcwd()\r\n'/home/joshua/repos/spinalcordtoolbox'\r\n>>> _in_venv(Path(\"./python/envs/venv_sct/\"))\r\nTrue\r\n```\r\n\r\nExploring more on my end too... :thinking: \nHmm. On my local Linux machine, I get fewer errors. Windows specifically reports many more errors... so I might have to test on a Windows machine. See:\r\n\r\n- https://github.com/spinalcordtoolbox/spinalcordtoolbox/issues/4570\nJust chiming in. We run automated tested in a docker container and on that container, we load the conda prefix inside the project folder. We could probably have done this better, but it was working for us in the past.\r\n\r\n/projects/projectX: the git repository location\r\n/projects/projectX/conda: the conda prefix\r\n\r\nSince version 8.3.1 we notice the same issue as described above. Tests from included packages are being discovered.\r\n\r\nWith pytest 8.2.2: collected 190 items / 1 deselected / 189 selected\r\nWith pytest 8.3.1: collected 85611 items / 157 errors / 1 deselected / 29 skipped / 85610 selected\r\n\r\nWe solved it by adding to pytest.ini\r\n```\r\naddopts = \r\n   --ignore=conda\r\n```\nit seems like checking only for modern venv left us wanting for conda - is there a similar easy check we could do for conda prefixes/envs -- i'll reach out to conda on fosstodon to get input on fixing this, we might have to undo the steamlining for now\nFor the record, I'm responding to @RonnyPfannschmidt reaching out on Mastodon (https://fosstodon.org/@ossronny/112837662322781627), we'll take a look at this ASAP.\n@RonnyPfannschmidt Can you provide more details other than what was said here, which feature was added in 8.3.1 that triggered this?\nI've filed https://github.com/conda/conda/issues/14069\nLooks like #12544/#12545 is the culprit that reduces virtualenv detection to look for `pyvenv.cfg` only and effectively removes conda environment detection.\r\n\r\nGiven that we can't easily retrofit existing conda environments out there, and a significant number of users are using `pytest` within conda environments, I'd appreciate it, if you could revert the patch, or at least retrofit it with the previous detection mechanism.\nas per https://github.com/pytest-dev/pytest/pull/12545#issuecomment-2246298479 - i'd slightly prefer adding explicit conda detection over reverting - in case thats not easy/feasible quickly we go with a revert\n@jezdez so the key question - is there a easy foolproof way to check for conda explicitly - even if a `pyvenv.cfg` was not yet retrofitted\n> @jezdez is there a good way to check for conda prior to that change? im happy to roll back for now, but if a consistent bugfix that ensures compatibility with older conda is easy, i'd prefer landing that over a revert dance\r\n\r\nThe best course of action would probably be checking for `path.joinpath(\"conda-meta\", \"history\").is_file()` for now, as that's required to exist for conda envs to use the conda environment revision system (`conda list --revisions` and [`conda install --revision REV`](https://docs.conda.io/projects/conda/en/stable/user-guide/tasks/manage-environments.html#restoring-an-environment)).\nworking on a bugfix now, venv detection will be expanded to (\"conda-meta\", \"history\")\nDoes the venv directory contain a `pyvenv.cfg` file?\nYes! \r\n\r\n```console\r\n# In root of project folder (where tests are located at `./testing`)\r\nmaster|joshua@monarch:~/repos/spinalcordtoolbox/$ find . -name pyvenv.cfg\r\n./python/envs/venv_sct/pyvenv.cfg\r\n```\nInteresting. Any chance you can poke the `_in_venv` function https://github.com/pytest-dev/pytest/blob/8.3.1/src/_pytest/main.py#L370 to see why it fails for this path `./python/envs/venv_sct/`?\nIn a Python console:\r\n\r\n```python\r\n>>> from pathlib import Path\r\n>>> def _in_venv(path: Path) -> bool:\r\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\r\n    checking for the existence of the pyvenv.cfg file.\r\n    [https://peps.python.org/pep-0405/]\"\"\"\r\n    try:\r\n        return path.joinpath(\"pyvenv.cfg\").is_file()\r\n    except OSError:\r\n        return False\r\n    \r\n>>> import os\r\n>>> os.getcwd()\r\n'/home/joshua/repos/spinalcordtoolbox'\r\n>>> _in_venv(Path(\"./python/envs/venv_sct/\"))\r\nTrue\r\n```\r\n\r\nExploring more on my end too... :thinking: \nHmm. On my local Linux machine, I get fewer errors. Windows specifically reports many more errors... so I might have to test on a Windows machine. See:\r\n\r\n- https://github.com/spinalcordtoolbox/spinalcordtoolbox/issues/4570\nJust chiming in. We run automated tested in a docker container and on that container, we load the conda prefix inside the project folder. We could probably have done this better, but it was working for us in the past.\r\n\r\n/projects/projectX: the git repository location\r\n/projects/projectX/conda: the conda prefix\r\n\r\nSince version 8.3.1 we notice the same issue as described above. Tests from included packages are being discovered.\r\n\r\nWith pytest 8.2.2: collected 190 items / 1 deselected / 189 selected\r\nWith pytest 8.3.1: collected 85611 items / 157 errors / 1 deselected / 29 skipped / 85610 selected\r\n\r\nWe solved it by adding to pytest.ini\r\n```\r\naddopts = \r\n   --ignore=conda\r\n```\nit seems like checking only for modern venv left us wanting for conda - is there a similar easy check we could do for conda prefixes/envs -- i'll reach out to conda on fosstodon to get input on fixing this, we might have to undo the steamlining for now\nFor the record, I'm responding to @RonnyPfannschmidt reaching out on Mastodon (https://fosstodon.org/@ossronny/112837662322781627), we'll take a look at this ASAP.\n@RonnyPfannschmidt Can you provide more details other than what was said here, which feature was added in 8.3.1 that triggered this?\nI've filed https://github.com/conda/conda/issues/14069\nLooks like #12544/#12545 is the culprit that reduces virtualenv detection to look for `pyvenv.cfg` only and effectively removes conda environment detection.\r\n\r\nGiven that we can't easily retrofit existing conda environments out there, and a significant number of users are using `pytest` within conda environments, I'd appreciate it, if you could revert the patch, or at least retrofit it with the previous detection mechanism.\nas per https://github.com/pytest-dev/pytest/pull/12545#issuecomment-2246298479 - i'd slightly prefer adding explicit conda detection over reverting - in case thats not easy/feasible quickly we go with a revert\n@jezdez so the key question - is there a easy foolproof way to check for conda explicitly - even if a `pyvenv.cfg` was not yet retrofitted\n> @jezdez is there a good way to check for conda prior to that change? im happy to roll back for now, but if a consistent bugfix that ensures compatibility with older conda is easy, i'd prefer landing that over a revert dance\r\n\r\nThe best course of action would probably be checking for `path.joinpath(\"conda-meta\", \"history\").is_file()` for now, as that's required to exist for conda envs to use the conda environment revision system (`conda list --revisions` and [`conda install --revision REV`](https://docs.conda.io/projects/conda/en/stable/user-guide/tasks/manage-environments.html#restoring-an-environment)).\nworking on a bugfix now, venv detection will be expanded to (\"conda-meta\", \"history\")", "created_at": "2024-07-23T21:46:01Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12632, "instance_id": "pytest-dev__pytest-12632", "issue_numbers": ["11771"], "base_commit": "18ca7c293b3b5ba1c7fdead4fe7e4d75ba72e67d", "patch": "diff --git a/changelog/11771.contrib.rst b/changelog/11771.contrib.rst\nnew file mode 100644\nindex 0000000000..a3c1ed1099\n--- /dev/null\n+++ b/changelog/11771.contrib.rst\n@@ -0,0 +1,5 @@\n+The PyPy runtime version has been updated to 3.9 from 3.8 that introduced\n+a flaky bug at the garbage collector which was not expected to fix there\n+as the V3.8 is EoL.\n+\n+-- by :user:`x612skm`\ndiff --git a/changelog/12557.contrib.rst b/changelog/12557.contrib.rst\nnew file mode 120000\nindex 0000000000..c036c51909\n--- /dev/null\n+++ b/changelog/12557.contrib.rst\n@@ -0,0 +1,1 @@\n+11771.contrib.rst\n\\ No newline at end of file\n", "test_patch": "diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml\nindex 0746581503..7ed40575d8 100644\n--- a/.github/workflows/test.yml\n+++ b/.github/workflows/test.yml\n@@ -145,7 +145,7 @@ jobs:\n             tox_env: \"py313\"\n             use_coverage: true\n           - name: \"ubuntu-pypy3\"\n-            python: \"pypy-3.8\"\n+            python: \"pypy-3.9\"\n             os: ubuntu-latest\n             tox_env: \"pypy3-xdist\"\n \ndiff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 8f7f474dca..fa507b3555 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1145,8 +1145,8 @@ def test_func():\n     result = pytester.runpytest()\n     markline = \"            ^\"\n     pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n-    if pypy_version_info is not None and pypy_version_info < (6,):\n-        markline = markline[1:]\n+    if pypy_version_info is not None:\n+        markline = markline[7:]\n \n     if sys.version_info >= (3, 10):\n         expected = [\n", "problem_statement": "Selftests sometimes fail on pypy: `TypeError: expected some sort of stmt, but got <_ast.Load object ...>`\nExample: https://github.com/pytest-dev/pytest/actions/runs/7408595776/job/20157160097\r\n\r\nThis doesn't always happen, maybe 50% of the time. Started in the last few days. I checked if the PyPy version changed during these days, but seems not (it's 3.8.16).\r\n\r\nThe error is:\r\n\r\n```\r\n __________________ ERROR collecting testing/_py/test_local.py __________________\r\n/opt/hostedtoolcache/PyPy/3.8.16/x64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:166: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:350: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Store object at 0x0000000002142880>\r\n```\r\n\r\nSometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\n", "hints_text": "I have same failure on older versions as well.  E.g. 7.4.3:\r\nhttps://github.com/mpmath/mpmath/actions/runs/8030300102?pr=759\r\n\r\nThis happens for all tested in the mpmath pypy versions (3.8-3.10).  But most often on 3.10.\nAnother example: https://github.com/pytest-dev/pytest/issues/11168#issuecomment-1714358183\r\n\r\n@cfbolz, I don't see a bugreport in pypy issues.  Is there any chance this might be related to pytest-dev/pytest#11168 (an fixed in pypy)?\n@skirpichev it's not impossible that it's the same problem, yes. You can try a nightly PyPy build (or wait for the next release but that is still a bit out). \n@cfbolz, thanks for a suggestion.  I did tests for nightly builds (on 3.8-3.10) and, after ~20 re-runs, I got a TypeError on pypy3.8, which is similar to this issue:\r\n<details>\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.8.16[pypy-7.3.12-alpha], pytest-8.1.1, pluggy-1.4.0\r\nmpmath backend: python\r\nmpmath mp class: <mpmath.ctx_mp.MPContext object at 0x00000000018deb10>\r\nmpmath version: 1.4.0a1.dev43+g534bc79\r\nPython version: 3.8.16 (d8e6b37f5231c7b59b2b639a651dd696a3732cc3, Jan 09 2023, 00:30:15)\r\n[PyPy 7.3.12-alpha0 with GCC 10.2.1 20210130 (Red Hat 10.2.1-11)]\r\nrootdir: /home/runner/work/mpmath/mpmath\r\nconfigfile: pyproject.toml\r\ntestpaths: mpmath, docs\r\nplugins: cov-5.0.0, xdist-3.5.0\r\ncreated: 4/4 workers\r\n4 workers [2294 items]\r\n\r\n........................................................................ [  3%]\r\n........................................................................ [  6%]\r\n........................................................................ [  9%]\r\n........................................................................ [ 12%]\r\n........................................................................ [ 15%]\r\n........................................................................ [ 18%]\r\n........................................................................ [ 21%]\r\n........................................................................ [ 25%]\r\n........................................................................ [ 28%]\r\n........................................................................ [ 31%]\r\n........................................................................ [ 34%]\r\n........................................................................ [ 37%]\r\n........................................................................ [ 40%]\r\n........................................................................ [ 43%]\r\n........................................................................ [ 47%]\r\n........................................................................ [ 50%]\r\n........................................................................ [ 53%]\r\n........................................................................ [ 56%]\r\n........................................................................ [ 59%]\r\n........................................................................ [ 62%]\r\n........................................................................ [ 65%]\r\n........................................................................ [ 69%]\r\n........................................................................ [ 72%]\r\n......................................................................... [ 75%]\r\n........................................................................ [ 78%]\r\n........................................................................ [ 81%]\r\n........................................................................ [ 84%]\r\n........................................................................ [ 87%]\r\n........................................x............................... [ 91%]\r\n.......................................x................................ [ 94%]\r\n...................................s.................................... [ 97%]\r\n.............................................................            [100%]\r\n==================================== ERRORS ====================================\r\n_______________ ERROR collecting mpmath/tests/test_basic_ops.py ________________\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:169: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:353: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n============================= slowest 20 durations =============================\r\n34.04s call     mpmath/tests/test_functions2.py::test_bessel_zeros_extra\r\n28.52s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False23]\r\n16.64s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyper\r\n11.94s call     mpmath/tests/test_extra_zeta.py::test_zetazero[241389216-97490234.22767118]\r\n10.72s call     mpmath/functions/zeta.py::mpmath.functions.zeta.secondzeta\r\n9.91s call     mpmath/tests/test_elliptic.py::test_elliptic_integrals\r\n9.25s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.bessely\r\n8.75s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyp3f2\r\n8.59s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.siegelz\r\n8.44s call     mpmath/calculus/extrapolation.py::mpmath.calculus.extrapolation.nsum\r\n8.39s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False9]\r\n7.87s call     mpmath/functions/zetazeros.py::mpmath.functions.zetazeros.nzeros\r\n7.58s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-1500-False1]\r\n7.53s call     mpmath/tests/test_quad.py::test_quadosc\r\n7.50s call     mpmath/calculus/quadrature.py::mpmath.calculus.quadrature.QuadratureMethods.quad\r\n7.45s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-90-False]\r\n7.27s call     mpmath/tests/test_torture.py::test_asymp[f-5000-True1]\r\n7.22s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False27]\r\n7.00s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False37]\r\n6.74s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False36]\r\n=========================== short test summary info ============================\r\nERROR mpmath/tests/test_basic_ops.py - TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n======= 2291 passed, 1 skipped, 2 xfailed, 1 error in 203.43s (0:03:23) ========\r\n```\r\n\r\n</details>\r\n\r\nSummary page: https://github.com/mpmath/mpmath/actions/runs/8491432157?pr=772\r\n\r\n~~Maybe this fix isn't merged yet to the 3.8 branch (as it was stated in your blog post)?  If so,~~ I'll continue testing.\nYes, the 3.8 variants are not maintained any more, you need to try 3.9 or 3.10. Thanks for trying this out! \nWell, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures.  Given the previous statistics, probably there is a chance that this issue was fixed in PyPy's nightly builds.  I'll switch regular tests for pypy3.9/10 to them.\r\n\r\nThanks for bugfix!\n> Well, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures. \r\n\r\nthank you for trying this, that's very valuable feedback!\n> Sometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\r\n\r\nDuring the sprints, we were seeing 3\u20134 variants of different AST object reprs there. Hopefully, bumping PyPy in CI will fix this. Ronny suggested this, but nobody got to actually doing it...\nFTR @LilyFoote linked https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html in https://github.com/pytest-dev/pytest/issues/11168#issuecomment-2023988486 but that reference never got cross-posted into this issue.", "created_at": "2024-07-19T12:55:45Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12587, "instance_id": "pytest-dev__pytest-12587", "issue_numbers": ["12577"], "base_commit": "d0bef1766546d5530c987ab94332b6aa06c79d1e", "patch": "diff --git a/changelog/12577.doc.rst b/changelog/12577.doc.rst\nnew file mode 100644\nindex 00000000000..0bd427e177d\n--- /dev/null\n+++ b/changelog/12577.doc.rst\n@@ -0,0 +1,3 @@\n+`CI` and `BUILD_NUMBER` environment variables role is discribed in\n+the reference doc. They now also appears when doing `pytest -h`\n+-- by :user:`MarcBresson`.\ndiff --git a/doc/en/explanation/ci.rst b/doc/en/explanation/ci.rst\nnew file mode 100644\nindex 00000000000..45fe658d14f\n--- /dev/null\n+++ b/doc/en/explanation/ci.rst\n@@ -0,0 +1,70 @@\n+.. _`ci-pipelines`:\n+\n+CI Pipelines\n+============\n+\n+Rationale\n+---------\n+\n+The goal of testing in a CI pipeline is different from testing locally. Indeed,\n+you can quickly edit some code and run your tests again on your computer, but\n+it is not possible with CI pipeline. They run on a separate server and are\n+triggered by specific actions.\n+\n+From that observation, pytest can detect when it is in a CI environment and\n+adapt some of its behaviours.\n+\n+How CI is detected\n+------------------\n+\n+Pytest knows it is in a CI environment when either one of these environment variables are set,\n+regardless of their value:\n+\n+* `CI`: used by many CI systems.\n+* `BUILD_NUMBER`: used by Jenkins.\n+\n+Effects on CI\n+-------------\n+\n+For now, the effects on pytest of being in a CI environment are limited.\n+\n+When a CI environment is detected, the output of the short test summary info is no longer truncated to the terminal size i.e. the entire message will be shown.\n+\n+  .. code-block:: python\n+\n+        # content of test_ci.py\n+        import pytest\n+\n+\n+        def test_db_initialized():\n+            pytest.fail(\n+                \"deliberately failing for demo purpose, Lorem ipsum dolor sit amet, \"\n+                \"consectetur adipiscing elit. Cras facilisis, massa in suscipit \"\n+                \"dignissim, mauris lacus molestie nisi, quis varius metus nulla ut ipsum.\"\n+            )\n+\n+\n+Running this locally, without any extra options, will output:\n+\n+  .. code-block:: pytest\n+\n+     $ pytest test_ci.py\n+     ...\n+     ========================= short test summary info ==========================\n+     FAILED test_backends.py::test_db_initialized[d2] - Failed: deliberately f...\n+\n+*(Note the truncated text)*\n+\n+\n+While running this on CI will output:\n+\n+  .. code-block:: pytest\n+\n+     $ export CI=true\n+     $ pytest test_ci.py\n+     ...\n+     ========================= short test summary info ==========================\n+     FAILED test_backends.py::test_db_initialized[d2] - Failed: deliberately failing\n+     for demo purpose, Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras\n+     facilisis, massa in suscipit dignissim, mauris lacus molestie nisi, quis varius\n+     metus nulla ut ipsum.\ndiff --git a/doc/en/explanation/index.rst b/doc/en/explanation/index.rst\nindex 53910f1eb7b..2edf60a5d8b 100644\n--- a/doc/en/explanation/index.rst\n+++ b/doc/en/explanation/index.rst\n@@ -11,5 +11,6 @@ Explanation\n    anatomy\n    fixtures\n    goodpractices\n-   flaky\n    pythonpath\n+   ci\n+   flaky\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 3675c7cb2ee..2628c1e9a04 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1120,11 +1120,11 @@ Environment variables that can be used to change pytest's behavior.\n \n .. envvar:: CI\n \n-When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to ``BUILD_NUMBER`` variable.\n+When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to ``BUILD_NUMBER`` variable. See also :ref:`ci-pipelines`.\n \n .. envvar:: BUILD_NUMBER\n \n-When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to CI variable.\n+When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to CI variable. See also :ref:`ci-pipelines`.\n \n .. envvar:: PYTEST_ADDOPTS\n \n@@ -1938,19 +1938,18 @@ All the command-line flags can be obtained by running ``pytest --help``::\n     general:\n       -k EXPRESSION         Only run tests which match the given substring\n                             expression. An expression is a Python evaluable\n-                            expression where all names are substring-matched\n-                            against test names and their parent classes.\n-                            Example: -k 'test_method or test_other' matches all\n-                            test functions and classes whose name contains\n-                            'test_method' or 'test_other', while -k 'not\n-                            test_method' matches those that don't contain\n-                            'test_method' in their names. -k 'not test_method\n-                            and not test_other' will eliminate the matches.\n-                            Additionally keywords are matched to classes and\n-                            functions containing extra names in their\n-                            'extra_keyword_matches' set, as well as functions\n-                            which have names assigned directly to them. The\n-                            matching is case-insensitive.\n+                            expression where all names are substring-matched against\n+                            test names and their parent classes. Example: -k\n+                            'test_method or test_other' matches all test functions\n+                            and classes whose name contains 'test_method' or\n+                            'test_other', while -k 'not test_method' matches those\n+                            that don't contain 'test_method' in their names. -k 'not\n+                            test_method and not test_other' will eliminate the\n+                            matches. Additionally keywords are matched to classes\n+                            and functions containing extra names in their\n+                            'extra_keyword_matches' set, as well as functions which\n+                            have names assigned directly to them. The matching is\n+                            case-insensitive.\n       -m MARKEXPR           Only run tests matching given mark expression. For\n                             example: -m 'mark1 and not mark2'.\n       --markers             show markers (builtin, plugin and per-project ones).\n@@ -1968,28 +1967,28 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       --trace               Immediately break when running each test\n       --capture=method      Per-test capturing method: one of fd|sys|no|tee-sys\n       -s                    Shortcut for --capture=no\n-      --runxfail            Report the results of xfail tests as if they were\n-                            not marked\n-      --lf, --last-failed   Rerun only the tests that failed at the last run (or\n-                            all if none failed)\n-      --ff, --failed-first  Run all tests, but run the last failures first. This\n-                            may re-order tests and thus lead to repeated fixture\n+      --runxfail            Report the results of xfail tests as if they were not\n+                            marked\n+      --lf, --last-failed   Rerun only the tests that failed at the last run (or all\n+                            if none failed)\n+      --ff, --failed-first  Run all tests, but run the last failures first. This may\n+                            re-order tests and thus lead to repeated fixture\n                             setup/teardown.\n       --nf, --new-first     Run tests from new files first, then the rest of the\n                             tests sorted by file mtime\n       --cache-show=[CACHESHOW]\n-                            Show cache contents, don't perform collection or\n-                            tests. Optional argument: glob (default: '*').\n+                            Show cache contents, don't perform collection or tests.\n+                            Optional argument: glob (default: '*').\n       --cache-clear         Remove all cache contents at start of test run\n       --lfnf={all,none}, --last-failed-no-failures={all,none}\n-                            With ``--lf``, determines whether to execute tests\n-                            when there are no previously (known) failures or\n-                            when no cached ``lastfailed`` data was found.\n-                            ``all`` (the default) runs the full test suite\n-                            again. ``none`` just emits a message about no known\n-                            failures and exits successfully.\n-      --sw, --stepwise      Exit on test failure and continue from last failing\n-                            test next time\n+                            With ``--lf``, determines whether to execute tests when\n+                            there are no previously (known) failures or when no\n+                            cached ``lastfailed`` data was found. ``all`` (the\n+                            default) runs the full test suite again. ``none`` just\n+                            emits a message about no known failures and exits\n+                            successfully.\n+      --sw, --stepwise      Exit on test failure and continue from last failing test\n+                            next time\n       --sw-skip, --stepwise-skip\n                             Ignore the first failing test but stop on the next\n                             failing test. Implicitly enables --stepwise.\n@@ -2006,55 +2005,53 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       -r chars              Show extra test summary info as specified by chars:\n                             (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,\n                             (p)assed, (P)assed with output, (a)ll except passed\n-                            (p/P), or (A)ll. (w)arnings are enabled by default\n-                            (see --disable-warnings), 'N' can be used to reset\n-                            the list. (default: 'fE').\n+                            (p/P), or (A)ll. (w)arnings are enabled by default (see\n+                            --disable-warnings), 'N' can be used to reset the list.\n+                            (default: 'fE').\n       --disable-warnings, --disable-pytest-warnings\n                             Disable warnings summary\n       -l, --showlocals      Show locals in tracebacks (disabled by default)\n-      --no-showlocals       Hide locals in tracebacks (negate --showlocals\n-                            passed through addopts)\n-      --tb=style            Traceback print mode\n-                            (auto/long/short/line/native/no)\n+      --no-showlocals       Hide locals in tracebacks (negate --showlocals passed\n+                            through addopts)\n+      --tb=style            Traceback print mode (auto/long/short/line/native/no)\n+      --xfail-tb            Show tracebacks for xfail (as long as --tb != no)\n       --show-capture={no,stdout,stderr,log,all}\n                             Controls how captured stdout/stderr/log is shown on\n                             failed tests. Default: all.\n       --full-trace          Don't cut any tracebacks (default is to cut)\n       --color=color         Color terminal output (yes/no/auto)\n       --code-highlight={yes,no}\n-                            Whether code should be highlighted (only if --color\n-                            is also enabled). Default: yes.\n+                            Whether code should be highlighted (only if --color is\n+                            also enabled). Default: yes.\n       --pastebin=mode       Send failed|all info to bpaste.net pastebin service\n       --junit-xml=path      Create junit-xml style report file at given path\n       --junit-prefix=str    Prepend prefix to classnames in junit-xml output\n \n     pytest-warnings:\n       -W PYTHONWARNINGS, --pythonwarnings=PYTHONWARNINGS\n-                            Set which warnings to report, see -W option of\n-                            Python itself\n+                            Set which warnings to report, see -W option of Python\n+                            itself\n       --maxfail=num         Exit after first num failures or errors\n       --strict-config       Any warnings encountered while parsing the `pytest`\n                             section of the configuration file raise errors\n-      --strict-markers      Markers not registered in the `markers` section of\n-                            the configuration file raise errors\n+      --strict-markers      Markers not registered in the `markers` section of the\n+                            configuration file raise errors\n       --strict              (Deprecated) alias to --strict-markers\n       -c FILE, --config-file=FILE\n                             Load configuration from `FILE` instead of trying to\n                             locate one of the implicit configuration files.\n       --continue-on-collection-errors\n                             Force test execution even if collection errors occur\n-      --rootdir=ROOTDIR     Define root directory for tests. Can be relative\n-                            path: 'root_dir', './root_dir',\n-                            'root_dir/another_dir/'; absolute path:\n-                            '/home/user/root_dir'; path with variables:\n-                            '$HOME/root_dir'.\n+      --rootdir=ROOTDIR     Define root directory for tests. Can be relative path:\n+                            'root_dir', './root_dir', 'root_dir/another_dir/';\n+                            absolute path: '/home/user/root_dir'; path with\n+                            variables: '$HOME/root_dir'.\n \n     collection:\n       --collect-only, --co  Only collect tests, don't execute them\n       --pyargs              Try to interpret all arguments as Python packages\n       --ignore=path         Ignore path during collection (multi-allowed)\n-      --ignore-glob=path    Ignore path pattern during collection (multi-\n-                            allowed)\n+      --ignore-glob=path    Ignore path pattern during collection (multi-allowed)\n       --deselect=nodeid_prefix\n                             Deselect item (via node id prefix) during collection\n                             (multi-allowed)\n@@ -2064,8 +2061,8 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       --collect-in-virtualenv\n                             Don't ignore tests in a local virtualenv directory\n       --import-mode={prepend,append,importlib}\n-                            Prepend/append to sys.path when importing test\n-                            modules and conftest files. Default: prepend.\n+                            Prepend/append to sys.path when importing test modules\n+                            and conftest files. Default: prepend.\n       --doctest-modules     Run doctests in all .py modules\n       --doctest-report={none,cdiff,ndiff,udiff,only_first_failure}\n                             Choose another output format for diffs on doctest\n@@ -2078,38 +2075,37 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             failure\n \n     test session debugging and configuration:\n-      --basetemp=dir        Base temporary directory for this test run.\n-                            (Warning: this directory is removed if it exists.)\n-      -V, --version         Display pytest version and information about\n-                            plugins. When given twice, also display information\n-                            about plugins.\n+      --basetemp=dir        Base temporary directory for this test run. (Warning:\n+                            this directory is removed if it exists.)\n+      -V, --version         Display pytest version and information about plugins.\n+                            When given twice, also display information about\n+                            plugins.\n       -h, --help            Show help message and configuration info\n       -p name               Early-load given plugin module name or entry point\n-                            (multi-allowed). To avoid loading of plugins, use\n-                            the `no:` prefix, e.g. `no:doctest`.\n+                            (multi-allowed). To avoid loading of plugins, use the\n+                            `no:` prefix, e.g. `no:doctest`.\n       --trace-config        Trace considerations of conftest.py files\n       --debug=[DEBUG_FILE_NAME]\n                             Store internal tracing debug information in this log\n-                            file. This file is opened with 'w' and truncated as\n-                            a result, care advised. Default: pytestdebug.log.\n+                            file. This file is opened with 'w' and truncated as a\n+                            result, care advised. Default: pytestdebug.log.\n       -o OVERRIDE_INI, --override-ini=OVERRIDE_INI\n-                            Override ini option with \"option=value\" style, e.g.\n-                            `-o xfail_strict=True -o cache_dir=cache`.\n+                            Override ini option with \"option=value\" style, e.g. `-o\n+                            xfail_strict=True -o cache_dir=cache`.\n       --assert=MODE         Control assertion debugging tools.\n                             'plain' performs no assertion debugging.\n-                            'rewrite' (the default) rewrites assert statements\n-                            in test modules on import to provide assert\n-                            expression information.\n+                            'rewrite' (the default) rewrites assert statements in\n+                            test modules on import to provide assert expression\n+                            information.\n       --setup-only          Only setup fixtures, do not execute tests\n       --setup-show          Show setup of fixtures while executing tests\n-      --setup-plan          Show what fixtures and tests would be executed but\n-                            don't execute anything\n+      --setup-plan          Show what fixtures and tests would be executed but don't\n+                            execute anything\n \n     logging:\n-      --log-level=LEVEL     Level of messages to catch/display. Not set by\n-                            default, so it depends on the root/parent log\n-                            handler's effective level, where it is \"WARNING\" by\n-                            default.\n+      --log-level=LEVEL     Level of messages to catch/display. Not set by default,\n+                            so it depends on the root/parent log handler's effective\n+                            level, where it is \"WARNING\" by default.\n       --log-format=LOG_FORMAT\n                             Log format used by the logging module\n       --log-date-format=LOG_DATE_FORMAT\n@@ -2133,8 +2129,13 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Auto-indent multiline messages passed to the logging\n                             module. Accepts true|on, false|off or an integer.\n       --log-disable=LOGGER_DISABLE\n-                            Disable a logger by name. Can be passed multiple\n-                            times.\n+                            Disable a logger by name. Can be passed multiple times.\n+\n+    Custom options:\n+      --lsof                Run FD checks if lsof is available\n+      --runpytest={inprocess,subprocess}\n+                            Run pytest sub runs in tests using an 'inprocess' or\n+                            'subprocess' (python -m main) method\n \n     [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg|pyproject.toml file found:\n \n@@ -2149,37 +2150,33 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             warnings.filterwarnings. Processed after\n                             -W/--pythonwarnings.\n       consider_namespace_packages (bool):\n-                            Consider namespace packages when resolving module\n-                            names during import\n-      usefixtures (args):   List of default fixtures to be used with this\n-                            project\n+                            Consider namespace packages when resolving module names\n+                            during import\n+      usefixtures (args):   List of default fixtures to be used with this project\n       python_files (args):  Glob-style file patterns for Python test module\n                             discovery\n       python_classes (args):\n-                            Prefixes or glob names for Python test class\n-                            discovery\n+                            Prefixes or glob names for Python test class discovery\n       python_functions (args):\n                             Prefixes or glob names for Python test function and\n                             method discovery\n       disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool):\n-                            Disable string escape non-ASCII characters, might\n-                            cause unwanted side effects(use at your own risk)\n+                            Disable string escape non-ASCII characters, might cause\n+                            unwanted side effects(use at your own risk)\n       console_output_style (string):\n-                            Console output: \"classic\", or with additional\n-                            progress information (\"progress\" (percentage) |\n-                            \"count\" | \"progress-even-when-capture-no\" (forces\n-                            progress even when capture=no)\n+                            Console output: \"classic\", or with additional progress\n+                            information (\"progress\" (percentage) | \"count\" |\n+                            \"progress-even-when-capture-no\" (forces progress even\n+                            when capture=no)\n       verbosity_test_cases (string):\n                             Specify a verbosity level for test case execution,\n-                            overriding the main level. Higher levels will\n-                            provide more detailed information about each test\n-                            case executed.\n-      xfail_strict (bool):  Default for the strict parameter of xfail markers\n-                            when not given explicitly (default: False)\n+                            overriding the main level. Higher levels will provide\n+                            more detailed information about each test case executed.\n+      xfail_strict (bool):  Default for the strict parameter of xfail markers when\n+                            not given explicitly (default: False)\n       tmp_path_retention_count (string):\n                             How many sessions should we keep the `tmp_path`\n-                            directories, according to\n-                            `tmp_path_retention_policy`.\n+                            directories, according to `tmp_path_retention_policy`.\n       tmp_path_retention_policy (string):\n                             Controls which directories created by the `tmp_path`\n                             fixture are kept around, based on test outcome.\n@@ -2188,9 +2185,9 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Enables the pytest_assertion_pass hook. Make sure to\n                             delete any previously generated pyc cache files.\n       verbosity_assertions (string):\n-                            Specify a verbosity level for assertions, overriding\n-                            the main level. Higher levels will provide more\n-                            detailed explanation when an assertion fails.\n+                            Specify a verbosity level for assertions, overriding the\n+                            main level. Higher levels will provide more detailed\n+                            explanation when an assertion fails.\n       junit_suite_name (string):\n                             Test suite name for JUnit report\n       junit_logging (string):\n@@ -2212,8 +2209,8 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       log_format (string):  Default value for --log-format\n       log_date_format (string):\n                             Default value for --log-date-format\n-      log_cli (bool):       Enable log display during test run (also known as\n-                            \"live logging\")\n+      log_cli (bool):       Enable log display during test run (also known as \"live\n+                            logging\")\n       log_cli_level (string):\n                             Default value for --log-cli-level\n       log_cli_format (string):\n@@ -2233,14 +2230,18 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Default value for --log-auto-indent\n       pythonpath (paths):   Add paths to sys.path\n       faulthandler_timeout (string):\n-                            Dump the traceback of all threads if a test takes\n-                            more than TIMEOUT seconds to finish\n+                            Dump the traceback of all threads if a test takes more\n+                            than TIMEOUT seconds to finish\n       addopts (args):       Extra command line options\n       minversion (string):  Minimally required pytest version\n       required_plugins (args):\n                             Plugins that must be present for pytest to run\n+      pytester_example_dir (string):\n+                            Directory to take the pytester example files from\n \n     Environment variables:\n+      CI                       When set (regardless of value), pytest knows it is running in a CI process and does not truncate summary info\n+      BUILD_NUMBER             equivalent to CI\n       PYTEST_ADDOPTS           Extra command line options\n       PYTEST_PLUGINS           Comma-separated plugins to load during startup\n       PYTEST_DISABLE_PLUGIN_AUTOLOAD Set to disable plugin auto-loading\n", "test_patch": "diff --git a/src/_pytest/helpconfig.py b/src/_pytest/helpconfig.py\nindex fa7c322cf8e..bb8b27a2390 100644\n--- a/src/_pytest/helpconfig.py\n+++ b/src/_pytest/helpconfig.py\n@@ -212,6 +212,12 @@ def showhelp(config: Config) -> None:\n     tw.line()\n     tw.line(\"Environment variables:\")\n     vars = [\n+        (\n+            \"CI\",\n+            \"When set (regardless of value), pytest knows it is running in a \"\n+            \"CI process and does not truncate summary info\",\n+        ),\n+        (\"BUILD_NUMBER\", \"Equivalent to CI\"),\n         (\"PYTEST_ADDOPTS\", \"Extra command line options\"),\n         (\"PYTEST_PLUGINS\", \"Comma-separated plugins to load during startup\"),\n         (\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"Set to disable plugin auto-loading\"),\n", "problem_statement": "Mention CI and BUILD_NUMBER in `pytest -h`\nFollowing up on https://github.com/pytest-dev/pytest/issues/10690, the two env variables are still missing from `pytest -h`and from the corresponding doc (https://docs.pytest.org/en/latest/reference/reference.html#command-line-flags) \n", "hints_text": "", "created_at": "2024-07-08T13:27:11Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12584, "instance_id": "pytest-dev__pytest-12584", "issue_numbers": ["12576"], "base_commit": "99f0662def864400ae5698a1f874cbb0724c2624", "patch": "diff --git a/doc/en/_templates/globaltoc.html b/doc/en/_templates/globaltoc.html\ndeleted file mode 100644\nindex 09d970b64ed..00000000000\n--- a/doc/en/_templates/globaltoc.html\n+++ /dev/null\n@@ -1,31 +0,0 @@\n-<h3>Contents</h3>\n-\n-<ul>\n-  <li><a href=\"{{ pathto('index') }}\">Home</a></li>\n-\n-  <li><a href=\"{{ pathto('getting-started') }}\">Get started</a></li>\n-  <li><a href=\"{{ pathto('how-to/index') }}\">How-to guides</a></li>\n-  <li><a href=\"{{ pathto('reference/index') }}\">Reference guides</a></li>\n-  <li><a href=\"{{ pathto('explanation/index') }}\">Explanation</a></li>\n-  <li><a href=\"{{ pathto('contents') }}\">Complete table of contents</a></li>\n-  <li><a href=\"{{ pathto('example/index') }}\">Library of examples</a></li>\n-</ul>\n-\n-<h3>About the project</h3>\n-\n-<ul>\n-  <li><a href=\"{{ pathto('changelog') }}\">Changelog</a></li>\n-  <li><a href=\"{{ pathto('contributing') }}\">Contributing</a></li>\n-  <li><a href=\"{{ pathto('backwards-compatibility') }}\">Backwards Compatibility</a></li>\n-  <li><a href=\"{{ pathto('sponsor') }}\">Sponsor</a></li>\n-  <li><a href=\"{{ pathto('tidelift') }}\">pytest for Enterprise</a></li>\n-  <li><a href=\"{{ pathto('license') }}\">License</a></li>\n-  <li><a href=\"{{ pathto('contact') }}\">Contact Channels</a></li>\n-</ul>\n-\n-{%- if display_toc %}\n-  <hr>\n-  {{ toc }}\n-{%- endif %}\n-\n-<hr>\ndiff --git a/doc/en/_templates/layout.html b/doc/en/_templates/layout.html\ndeleted file mode 100644\nindex f7096eaaa5e..00000000000\n--- a/doc/en/_templates/layout.html\n+++ /dev/null\n@@ -1,52 +0,0 @@\n-{#\n-\n-    Copied from:\n-\n-     https://raw.githubusercontent.com/pallets/pallets-sphinx-themes/b0c6c41849b4e15cbf62cc1d95c05ef2b3e155c8/src/pallets_sphinx_themes/themes/pocoo/layout.html\n-\n-    And removed the warning version (see #7331).\n-\n-#}\n-\n-{% extends \"basic/layout.html\" %}\n-\n-{% set metatags %}\n-  {{- metatags }}\n-  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n-{%- endset %}\n-\n-{% block extrahead %}\n-  {%- if page_canonical_url %}\n-    <link rel=\"canonical\" href=\"{{ page_canonical_url }}\">\n-  {%- endif %}\n-  <script>DOCUMENTATION_OPTIONS.URL_ROOT = '{{ url_root }}';</script>\n-  {{ super() }}\n-{%- endblock %}\n-\n-{% block sidebarlogo %}\n-  {% if pagename != \"index\" or theme_index_sidebar_logo %}\n-    {{ super() }}\n-  {% endif %}\n-{% endblock %}\n-\n-{% block relbar2 %}{% endblock %}\n-\n-{% block sidebar2 %}\n-  <span id=\"sidebar-top\"></span>\n-  {{- super() }}\n-{%- endblock %}\n-\n-{% block footer %}\n-  {{ super() }}\n-  {%- if READTHEDOCS and not readthedocs_docsearch %}\n-    <script>\n-      if (typeof READTHEDOCS_DATA !== 'undefined') {\n-        if (!READTHEDOCS_DATA.features) {\n-          READTHEDOCS_DATA.features = {};\n-        }\n-        READTHEDOCS_DATA.features.docsearch_disabled = true;\n-      }\n-    </script>\n-  {%- endif %}\n-  {{ js_tag(\"_static/version_warning_offset.js\") }}\n-{% endblock %}\ndiff --git a/doc/en/_templates/relations.html b/doc/en/_templates/relations.html\ndeleted file mode 100644\nindex 3bbcde85bb4..00000000000\n--- a/doc/en/_templates/relations.html\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-<h3>Related Topics</h3>\n-<ul>\n-  <li><a href=\"{{ pathto(master_doc) }}\">Documentation overview</a><ul>\n-  {%- for parent in parents %}\n-  <li><a href=\"{{ parent.link|e }}\">{{ parent.title }}</a><ul>\n-  {%- endfor %}\n-    {%- if prev %}\n-      <li>Previous: <a href=\"{{ prev.link|e }}\" title=\"{{ _('previous chapter')\n-        }}\">{{ prev.title }}</a></li>\n-    {%- endif %}\n-    {%- if next %}\n-      <li>Next: <a href=\"{{ next.link|e }}\" title=\"{{ _('next chapter')\n-        }}\">{{ next.title }}</a></li>\n-    {%- endif %}\n-  {%- for parent in parents %}\n-  </ul></li>\n-  {%- endfor %}\n-  </ul></li>\n-</ul>\ndiff --git a/doc/en/_templates/sidebar/brand.html b/doc/en/_templates/sidebar/brand.html\ndeleted file mode 100644\nindex f997c4cca5f..00000000000\n--- a/doc/en/_templates/sidebar/brand.html\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-<style>\n-    .logo {text-align: center;}\n-</style>\n-\n-<a class=\"logo\" href=\"{{ pathto('contents') }}\">\n-    <img src=\"{{ pathto('_static/pytest1.png', 1) }}\" width=\"70%\" height=\"70%\" text=\"Pytest Logo\"/>\n-</a>\ndiff --git a/doc/en/_templates/sidebarintro.html b/doc/en/_templates/sidebarintro.html\ndeleted file mode 100644\nindex ae860c172f0..00000000000\n--- a/doc/en/_templates/sidebarintro.html\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-<h3>About pytest</h3>\n-<p>\n-  pytest is a mature full-featured Python testing tool that helps\n-  you write better programs.\n-</p>\ndiff --git a/doc/en/_templates/style.html b/doc/en/_templates/style.html\ndeleted file mode 100644\nindex 400cb75ff97..00000000000\n--- a/doc/en/_templates/style.html\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-<style>\n-    ul {list-style: none;}\n-    li {margin: 0.4em 0;}\n-    @media (min-width: 46em) {\n-        #features {width: 50%;}\n-    }\n-</style>\ndiff --git a/doc/en/conf.py b/doc/en/conf.py\nindex 0d440ec448a..9558a75f927 100644\n--- a/doc/en/conf.py\n+++ b/doc/en/conf.py\n@@ -1,20 +1,3 @@\n-#\n-# pytest documentation build configuration file, created by\n-# sphinx-quickstart on Fri Oct  8 17:54:28 2010.\n-#\n-# This file is execfile()d with the current directory set to its containing dir.\n-#\n-# Note that not all possible configuration values are present in this\n-# autogenerated file.\n-#\n-# All configuration values have a default; values that are commented out\n-# serve to show the default.\n-# The version info for the project you're documenting, acts as replacement for\n-# |version| and |release|, also used in various other places throughout the\n-# built documents.\n-#\n-# The full version, including alpha/beta/rc tags.\n-# The short X.Y version.\n from __future__ import annotations\n \n import os\n@@ -23,61 +6,26 @@\n from textwrap import dedent\n from typing import TYPE_CHECKING\n \n-from _pytest import __version__ as full_version\n+from pytest import __version__ as full_version\n \n \n-version = full_version.split(\"+\")[0]\n-\n if TYPE_CHECKING:\n     import sphinx.application\n \n-\n PROJECT_ROOT_DIR = Path(__file__).parents[2].resolve()\n-IS_RELEASE_ON_RTD = (\n-    os.getenv(\"READTHEDOCS\", \"False\") == \"True\"\n-    and os.environ[\"READTHEDOCS_VERSION_TYPE\"] == \"tag\"\n-)\n-if IS_RELEASE_ON_RTD:\n-    tags: set[str]\n-    # pylint: disable-next=used-before-assignment\n-    tags.add(\"is_release\")  # noqa: F821\n-\n-release = \".\".join(version.split(\".\")[:2])\n-\n-# If extensions (or modules to document with autodoc) are in another directory,\n-# add these directories to sys.path here. If the directory is relative to the\n-# documentation root, use os.path.abspath to make it absolute, like shown here.\n-# sys.path.insert(0, os.path.abspath('.'))\n-\n-autodoc_member_order = \"bysource\"\n-autodoc_typehints = \"description\"\n-autodoc_typehints_description_target = \"documented\"\n-todo_include_todos = 1\n-\n-latex_engine = \"lualatex\"\n-\n-latex_elements = {\n-    \"preamble\": dedent(\n-        r\"\"\"\n-        \\directlua{\n-            luaotfload.add_fallback(\"fallbacks\", {\n-                \"Noto Serif CJK SC:style=Regular;\",\n-                \"Symbola:Style=Regular;\"\n-            })\n-        }\n \n-        \\setmainfont{FreeSerif}[RawFeature={fallback=fallbacks}]\n-        \"\"\"\n-    )\n-}\n+# -- Project information ---------------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n \n-# -- General configuration -----------------------------------------------------\n+project = \"pytest\"\n+copyright = \"2015, holger krekel and pytest-dev team\"\n+version = full_version.split(\"+\")[0]\n+release = \".\".join(version.split(\".\")[:2])\n \n-# If your documentation needs a minimal Sphinx version, state it here.\n-# needs_sphinx = '1.0'\n+# -- General configuration -------------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n \n-# Add any Sphinx extension module names here, as strings. They can be extensions\n-# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n+root_doc = \"index\"\n extensions = [\n     \"pygments_pytest\",\n     \"sphinx.ext.autodoc\",\n@@ -98,35 +46,6 @@\n if shutil.which(\"inkscape\"):\n     extensions.append(\"sphinxcontrib.inkscapeconverter\")\n \n-# Add any paths that contain templates here, relative to this directory.\n-templates_path = [\"_templates\"]\n-\n-# The suffix of source filenames.\n-source_suffix = \".rst\"\n-\n-# The encoding of source files.\n-# source_encoding = 'utf-8-sig'\n-\n-# The master toctree document.\n-master_doc = \"contents\"\n-\n-# General information about the project.\n-project = \"pytest\"\n-copyright = \"2015, holger krekel and pytest-dev team\"\n-\n-\n-# The language for content autogenerated by Sphinx. Refer to documentation\n-# for a list of supported languages.\n-# language = None\n-\n-# There are two options for replacing |today|: either, you set today to some\n-# non-false value, then it is used:\n-# today = ''\n-# Else, today_fmt is used as the format for a strftime call.\n-# today_fmt = '%B %d, %Y'\n-\n-# List of patterns, relative to source directory, that match files and\n-# directories to ignore when looking for source files.\n exclude_patterns = [\n     \"_build\",\n     \"naming20.rst\",\n@@ -138,38 +57,9 @@\n     \"setup.rst\",\n     \"example/remoteinterp.rst\",\n ]\n-\n-\n-# The reST default role (used for this markup: `text`) to use for all documents.\n+templates_path = [\"_templates\"]\n default_role = \"literal\"\n \n-# If true, '()' will be appended to :func: etc. cross-reference text.\n-# add_function_parentheses = True\n-\n-# If true, the current module name will be prepended to all description\n-# unit titles (such as .. function::).\n-add_module_names = False\n-\n-# If true, sectionauthor and moduleauthor directives will be shown in the\n-# output. They are ignored by default.\n-# show_authors = False\n-\n-# A list of ignored prefixes for module index sorting.\n-# modindex_common_prefix = []\n-\n-# A list of regular expressions that match URIs that should not be checked when\n-# doing a linkcheck.\n-linkcheck_ignore = [\n-    \"https://blogs.msdn.microsoft.com/bharry/2017/06/28/testing-in-a-cloud-delivery-cadence/\",\n-    \"http://pythontesting.net/framework/pytest-introduction/\",\n-    r\"https://github.com/pytest-dev/pytest/issues/\\d+\",\n-    r\"https://github.com/pytest-dev/pytest/pull/\\d+\",\n-]\n-\n-# The number of worker threads to use when checking links (default=5).\n-linkcheck_workers = 5\n-\n-\n nitpicky = True\n nitpick_ignore = [\n     # TODO (fix in pluggy?)\n@@ -217,126 +107,91 @@\n     (\"py:class\", \"_ScopeName\"),\n ]\n \n+add_module_names = False\n \n-# -- Options for HTML output ---------------------------------------------------\n-\n-# The theme to use for HTML and HTML Help pages.  See the documentation for\n-# a list of builtin themes.\n-html_theme = \"furo\"\n+# -- Options for Autodoc --------------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html#configuration\n \n-# Theme options are theme-specific and customize the look and feel of a theme\n-# further.  For a list of options available for each theme, see the\n-# documentation.\n-# html_theme_options = {\"index_logo\": None}\n+autodoc_member_order = \"bysource\"\n+autodoc_typehints = \"description\"\n+autodoc_typehints_description_target = \"documented\"\n \n-# Add any paths that contain custom themes here, relative to this directory.\n-# html_theme_path = []\n+# -- Options for intersphinx ----------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html#configuration\n \n-# The name for this set of Sphinx documents.  If None, it defaults to\n-# \"<project> v<release> documentation\".\n-html_title = \"pytest documentation\"\n+intersphinx_mapping = {\n+    \"pluggy\": (\"https://pluggy.readthedocs.io/en/stable\", None),\n+    \"python\": (\"https://docs.python.org/3\", None),\n+    \"numpy\": (\"https://numpy.org/doc/stable\", None),\n+    \"pip\": (\"https://pip.pypa.io/en/stable\", None),\n+    \"tox\": (\"https://tox.wiki/en/stable\", None),\n+    \"virtualenv\": (\"https://virtualenv.pypa.io/en/stable\", None),\n+    \"setuptools\": (\"https://setuptools.pypa.io/en/stable\", None),\n+    \"packaging\": (\"https://packaging.python.org/en/latest\", None),\n+}\n \n-# A shorter title for the navigation bar.  Default is the same as html_title.\n-html_short_title = f\"pytest-{release}\"\n+# -- Options for todo -----------------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/extensions/todo.html#configuration\n \n-# The name of an image file (relative to this directory) to place at the top\n-# of the sidebar.\n-html_logo = \"img/pytest_logo_curves.svg\"\n+todo_include_todos = True\n \n-# The name of an image file (within the static path) to use as favicon of the\n-# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n-# pixels large.\n-html_favicon = \"img/favicon.png\"\n+# -- Options for linkcheck builder ----------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-the-linkcheck-builder\n \n-# Add any paths that contain custom static files (such as style sheets) here,\n-# relative to this directory. They are copied after the builtin static files,\n-# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n-# html_static_path = ['_static']\n-\n-# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n-# using the given strftime format.\n-# html_last_updated_fmt = '%b %d, %Y'\n-\n-# If true, SmartyPants will be used to convert quotes and dashes to\n-# typographically correct entities.\n-# html_use_smartypants = True\n-\n-# Custom sidebar templates, maps document names to template names.\n-# html_sidebars = {}\n-# html_sidebars = {'index': 'indexsidebar.html'}\n-\n-html_sidebars = {\n-    \"index\": [\n-        \"sidebar/brand.html\",\n-        \"sidebar/search.html\",\n-        \"sidebar/scroll-start.html\",\n-        \"sidebarintro.html\",\n-        \"globaltoc.html\",\n-        \"links.html\",\n-        \"sidebar/scroll-end.html\",\n-        \"style.html\",\n-    ],\n-    \"**\": [\n-        \"sidebar/brand.html\",\n-        \"sidebar/search.html\",\n-        \"sidebar/scroll-start.html\",\n-        \"globaltoc.html\",\n-        \"relations.html\",\n-        \"links.html\",\n-        \"sidebar/scroll-end.html\",\n-        \"style.html\",\n-    ],\n-}\n+linkcheck_ignore = [\n+    \"https://blogs.msdn.microsoft.com/bharry/2017/06/28/testing-in-a-cloud-delivery-cadence/\",\n+    \"http://pythontesting.net/framework/pytest-introduction/\",\n+    r\"https://github.com/pytest-dev/pytest/issues/\\d+\",\n+    r\"https://github.com/pytest-dev/pytest/pull/\\d+\",\n+]\n+linkcheck_workers = 5\n \n-# Additional templates that should be rendered to pages, maps page names to\n-# template names.\n-# html_additional_pages = {}\n-# html_additional_pages = {'index': 'index.html'}\n+# -- Options for HTML output ----------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n \n+html_theme = \"furo\"\n+html_theme_options = {\"sidebar_hide_name\": True}\n \n-# If false, no module index is generated.\n-html_domain_indices = True\n+html_static_path = [\"_static\"]\n+html_css_files = [\n+    \"pytest-custom.css\",\n+]\n \n-# If false, no index is generated.\n-html_use_index = False\n+html_title = \"pytest documentation\"\n+html_short_title = f\"pytest-{release}\"\n \n-# If true, the index is split into individual pages for each letter.\n-# html_split_index = False\n+html_logo = \"_static/pytest1.png\"\n+html_favicon = \"img/favicon.png\"\n \n-# If true, links to the reST sources are added to the pages.\n+html_use_index = False\n html_show_sourcelink = False\n \n-# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n-# html_show_sphinx = True\n+html_baseurl = \"https://docs.pytest.org/en/stable/\"\n \n-# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n-# html_show_copyright = True\n+# -- Options for HTML Help output -----------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-help-output\n \n-# If true, an OpenSearch description file will be output, and all pages will\n-# contain a <link> tag referring to it.  The value of this option must be the\n-# base URL from which the finished HTML is served.\n-# html_use_opensearch = ''\n+htmlhelp_basename = \"pytestdoc\"\n \n-# This is the file name suffix for HTML files (e.g. \".xhtml\").\n-# html_file_suffix = None\n \n-# Output file base name for HTML help builder.\n-htmlhelp_basename = \"pytestdoc\"\n+# -- Options for manual page output ---------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-manual-page-output\n \n-# The base URL which points to the root of the HTML documentation. It is used\n-# to indicate the location of document using the canonical link relation (#12363).\n-html_baseurl = \"https://docs.pytest.org/en/stable/\"\n+man_pages = [\n+    (\"how-to/usage\", \"pytest\", \"pytest usage\", [\"holger krekel at merlinux eu\"], 1)\n+]\n \n-# -- Options for LaTeX output --------------------------------------------------\n+# -- Options for epub output ----------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-epub-output\n \n-# The paper size ('letter' or 'a4').\n-# latex_paper_size = 'letter'\n+epub_title = \"pytest\"\n+epub_author = \"holger krekel at merlinux eu\"\n+epub_publisher = \"holger krekel at merlinux eu\"\n+epub_copyright = \"2013, holger krekel et alii\"\n \n-# The font size ('10pt', '11pt' or '12pt').\n-# latex_font_size = '10pt'\n+# -- Options for LaTeX output --------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-latex-output\n \n-# Grouping the document tree into LaTeX files. List of tuples\n-# (source start file, target name, title, author, documentclass [howto/manual]).\n latex_documents = [\n     (\n         \"contents\",\n@@ -346,80 +201,29 @@\n         \"manual\",\n     )\n ]\n-\n-# For \"manual\" documents, if this is true, then toplevel headings are parts,\n-# not chapters.\n-# latex_use_parts = False\n-\n-# If true, show page references after internal links.\n-# latex_show_pagerefs = False\n-\n-# If true, show URL addresses after external links.\n-# latex_show_urls = False\n-\n-# Additional stuff for the LaTeX preamble.\n-# latex_preamble = ''\n-\n-# Documents to append as an appendix to all manuals.\n-# latex_appendices = []\n-\n-# If false, no module index is generated.\n latex_domain_indices = False\n+latex_engine = \"lualatex\"\n+latex_elements = {\n+    \"preamble\": dedent(\n+        r\"\"\"\n+        \\directlua{\n+            luaotfload.add_fallback(\"fallbacks\", {\n+                \"Noto Serif CJK SC:style=Regular;\",\n+                \"Symbola:Style=Regular;\"\n+            })\n+        }\n \n-# -- Options for manual page output --------------------------------------------\n-\n-# One entry per manual page. List of tuples\n-# (source start file, name, description, authors, manual section).\n-man_pages = [\n-    (\"how-to/usage\", \"pytest\", \"pytest usage\", [\"holger krekel at merlinux eu\"], 1)\n-]\n-\n-\n-# -- Options for Epub output ---------------------------------------------------\n-\n-# Bibliographic Dublin Core info.\n-epub_title = \"pytest\"\n-epub_author = \"holger krekel at merlinux eu\"\n-epub_publisher = \"holger krekel at merlinux eu\"\n-epub_copyright = \"2013, holger krekel et alii\"\n-\n-# The language of the text. It defaults to the language option\n-# or en if the language is not set.\n-# epub_language = ''\n-\n-# The scheme of the identifier. Typical schemes are ISBN or URL.\n-# epub_scheme = ''\n-\n-# The unique identifier of the text. This can be an ISBN number\n-# or the project homepage.\n-# epub_identifier = ''\n-\n-# A unique identification for the text.\n-# epub_uid = ''\n-\n-# HTML files that should be inserted before the pages created by sphinx.\n-# The format is a list of tuples containing the path and title.\n-# epub_pre_files = []\n-\n-# HTML files that should be inserted after the pages created by sphinx.\n-# The format is a list of tuples containing the path and title.\n-# epub_post_files = []\n-\n-# A list of files that should not be packed into the epub file.\n-# epub_exclude_files = []\n-\n-# The depth of the table of contents in toc.ncx.\n-# epub_tocdepth = 3\n-\n-# Allow duplicate toc entries.\n-# epub_tocdup = True\n-\n+        \\setmainfont{FreeSerif}[RawFeature={fallback=fallbacks}]\n+        \"\"\"\n+    )\n+}\n \n-# -- Options for texinfo output ------------------------------------------------\n+# -- Options for texinfo output -------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-texinfo-output\n \n texinfo_documents = [\n     (\n-        master_doc,\n+        root_doc,\n         \"pytest\",\n         \"pytest Documentation\",\n         (\n@@ -433,29 +237,34 @@\n     )\n ]\n \n-# -- Options for towncrier_draft extension -----------------------------------\n+# -- Options for towncrier_draft extension --------------------------------------------\n+# https://sphinxcontrib-towncrier.readthedocs.io/en/latest/#how-to-use-this\n \n towncrier_draft_autoversion_mode = \"draft\"  # or: 'sphinx-version', 'sphinx-release'\n towncrier_draft_include_empty = True\n towncrier_draft_working_directory = PROJECT_ROOT_DIR\n towncrier_draft_config_path = \"pyproject.toml\"  # relative to cwd\n \n-\n # -- Options for sphinx_issues extension -----------------------------------\n+# https://github.com/sloria/sphinx-issues#installation-and-configuration\n \n issues_github_path = \"pytest-dev/pytest\"\n \n+# -- Custom Read the Docs build configuration -----------------------------------------\n+# https://docs.readthedocs.io/en/stable/reference/environment-variables.html#environment-variable-reference\n+# https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html#including-content-based-on-tags\n \n-intersphinx_mapping = {\n-    \"pluggy\": (\"https://pluggy.readthedocs.io/en/stable\", None),\n-    \"python\": (\"https://docs.python.org/3\", None),\n-    \"numpy\": (\"https://numpy.org/doc/stable\", None),\n-    \"pip\": (\"https://pip.pypa.io/en/stable\", None),\n-    \"tox\": (\"https://tox.wiki/en/stable\", None),\n-    \"virtualenv\": (\"https://virtualenv.pypa.io/en/stable\", None),\n-    \"setuptools\": (\"https://setuptools.pypa.io/en/stable\", None),\n-    \"packaging\": (\"https://packaging.python.org/en/latest\", None),\n-}\n+IS_RELEASE_ON_RTD = (\n+    os.getenv(\"READTHEDOCS\", \"False\") == \"True\"\n+    and os.environ[\"READTHEDOCS_VERSION_TYPE\"] == \"tag\"\n+)\n+if IS_RELEASE_ON_RTD:\n+    tags: set[str]\n+    # pylint: disable-next=used-before-assignment\n+    tags.add(\"is_release\")  # noqa: F821\n+\n+# -- Custom documentation plugin ------------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/development/tutorials/extending_syntax.html#the-setup-function\n \n \n def setup(app: sphinx.application.Sphinx) -> None:\ndiff --git a/doc/en/contents.rst b/doc/en/contents.rst\nindex 181207203b2..07c0b3ff6b9 100644\n--- a/doc/en/contents.rst\n+++ b/doc/en/contents.rst\n@@ -1,3 +1,5 @@\n+:orphan:\n+\n .. _toc:\n \n Full pytest documentation\ndiff --git a/doc/en/index.rst b/doc/en/index.rst\nindex 8de3b3993dd..a907d1ff549 100644\n--- a/doc/en/index.rst\n+++ b/doc/en/index.rst\n@@ -1,5 +1,3 @@\n-:orphan:\n-\n .. _features:\n \n .. sidebar:: **Next Open Trainings and Events**\n@@ -13,6 +11,36 @@\n pytest: helps you write better programs\n =======================================\n \n+.. toctree::\n+    :hidden:\n+\n+    getting-started\n+    how-to/index\n+    reference/index\n+    explanation/index\n+    example/index\n+\n+.. toctree::\n+    :caption: About the project\n+    :hidden:\n+\n+    changelog\n+    contributing\n+    backwards-compatibility\n+    sponsor\n+    tidelift\n+    license\n+    contact\n+\n+.. toctree::\n+    :caption: Useful links\n+    :hidden:\n+\n+    pytest @ PyPI <https://pypi.org/project/pytest/>\n+    pytest @ GitHub <https://github.com/pytest-dev/pytest/>\n+    Issue Tracker <https://github.com/pytest-dev/pytest/issues>\n+    PDF Documentation <https://media.readthedocs.org/pdf/pytest/latest/pytest.pdf>\n+\n .. module:: pytest\n \n The ``pytest`` framework makes it easy to write small, readable tests, and can\n", "test_patch": "diff --git a/doc/en/_static/pytest-custom.css b/doc/en/_static/pytest-custom.css\nnew file mode 100644\nindex 00000000000..bc9eef457f1\n--- /dev/null\n+++ b/doc/en/_static/pytest-custom.css\n@@ -0,0 +1,21 @@\n+/* Tweak how the sidebar logo is presented */\n+.sidebar-logo {\n+  width: 70%;\n+}\n+.sidebar-brand {\n+  padding: 0;\n+}\n+\n+/* The landing pages' sidebar-in-content highlights */\n+#features ul {\n+  padding-left: 1rem;\n+  list-style: none;\n+}\n+#features ul li {\n+  margin-bottom: 0;\n+}\n+@media (min-width: 46em) {\n+  #features {\n+    width: 50%;\n+  }\n+}\n", "problem_statement": "Inject CSS via `html_css_files` rather than inline styles in the sidebar\nSee https://pradyunsg.me/furo/customisation/injecting/#css-or-js for the guidance from the theme for how to inject CSS.\r\n\r\n_Originally posted by @pradyunsg in https://github.com/pytest-dev/pytest/pull/12326#discussion_r1666516622_\n", "hints_text": "Thanks @pradyunsg!\r\n\r\nMarking @samjirovec here in case he would like to tackle this.", "created_at": "2024-07-07T12:31:31Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12578, "instance_id": "pytest-dev__pytest-12578", "issue_numbers": ["12577"], "base_commit": "e19ad1f7a11ab51d020107dcbbf588db8cee669f", "patch": "diff --git a/changelog/12577.doc.rst b/changelog/12577.doc.rst\nnew file mode 100644\nindex 0000000000..0bd427e177\n--- /dev/null\n+++ b/changelog/12577.doc.rst\n@@ -0,0 +1,3 @@\n+`CI` and `BUILD_NUMBER` environment variables role is discribed in\n+the reference doc. They now also appears when doing `pytest -h`\n+-- by :user:`MarcBresson`.\ndiff --git a/doc/en/explanation/ci.rst b/doc/en/explanation/ci.rst\nnew file mode 100644\nindex 0000000000..45fe658d14\n--- /dev/null\n+++ b/doc/en/explanation/ci.rst\n@@ -0,0 +1,70 @@\n+.. _`ci-pipelines`:\n+\n+CI Pipelines\n+============\n+\n+Rationale\n+---------\n+\n+The goal of testing in a CI pipeline is different from testing locally. Indeed,\n+you can quickly edit some code and run your tests again on your computer, but\n+it is not possible with CI pipeline. They run on a separate server and are\n+triggered by specific actions.\n+\n+From that observation, pytest can detect when it is in a CI environment and\n+adapt some of its behaviours.\n+\n+How CI is detected\n+------------------\n+\n+Pytest knows it is in a CI environment when either one of these environment variables are set,\n+regardless of their value:\n+\n+* `CI`: used by many CI systems.\n+* `BUILD_NUMBER`: used by Jenkins.\n+\n+Effects on CI\n+-------------\n+\n+For now, the effects on pytest of being in a CI environment are limited.\n+\n+When a CI environment is detected, the output of the short test summary info is no longer truncated to the terminal size i.e. the entire message will be shown.\n+\n+  .. code-block:: python\n+\n+        # content of test_ci.py\n+        import pytest\n+\n+\n+        def test_db_initialized():\n+            pytest.fail(\n+                \"deliberately failing for demo purpose, Lorem ipsum dolor sit amet, \"\n+                \"consectetur adipiscing elit. Cras facilisis, massa in suscipit \"\n+                \"dignissim, mauris lacus molestie nisi, quis varius metus nulla ut ipsum.\"\n+            )\n+\n+\n+Running this locally, without any extra options, will output:\n+\n+  .. code-block:: pytest\n+\n+     $ pytest test_ci.py\n+     ...\n+     ========================= short test summary info ==========================\n+     FAILED test_backends.py::test_db_initialized[d2] - Failed: deliberately f...\n+\n+*(Note the truncated text)*\n+\n+\n+While running this on CI will output:\n+\n+  .. code-block:: pytest\n+\n+     $ export CI=true\n+     $ pytest test_ci.py\n+     ...\n+     ========================= short test summary info ==========================\n+     FAILED test_backends.py::test_db_initialized[d2] - Failed: deliberately failing\n+     for demo purpose, Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras\n+     facilisis, massa in suscipit dignissim, mauris lacus molestie nisi, quis varius\n+     metus nulla ut ipsum.\ndiff --git a/doc/en/explanation/index.rst b/doc/en/explanation/index.rst\nindex 53910f1eb7..2edf60a5d8 100644\n--- a/doc/en/explanation/index.rst\n+++ b/doc/en/explanation/index.rst\n@@ -11,5 +11,6 @@ Explanation\n    anatomy\n    fixtures\n    goodpractices\n-   flaky\n    pythonpath\n+   ci\n+   flaky\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 6926cd61bd..d1222728e1 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1120,11 +1120,11 @@ Environment variables that can be used to change pytest's behavior.\n \n .. envvar:: CI\n \n-When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to ``BUILD_NUMBER`` variable.\n+When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to ``BUILD_NUMBER`` variable. See also :ref:`ci-pipelines`.\n \n .. envvar:: BUILD_NUMBER\n \n-When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to CI variable.\n+When set (regardless of value), pytest acknowledges that is running in a CI process. Alternative to CI variable. See also :ref:`ci-pipelines`.\n \n .. envvar:: PYTEST_ADDOPTS\n \n@@ -1939,19 +1939,18 @@ All the command-line flags can be obtained by running ``pytest --help``::\n     general:\n       -k EXPRESSION         Only run tests which match the given substring\n                             expression. An expression is a Python evaluable\n-                            expression where all names are substring-matched\n-                            against test names and their parent classes.\n-                            Example: -k 'test_method or test_other' matches all\n-                            test functions and classes whose name contains\n-                            'test_method' or 'test_other', while -k 'not\n-                            test_method' matches those that don't contain\n-                            'test_method' in their names. -k 'not test_method\n-                            and not test_other' will eliminate the matches.\n-                            Additionally keywords are matched to classes and\n-                            functions containing extra names in their\n-                            'extra_keyword_matches' set, as well as functions\n-                            which have names assigned directly to them. The\n-                            matching is case-insensitive.\n+                            expression where all names are substring-matched against\n+                            test names and their parent classes. Example: -k\n+                            'test_method or test_other' matches all test functions\n+                            and classes whose name contains 'test_method' or\n+                            'test_other', while -k 'not test_method' matches those\n+                            that don't contain 'test_method' in their names. -k 'not\n+                            test_method and not test_other' will eliminate the\n+                            matches. Additionally keywords are matched to classes\n+                            and functions containing extra names in their\n+                            'extra_keyword_matches' set, as well as functions which\n+                            have names assigned directly to them. The matching is\n+                            case-insensitive.\n       -m MARKEXPR           Only run tests matching given mark expression. For\n                             example: -m 'mark1 and not mark2'.\n       --markers             show markers (builtin, plugin and per-project ones).\n@@ -1969,28 +1968,28 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       --trace               Immediately break when running each test\n       --capture=method      Per-test capturing method: one of fd|sys|no|tee-sys\n       -s                    Shortcut for --capture=no\n-      --runxfail            Report the results of xfail tests as if they were\n-                            not marked\n-      --lf, --last-failed   Rerun only the tests that failed at the last run (or\n-                            all if none failed)\n-      --ff, --failed-first  Run all tests, but run the last failures first. This\n-                            may re-order tests and thus lead to repeated fixture\n+      --runxfail            Report the results of xfail tests as if they were not\n+                            marked\n+      --lf, --last-failed   Rerun only the tests that failed at the last run (or all\n+                            if none failed)\n+      --ff, --failed-first  Run all tests, but run the last failures first. This may\n+                            re-order tests and thus lead to repeated fixture\n                             setup/teardown.\n       --nf, --new-first     Run tests from new files first, then the rest of the\n                             tests sorted by file mtime\n       --cache-show=[CACHESHOW]\n-                            Show cache contents, don't perform collection or\n-                            tests. Optional argument: glob (default: '*').\n+                            Show cache contents, don't perform collection or tests.\n+                            Optional argument: glob (default: '*').\n       --cache-clear         Remove all cache contents at start of test run\n       --lfnf={all,none}, --last-failed-no-failures={all,none}\n-                            With ``--lf``, determines whether to execute tests\n-                            when there are no previously (known) failures or\n-                            when no cached ``lastfailed`` data was found.\n-                            ``all`` (the default) runs the full test suite\n-                            again. ``none`` just emits a message about no known\n-                            failures and exits successfully.\n-      --sw, --stepwise      Exit on test failure and continue from last failing\n-                            test next time\n+                            With ``--lf``, determines whether to execute tests when\n+                            there are no previously (known) failures or when no\n+                            cached ``lastfailed`` data was found. ``all`` (the\n+                            default) runs the full test suite again. ``none`` just\n+                            emits a message about no known failures and exits\n+                            successfully.\n+      --sw, --stepwise      Exit on test failure and continue from last failing test\n+                            next time\n       --sw-skip, --stepwise-skip\n                             Ignore the first failing test but stop on the next\n                             failing test. Implicitly enables --stepwise.\n@@ -2007,55 +2006,53 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       -r chars              Show extra test summary info as specified by chars:\n                             (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,\n                             (p)assed, (P)assed with output, (a)ll except passed\n-                            (p/P), or (A)ll. (w)arnings are enabled by default\n-                            (see --disable-warnings), 'N' can be used to reset\n-                            the list. (default: 'fE').\n+                            (p/P), or (A)ll. (w)arnings are enabled by default (see\n+                            --disable-warnings), 'N' can be used to reset the list.\n+                            (default: 'fE').\n       --disable-warnings, --disable-pytest-warnings\n                             Disable warnings summary\n       -l, --showlocals      Show locals in tracebacks (disabled by default)\n-      --no-showlocals       Hide locals in tracebacks (negate --showlocals\n-                            passed through addopts)\n-      --tb=style            Traceback print mode\n-                            (auto/long/short/line/native/no)\n+      --no-showlocals       Hide locals in tracebacks (negate --showlocals passed\n+                            through addopts)\n+      --tb=style            Traceback print mode (auto/long/short/line/native/no)\n+      --xfail-tb            Show tracebacks for xfail (as long as --tb != no)\n       --show-capture={no,stdout,stderr,log,all}\n                             Controls how captured stdout/stderr/log is shown on\n                             failed tests. Default: all.\n       --full-trace          Don't cut any tracebacks (default is to cut)\n       --color=color         Color terminal output (yes/no/auto)\n       --code-highlight={yes,no}\n-                            Whether code should be highlighted (only if --color\n-                            is also enabled). Default: yes.\n+                            Whether code should be highlighted (only if --color is\n+                            also enabled). Default: yes.\n       --pastebin=mode       Send failed|all info to bpaste.net pastebin service\n       --junit-xml=path      Create junit-xml style report file at given path\n       --junit-prefix=str    Prepend prefix to classnames in junit-xml output\n \n     pytest-warnings:\n       -W PYTHONWARNINGS, --pythonwarnings=PYTHONWARNINGS\n-                            Set which warnings to report, see -W option of\n-                            Python itself\n+                            Set which warnings to report, see -W option of Python\n+                            itself\n       --maxfail=num         Exit after first num failures or errors\n       --strict-config       Any warnings encountered while parsing the `pytest`\n                             section of the configuration file raise errors\n-      --strict-markers      Markers not registered in the `markers` section of\n-                            the configuration file raise errors\n+      --strict-markers      Markers not registered in the `markers` section of the\n+                            configuration file raise errors\n       --strict              (Deprecated) alias to --strict-markers\n       -c FILE, --config-file=FILE\n                             Load configuration from `FILE` instead of trying to\n                             locate one of the implicit configuration files.\n       --continue-on-collection-errors\n                             Force test execution even if collection errors occur\n-      --rootdir=ROOTDIR     Define root directory for tests. Can be relative\n-                            path: 'root_dir', './root_dir',\n-                            'root_dir/another_dir/'; absolute path:\n-                            '/home/user/root_dir'; path with variables:\n-                            '$HOME/root_dir'.\n+      --rootdir=ROOTDIR     Define root directory for tests. Can be relative path:\n+                            'root_dir', './root_dir', 'root_dir/another_dir/';\n+                            absolute path: '/home/user/root_dir'; path with\n+                            variables: '$HOME/root_dir'.\n \n     collection:\n       --collect-only, --co  Only collect tests, don't execute them\n       --pyargs              Try to interpret all arguments as Python packages\n       --ignore=path         Ignore path during collection (multi-allowed)\n-      --ignore-glob=path    Ignore path pattern during collection (multi-\n-                            allowed)\n+      --ignore-glob=path    Ignore path pattern during collection (multi-allowed)\n       --deselect=nodeid_prefix\n                             Deselect item (via node id prefix) during collection\n                             (multi-allowed)\n@@ -2065,8 +2062,8 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       --collect-in-virtualenv\n                             Don't ignore tests in a local virtualenv directory\n       --import-mode={prepend,append,importlib}\n-                            Prepend/append to sys.path when importing test\n-                            modules and conftest files. Default: prepend.\n+                            Prepend/append to sys.path when importing test modules\n+                            and conftest files. Default: prepend.\n       --doctest-modules     Run doctests in all .py modules\n       --doctest-report={none,cdiff,ndiff,udiff,only_first_failure}\n                             Choose another output format for diffs on doctest\n@@ -2079,38 +2076,37 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             failure\n \n     test session debugging and configuration:\n-      --basetemp=dir        Base temporary directory for this test run.\n-                            (Warning: this directory is removed if it exists.)\n-      -V, --version         Display pytest version and information about\n-                            plugins. When given twice, also display information\n-                            about plugins.\n+      --basetemp=dir        Base temporary directory for this test run. (Warning:\n+                            this directory is removed if it exists.)\n+      -V, --version         Display pytest version and information about plugins.\n+                            When given twice, also display information about\n+                            plugins.\n       -h, --help            Show help message and configuration info\n       -p name               Early-load given plugin module name or entry point\n-                            (multi-allowed). To avoid loading of plugins, use\n-                            the `no:` prefix, e.g. `no:doctest`.\n+                            (multi-allowed). To avoid loading of plugins, use the\n+                            `no:` prefix, e.g. `no:doctest`.\n       --trace-config        Trace considerations of conftest.py files\n       --debug=[DEBUG_FILE_NAME]\n                             Store internal tracing debug information in this log\n-                            file. This file is opened with 'w' and truncated as\n-                            a result, care advised. Default: pytestdebug.log.\n+                            file. This file is opened with 'w' and truncated as a\n+                            result, care advised. Default: pytestdebug.log.\n       -o OVERRIDE_INI, --override-ini=OVERRIDE_INI\n-                            Override ini option with \"option=value\" style, e.g.\n-                            `-o xfail_strict=True -o cache_dir=cache`.\n+                            Override ini option with \"option=value\" style, e.g. `-o\n+                            xfail_strict=True -o cache_dir=cache`.\n       --assert=MODE         Control assertion debugging tools.\n                             'plain' performs no assertion debugging.\n-                            'rewrite' (the default) rewrites assert statements\n-                            in test modules on import to provide assert\n-                            expression information.\n+                            'rewrite' (the default) rewrites assert statements in\n+                            test modules on import to provide assert expression\n+                            information.\n       --setup-only          Only setup fixtures, do not execute tests\n       --setup-show          Show setup of fixtures while executing tests\n-      --setup-plan          Show what fixtures and tests would be executed but\n-                            don't execute anything\n+      --setup-plan          Show what fixtures and tests would be executed but don't\n+                            execute anything\n \n     logging:\n-      --log-level=LEVEL     Level of messages to catch/display. Not set by\n-                            default, so it depends on the root/parent log\n-                            handler's effective level, where it is \"WARNING\" by\n-                            default.\n+      --log-level=LEVEL     Level of messages to catch/display. Not set by default,\n+                            so it depends on the root/parent log handler's effective\n+                            level, where it is \"WARNING\" by default.\n       --log-format=LOG_FORMAT\n                             Log format used by the logging module\n       --log-date-format=LOG_DATE_FORMAT\n@@ -2134,8 +2130,13 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Auto-indent multiline messages passed to the logging\n                             module. Accepts true|on, false|off or an integer.\n       --log-disable=LOGGER_DISABLE\n-                            Disable a logger by name. Can be passed multiple\n-                            times.\n+                            Disable a logger by name. Can be passed multiple times.\n+\n+    Custom options:\n+      --lsof                Run FD checks if lsof is available\n+      --runpytest={inprocess,subprocess}\n+                            Run pytest sub runs in tests using an 'inprocess' or\n+                            'subprocess' (python -m main) method\n \n     [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg|pyproject.toml file found:\n \n@@ -2150,37 +2151,33 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             warnings.filterwarnings. Processed after\n                             -W/--pythonwarnings.\n       consider_namespace_packages (bool):\n-                            Consider namespace packages when resolving module\n-                            names during import\n-      usefixtures (args):   List of default fixtures to be used with this\n-                            project\n+                            Consider namespace packages when resolving module names\n+                            during import\n+      usefixtures (args):   List of default fixtures to be used with this project\n       python_files (args):  Glob-style file patterns for Python test module\n                             discovery\n       python_classes (args):\n-                            Prefixes or glob names for Python test class\n-                            discovery\n+                            Prefixes or glob names for Python test class discovery\n       python_functions (args):\n                             Prefixes or glob names for Python test function and\n                             method discovery\n       disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool):\n-                            Disable string escape non-ASCII characters, might\n-                            cause unwanted side effects(use at your own risk)\n+                            Disable string escape non-ASCII characters, might cause\n+                            unwanted side effects(use at your own risk)\n       console_output_style (string):\n-                            Console output: \"classic\", or with additional\n-                            progress information (\"progress\" (percentage) |\n-                            \"count\" | \"progress-even-when-capture-no\" (forces\n-                            progress even when capture=no)\n+                            Console output: \"classic\", or with additional progress\n+                            information (\"progress\" (percentage) | \"count\" |\n+                            \"progress-even-when-capture-no\" (forces progress even\n+                            when capture=no)\n       verbosity_test_cases (string):\n                             Specify a verbosity level for test case execution,\n-                            overriding the main level. Higher levels will\n-                            provide more detailed information about each test\n-                            case executed.\n-      xfail_strict (bool):  Default for the strict parameter of xfail markers\n-                            when not given explicitly (default: False)\n+                            overriding the main level. Higher levels will provide\n+                            more detailed information about each test case executed.\n+      xfail_strict (bool):  Default for the strict parameter of xfail markers when\n+                            not given explicitly (default: False)\n       tmp_path_retention_count (string):\n                             How many sessions should we keep the `tmp_path`\n-                            directories, according to\n-                            `tmp_path_retention_policy`.\n+                            directories, according to `tmp_path_retention_policy`.\n       tmp_path_retention_policy (string):\n                             Controls which directories created by the `tmp_path`\n                             fixture are kept around, based on test outcome.\n@@ -2189,9 +2186,9 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Enables the pytest_assertion_pass hook. Make sure to\n                             delete any previously generated pyc cache files.\n       verbosity_assertions (string):\n-                            Specify a verbosity level for assertions, overriding\n-                            the main level. Higher levels will provide more\n-                            detailed explanation when an assertion fails.\n+                            Specify a verbosity level for assertions, overriding the\n+                            main level. Higher levels will provide more detailed\n+                            explanation when an assertion fails.\n       junit_suite_name (string):\n                             Test suite name for JUnit report\n       junit_logging (string):\n@@ -2213,8 +2210,8 @@ All the command-line flags can be obtained by running ``pytest --help``::\n       log_format (string):  Default value for --log-format\n       log_date_format (string):\n                             Default value for --log-date-format\n-      log_cli (bool):       Enable log display during test run (also known as\n-                            \"live logging\")\n+      log_cli (bool):       Enable log display during test run (also known as \"live\n+                            logging\")\n       log_cli_level (string):\n                             Default value for --log-cli-level\n       log_cli_format (string):\n@@ -2234,14 +2231,18 @@ All the command-line flags can be obtained by running ``pytest --help``::\n                             Default value for --log-auto-indent\n       pythonpath (paths):   Add paths to sys.path\n       faulthandler_timeout (string):\n-                            Dump the traceback of all threads if a test takes\n-                            more than TIMEOUT seconds to finish\n+                            Dump the traceback of all threads if a test takes more\n+                            than TIMEOUT seconds to finish\n       addopts (args):       Extra command line options\n       minversion (string):  Minimally required pytest version\n       required_plugins (args):\n                             Plugins that must be present for pytest to run\n+      pytester_example_dir (string):\n+                            Directory to take the pytester example files from\n \n     Environment variables:\n+      CI                       When set (regardless of value), pytest knows it is running in a CI process and does not truncate summary info\n+      BUILD_NUMBER             equivalent to CI\n       PYTEST_ADDOPTS           Extra command line options\n       PYTEST_PLUGINS           Comma-separated plugins to load during startup\n       PYTEST_DISABLE_PLUGIN_AUTOLOAD Set to disable plugin auto-loading\n", "test_patch": "diff --git a/src/_pytest/helpconfig.py b/src/_pytest/helpconfig.py\nindex f23b839943..1433607a19 100644\n--- a/src/_pytest/helpconfig.py\n+++ b/src/_pytest/helpconfig.py\n@@ -212,6 +212,12 @@ def showhelp(config: Config) -> None:\n     tw.line()\n     tw.line(\"Environment variables:\")\n     vars = [\n+        (\n+            \"CI\",\n+            \"When set (regardless of value), pytest knows it is running in a \"\n+            \"CI process and does not truncate summary info\",\n+        ),\n+        (\"BUILD_NUMBER\", \"Equivalent to CI\"),\n         (\"PYTEST_ADDOPTS\", \"Extra command line options\"),\n         (\"PYTEST_PLUGINS\", \"Comma-separated plugins to load during startup\"),\n         (\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"Set to disable plugin auto-loading\"),\n", "problem_statement": "Mention CI and BUILD_NUMBER in `pytest -h`\nFollowing up on https://github.com/pytest-dev/pytest/issues/10690, the two env variables are still missing from `pytest -h`and from the corresponding doc (https://docs.pytest.org/en/latest/reference/reference.html#command-line-flags) \n", "hints_text": "", "created_at": "2024-07-05T10:25:52Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12558, "instance_id": "pytest-dev__pytest-12558", "issue_numbers": ["12552"], "base_commit": "ac4189875562a6ce5b502c3dd87156c0367cf8f1", "patch": "diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nindex 431b21f994..ebcc797cc1 100644\n--- a/.pre-commit-config.yaml\n+++ b/.pre-commit-config.yaml\n@@ -1,6 +1,6 @@\n repos:\n - repo: https://github.com/astral-sh/ruff-pre-commit\n-  rev: \"v0.4.10\"\n+  rev: \"v0.5.0\"\n   hooks:\n     - id: ruff\n       args: [\"--fix\"]\n@@ -12,7 +12,7 @@ repos:\n     -   id: end-of-file-fixer\n     -   id: check-yaml\n -   repo: https://github.com/adamchainz/blacken-docs\n-    rev: 1.16.0\n+    rev: 1.18.0\n     hooks:\n     -   id: blacken-docs\n         additional_dependencies: [black==24.1.1]\n@@ -21,7 +21,7 @@ repos:\n     hooks:\n     -   id: python-use-type-annotations\n -   repo: https://github.com/pre-commit/mirrors-mypy\n-    rev: v1.10.0\n+    rev: v1.10.1\n     hooks:\n     -   id: mypy\n         files: ^(src/|testing/|scripts/)\n@@ -38,7 +38,7 @@ repos:\n             # on <3.11\n           - exceptiongroup>=1.0.0rc8\n - repo: https://github.com/tox-dev/pyproject-fmt\n-  rev: \"2.1.3\"\n+  rev: \"2.1.4\"\n   hooks:\n     - id: pyproject-fmt\n       # https://pyproject-fmt.readthedocs.io/en/latest/#calculating-max-supported-python-version\ndiff --git a/pyproject.toml b/pyproject.toml\nindex e0ed2b9006..1eb4871bc2 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -221,6 +221,7 @@ disable = [\n     \"method-hidden\",\n     \"missing-docstring\",\n     \"missing-timeout\",\n+    \"misplaced-bare-raise\",                   # PLE0704 from ruff\n     \"multiple-statements\",                    # multiple-statements-on-one-line-colon (E701) from ruff\n     \"no-else-break\",\n     \"no-else-continue\",\n@@ -283,7 +284,8 @@ disable = [\n     \"useless-import-alias\",\n     \"useless-return\",\n     \"using-constant-test\",\n-    \"wrong-import-order\",\n+    \"wrong-import-order\",                     # handled by isort / ruff\n+    \"wrong-import-position\",                  # handled by isort / ruff\n ]\n \n [tool.check-wheel-contents]\n", "test_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex fe3be060fd..44af8ff204 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -399,7 +399,7 @@ def handleError(self, record: logging.LogRecord) -> None:\n             # The default behavior of logging is to print \"Logging error\"\n             # to stderr with the call stack and some extra details.\n             # pytest wants to make such mistakes visible during testing.\n-            raise  # pylint: disable=misplaced-bare-raise\n+            raise  # noqa: PLE0704\n \n \n @final\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex bc091bb1f2..5c3a6a35b3 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -76,6 +76,16 @@ class B(A):\n     assert getfuncargnames(B.static, cls=B) == (\"arg1\", \"arg2\")\n \n \n+@pytest.mark.skipif(\n+    sys.version_info >= (3, 13),\n+    reason=\"\"\"\\\n+In python 3.13, this will raise FutureWarning:\n+functools.partial will be a method descriptor in future Python versions;\n+wrap it in staticmethod() if you want to preserve the old behavior\n+\n+But the wrapped 'functools.partial' is tested by 'test_getfuncargnames_staticmethod_partial' below.\n+\"\"\",\n+)\n def test_getfuncargnames_partial():\n     \"\"\"Check getfuncargnames for methods defined with functools.partial (#5701)\"\"\"\n     import functools\ndiff --git a/testing/test_mark_expression.py b/testing/test_mark_expression.py\nindex f8f5f9221c..a61a9f2156 100644\n--- a/testing/test_mark_expression.py\n+++ b/testing/test_mark_expression.py\n@@ -243,7 +243,7 @@ def mark_matcher() -> MarkMatcher:\n     markers = [\n         pytest.mark.number_mark(a=1, b=2, c=3, d=999_999).mark,\n         pytest.mark.builtin_matchers_mark(x=True, y=False, z=None).mark,\n-        pytest.mark.str_mark(\n+        pytest.mark.str_mark(  # pylint: disable-next=non-ascii-name\n             m=\"M\", space=\"with space\", empty=\"\", aa\u05d0\u05d1\u05d2\u05d3cc=\"aa\u05d0\u05d1\u05d2\u05d3cc\", \u05d0\u05d1\u05d2\u05d3=\"\u05d0\u05d1\u05d2\u05d3\"\n         ).mark,\n     ]\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 79f7a3fd4d..1b59ff7863 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -533,7 +533,7 @@ class TestClass(object):\n )\n def test_report_extra_parameters(reporttype: type[reports.BaseReport]) -> None:\n     args = list(inspect.signature(reporttype.__init__).parameters.keys())[1:]\n-    basekw: dict[str, list[object]] = dict.fromkeys(args, [])\n+    basekw: dict[str, list[object]] = {arg: [] for arg in args}\n     report = reporttype(newthing=1, **basekw)\n     assert report.newthing == 1\n \n", "problem_statement": "[Python 3.13.0b3] Address a deprecated call in `testing/python/fixtures.py::test_getfuncargnames_partial`\n```python-traceback\r\n================================== FAILURES ===================================\r\n________________________ test_getfuncargnames_partial _________________________\r\n\r\n    def test_getfuncargnames_partial():\r\n        \"\"\"Check getfuncargnames for methods defined with functools.partial (#5701)\"\"\"\r\n        import functools\r\n    \r\n        def check(arg1, arg2, i):\r\n            raise NotImplementedError()\r\n    \r\n        class T:\r\n            test_ok = functools.partial(check, i=2)\r\n    \r\n>       values = getfuncargnames(T().test_ok, name=\"test_ok\")\r\nE       FutureWarning: functools.partial will be a method descriptor in future Python versions; wrap it in staticmethod() if you want to preserve the old behavior\r\n\r\ntesting\\python\\fixtures.py:89: FutureWarning\r\n```\r\n*(https://github.com/pytest-dev/pytest/actions/runs/9745977844/job/26895224146#step:7:220)*\n", "hints_text": "", "created_at": "2024-07-02T00:16:56Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12557, "instance_id": "pytest-dev__pytest-12557", "issue_numbers": ["11771", "11771"], "base_commit": "d489247505a953885a156e61d4473497cbc167ea", "patch": "diff --git a/changelog/11771.contrib.rst b/changelog/11771.contrib.rst\nnew file mode 100644\nindex 0000000000..a3c1ed1099\n--- /dev/null\n+++ b/changelog/11771.contrib.rst\n@@ -0,0 +1,5 @@\n+The PyPy runtime version has been updated to 3.9 from 3.8 that introduced\n+a flaky bug at the garbage collector which was not expected to fix there\n+as the V3.8 is EoL.\n+\n+-- by :user:`x612skm`\ndiff --git a/changelog/12557.contrib.rst b/changelog/12557.contrib.rst\nnew file mode 120000\nindex 0000000000..c036c51909\n--- /dev/null\n+++ b/changelog/12557.contrib.rst\n@@ -0,0 +1,1 @@\n+11771.contrib.rst\n\\ No newline at end of file\n", "test_patch": "diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml\nindex d78e0900fd..9158d6bcc7 100644\n--- a/.github/workflows/test.yml\n+++ b/.github/workflows/test.yml\n@@ -150,7 +150,7 @@ jobs:\n             tox_env: \"py313\"\n             use_coverage: true\n           - name: \"ubuntu-pypy3\"\n-            python: \"pypy-3.8\"\n+            python: \"pypy-3.9\"\n             os: ubuntu-latest\n             tox_env: \"pypy3-xdist\"\n \ndiff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 558e3d35c6..d1a63b1d92 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1140,8 +1140,8 @@ def test_func():\n     result = pytester.runpytest()\n     markline = \"            ^\"\n     pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n-    if pypy_version_info is not None and pypy_version_info < (6,):\n-        markline = markline[1:]\n+    if pypy_version_info is not None:\n+        markline = markline[7:]\n \n     if sys.version_info >= (3, 10):\n         expected = [\n", "problem_statement": "Selftests sometimes fail on pypy: `TypeError: expected some sort of stmt, but got <_ast.Load object ...>`\nExample: https://github.com/pytest-dev/pytest/actions/runs/7408595776/job/20157160097\r\n\r\nThis doesn't always happen, maybe 50% of the time. Started in the last few days. I checked if the PyPy version changed during these days, but seems not (it's 3.8.16).\r\n\r\nThe error is:\r\n\r\n```\r\n __________________ ERROR collecting testing/_py/test_local.py __________________\r\n/opt/hostedtoolcache/PyPy/3.8.16/x64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:166: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:350: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Store object at 0x0000000002142880>\r\n```\r\n\r\nSometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\nSelftests sometimes fail on pypy: `TypeError: expected some sort of stmt, but got <_ast.Load object ...>`\nExample: https://github.com/pytest-dev/pytest/actions/runs/7408595776/job/20157160097\r\n\r\nThis doesn't always happen, maybe 50% of the time. Started in the last few days. I checked if the PyPy version changed during these days, but seems not (it's 3.8.16).\r\n\r\nThe error is:\r\n\r\n```\r\n __________________ ERROR collecting testing/_py/test_local.py __________________\r\n/opt/hostedtoolcache/PyPy/3.8.16/x64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:166: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n.tox/pypy3-xdist/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:350: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Store object at 0x0000000002142880>\r\n```\r\n\r\nSometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\n", "hints_text": "I have same failure on older versions as well.  E.g. 7.4.3:\r\nhttps://github.com/mpmath/mpmath/actions/runs/8030300102?pr=759\r\n\r\nThis happens for all tested in the mpmath pypy versions (3.8-3.10).  But most often on 3.10.\nAnother example: https://github.com/pytest-dev/pytest/issues/11168#issuecomment-1714358183\r\n\r\n@cfbolz, I don't see a bugreport in pypy issues.  Is there any chance this might be related to pytest-dev/pytest#11168 (an fixed in pypy)?\n@skirpichev it's not impossible that it's the same problem, yes. You can try a nightly PyPy build (or wait for the next release but that is still a bit out). \n@cfbolz, thanks for a suggestion.  I did tests for nightly builds (on 3.8-3.10) and, after ~20 re-runs, I got a TypeError on pypy3.8, which is similar to this issue:\r\n<details>\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.8.16[pypy-7.3.12-alpha], pytest-8.1.1, pluggy-1.4.0\r\nmpmath backend: python\r\nmpmath mp class: <mpmath.ctx_mp.MPContext object at 0x00000000018deb10>\r\nmpmath version: 1.4.0a1.dev43+g534bc79\r\nPython version: 3.8.16 (d8e6b37f5231c7b59b2b639a651dd696a3732cc3, Jan 09 2023, 00:30:15)\r\n[PyPy 7.3.12-alpha0 with GCC 10.2.1 20210130 (Red Hat 10.2.1-11)]\r\nrootdir: /home/runner/work/mpmath/mpmath\r\nconfigfile: pyproject.toml\r\ntestpaths: mpmath, docs\r\nplugins: cov-5.0.0, xdist-3.5.0\r\ncreated: 4/4 workers\r\n4 workers [2294 items]\r\n\r\n........................................................................ [  3%]\r\n........................................................................ [  6%]\r\n........................................................................ [  9%]\r\n........................................................................ [ 12%]\r\n........................................................................ [ 15%]\r\n........................................................................ [ 18%]\r\n........................................................................ [ 21%]\r\n........................................................................ [ 25%]\r\n........................................................................ [ 28%]\r\n........................................................................ [ 31%]\r\n........................................................................ [ 34%]\r\n........................................................................ [ 37%]\r\n........................................................................ [ 40%]\r\n........................................................................ [ 43%]\r\n........................................................................ [ 47%]\r\n........................................................................ [ 50%]\r\n........................................................................ [ 53%]\r\n........................................................................ [ 56%]\r\n........................................................................ [ 59%]\r\n........................................................................ [ 62%]\r\n........................................................................ [ 65%]\r\n........................................................................ [ 69%]\r\n........................................................................ [ 72%]\r\n......................................................................... [ 75%]\r\n........................................................................ [ 78%]\r\n........................................................................ [ 81%]\r\n........................................................................ [ 84%]\r\n........................................................................ [ 87%]\r\n........................................x............................... [ 91%]\r\n.......................................x................................ [ 94%]\r\n...................................s.................................... [ 97%]\r\n.............................................................            [100%]\r\n==================================== ERRORS ====================================\r\n_______________ ERROR collecting mpmath/tests/test_basic_ops.py ________________\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:169: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:353: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n============================= slowest 20 durations =============================\r\n34.04s call     mpmath/tests/test_functions2.py::test_bessel_zeros_extra\r\n28.52s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False23]\r\n16.64s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyper\r\n11.94s call     mpmath/tests/test_extra_zeta.py::test_zetazero[241389216-97490234.22767118]\r\n10.72s call     mpmath/functions/zeta.py::mpmath.functions.zeta.secondzeta\r\n9.91s call     mpmath/tests/test_elliptic.py::test_elliptic_integrals\r\n9.25s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.bessely\r\n8.75s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyp3f2\r\n8.59s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.siegelz\r\n8.44s call     mpmath/calculus/extrapolation.py::mpmath.calculus.extrapolation.nsum\r\n8.39s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False9]\r\n7.87s call     mpmath/functions/zetazeros.py::mpmath.functions.zetazeros.nzeros\r\n7.58s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-1500-False1]\r\n7.53s call     mpmath/tests/test_quad.py::test_quadosc\r\n7.50s call     mpmath/calculus/quadrature.py::mpmath.calculus.quadrature.QuadratureMethods.quad\r\n7.45s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-90-False]\r\n7.27s call     mpmath/tests/test_torture.py::test_asymp[f-5000-True1]\r\n7.22s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False27]\r\n7.00s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False37]\r\n6.74s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False36]\r\n=========================== short test summary info ============================\r\nERROR mpmath/tests/test_basic_ops.py - TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n======= 2291 passed, 1 skipped, 2 xfailed, 1 error in 203.43s (0:03:23) ========\r\n```\r\n\r\n</details>\r\n\r\nSummary page: https://github.com/mpmath/mpmath/actions/runs/8491432157?pr=772\r\n\r\n~~Maybe this fix isn't merged yet to the 3.8 branch (as it was stated in your blog post)?  If so,~~ I'll continue testing.\nYes, the 3.8 variants are not maintained any more, you need to try 3.9 or 3.10. Thanks for trying this out! \nWell, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures.  Given the previous statistics, probably there is a chance that this issue was fixed in PyPy's nightly builds.  I'll switch regular tests for pypy3.9/10 to them.\r\n\r\nThanks for bugfix!\n> Well, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures. \r\n\r\nthank you for trying this, that's very valuable feedback!\n> Sometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\r\n\r\nDuring the sprints, we were seeing 3\u20134 variants of different AST object reprs there. Hopefully, bumping PyPy in CI will fix this. Ronny suggested this, but nobody got to actually doing it...\nFTR @LilyFoote linked https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html in https://github.com/pytest-dev/pytest/issues/11168#issuecomment-2023988486 but that reference never got cross-posted into this issue.\nI have same failure on older versions as well.  E.g. 7.4.3:\r\nhttps://github.com/mpmath/mpmath/actions/runs/8030300102?pr=759\r\n\r\nThis happens for all tested in the mpmath pypy versions (3.8-3.10).  But most often on 3.10.\nAnother example: https://github.com/pytest-dev/pytest/issues/11168#issuecomment-1714358183\r\n\r\n@cfbolz, I don't see a bugreport in pypy issues.  Is there any chance this might be related to pytest-dev/pytest#11168 (an fixed in pypy)?\n@skirpichev it's not impossible that it's the same problem, yes. You can try a nightly PyPy build (or wait for the next release but that is still a bit out). \n@cfbolz, thanks for a suggestion.  I did tests for nightly builds (on 3.8-3.10) and, after ~20 re-runs, I got a TypeError on pypy3.8, which is similar to this issue:\r\n<details>\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.8.16[pypy-7.3.12-alpha], pytest-8.1.1, pluggy-1.4.0\r\nmpmath backend: python\r\nmpmath mp class: <mpmath.ctx_mp.MPContext object at 0x00000000018deb10>\r\nmpmath version: 1.4.0a1.dev43+g534bc79\r\nPython version: 3.8.16 (d8e6b37f5231c7b59b2b639a651dd696a3732cc3, Jan 09 2023, 00:30:15)\r\n[PyPy 7.3.12-alpha0 with GCC 10.2.1 20210130 (Red Hat 10.2.1-11)]\r\nrootdir: /home/runner/work/mpmath/mpmath\r\nconfigfile: pyproject.toml\r\ntestpaths: mpmath, docs\r\nplugins: cov-5.0.0, xdist-3.5.0\r\ncreated: 4/4 workers\r\n4 workers [2294 items]\r\n\r\n........................................................................ [  3%]\r\n........................................................................ [  6%]\r\n........................................................................ [  9%]\r\n........................................................................ [ 12%]\r\n........................................................................ [ 15%]\r\n........................................................................ [ 18%]\r\n........................................................................ [ 21%]\r\n........................................................................ [ 25%]\r\n........................................................................ [ 28%]\r\n........................................................................ [ 31%]\r\n........................................................................ [ 34%]\r\n........................................................................ [ 37%]\r\n........................................................................ [ 40%]\r\n........................................................................ [ 43%]\r\n........................................................................ [ 47%]\r\n........................................................................ [ 50%]\r\n........................................................................ [ 53%]\r\n........................................................................ [ 56%]\r\n........................................................................ [ 59%]\r\n........................................................................ [ 62%]\r\n........................................................................ [ 65%]\r\n........................................................................ [ 69%]\r\n........................................................................ [ 72%]\r\n......................................................................... [ 75%]\r\n........................................................................ [ 78%]\r\n........................................................................ [ 81%]\r\n........................................................................ [ 84%]\r\n........................................................................ [ 87%]\r\n........................................x............................... [ 91%]\r\n.......................................x................................ [ 94%]\r\n...................................s.................................... [ 97%]\r\n.............................................................            [100%]\r\n==================================== ERRORS ====================================\r\n_______________ ERROR collecting mpmath/tests/test_basic_ops.py ________________\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1023: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1000: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:984: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:680: in _load_unlocked\r\n    ???\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:169: in exec_module\r\n    source_stat, co = _rewrite_test(fn, self.config)\r\n../../_temp/d367cbdc-8911-4ebe-aab6-2151925ee5c2/pypy-c-jit-106755-d8e6b37f5231-linux64/lib/pypy3.8/site-packages/_pytest/assertion/rewrite.py:353: in _rewrite_test\r\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\r\nE   TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n============================= slowest 20 durations =============================\r\n34.04s call     mpmath/tests/test_functions2.py::test_bessel_zeros_extra\r\n28.52s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False23]\r\n16.64s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyper\r\n11.94s call     mpmath/tests/test_extra_zeta.py::test_zetazero[241389216-97490234.22767118]\r\n10.72s call     mpmath/functions/zeta.py::mpmath.functions.zeta.secondzeta\r\n9.91s call     mpmath/tests/test_elliptic.py::test_elliptic_integrals\r\n9.25s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.bessely\r\n8.75s call     mpmath/functions/hypergeometric.py::mpmath.functions.hypergeometric.hyp3f2\r\n8.59s call     mpmath/ctx_fp.py::mpmath.ctx_fp.FPContext.siegelz\r\n8.44s call     mpmath/calculus/extrapolation.py::mpmath.calculus.extrapolation.nsum\r\n8.39s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False9]\r\n7.87s call     mpmath/functions/zetazeros.py::mpmath.functions.zetazeros.nzeros\r\n7.58s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-1500-False1]\r\n7.53s call     mpmath/tests/test_quad.py::test_quadosc\r\n7.50s call     mpmath/calculus/quadrature.py::mpmath.calculus.quadrature.QuadratureMethods.quad\r\n7.45s call     mpmath/tests/test_torture.py::test_asymp[f_wrapped-90-False]\r\n7.27s call     mpmath/tests/test_torture.py::test_asymp[f-5000-True1]\r\n7.22s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False27]\r\n7.00s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False37]\r\n6.74s call     mpmath/tests/test_torture.py::test_asymp[<lambda>-150-False36]\r\n=========================== short test summary info ============================\r\nERROR mpmath/tests/test_basic_ops.py - TypeError: expected some sort of stmt, but got <_ast.Attribute object at 0x00007f101d7a6920>\r\n======= 2291 passed, 1 skipped, 2 xfailed, 1 error in 203.43s (0:03:23) ========\r\n```\r\n\r\n</details>\r\n\r\nSummary page: https://github.com/mpmath/mpmath/actions/runs/8491432157?pr=772\r\n\r\n~~Maybe this fix isn't merged yet to the 3.8 branch (as it was stated in your blog post)?  If so,~~ I'll continue testing.\nYes, the 3.8 variants are not maintained any more, you need to try 3.9 or 3.10. Thanks for trying this out! \nWell, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures.  Given the previous statistics, probably there is a chance that this issue was fixed in PyPy's nightly builds.  I'll switch regular tests for pypy3.9/10 to them.\r\n\r\nThanks for bugfix!\n> Well, I did ~50 re-runs of mpmath's tests on pypy3.9 and pypy3.10 - without any failures. \r\n\r\nthank you for trying this, that's very valuable feedback!\n> Sometimes it says `TypeError: expected some sort of stmt, but got <_ast.Load object at 0x000000000365d040>` instead.\r\n\r\nDuring the sprints, we were seeing 3\u20134 variants of different AST object reprs there. Hopefully, bumping PyPy in CI will fix this. Ronny suggested this, but nobody got to actually doing it...\nFTR @LilyFoote linked https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html in https://github.com/pytest-dev/pytest/issues/11168#issuecomment-2023988486 but that reference never got cross-posted into this issue.", "created_at": "2024-07-01T17:14:46Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12545, "instance_id": "pytest-dev__pytest-12545", "issue_numbers": ["12544"], "base_commit": "0ed2d79457b499119693588b71233db957e972c0", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex ad7fccf6d5..26fa27f9b2 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -454,6 +454,7 @@ Yusuke Kadowaki\n Yutian Li\n Yuval Shimon\n Zac Hatfield-Dodds\n+Zach Snicker\n Zachary Kneupper\n Zachary OBrien\n Zhouxin Qiu\ndiff --git a/changelog/12544.improvement.rst b/changelog/12544.improvement.rst\nnew file mode 100644\nindex 0000000000..9edbf7c4fe\n--- /dev/null\n+++ b/changelog/12544.improvement.rst\n@@ -0,0 +1,4 @@\n+The _in_venv function now detects Python virtual environments by checking\n+for a pyvenv.cfg file, ensuring reliable detection on various platforms.\n+\n+-- by :user:`zachsnickers`.\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 7c7b99d81c..6926cd61bd 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1702,13 +1702,13 @@ passed multiple times. The expected format is ``name=value``. For example::\n    This would tell ``pytest`` to not look into typical subversion or\n    sphinx-build directories or into any ``tmp`` prefixed directory.\n \n-   Additionally, ``pytest`` will attempt to intelligently identify and ignore a\n-   virtualenv by the presence of an activation script.  Any directory deemed to\n-   be the root of a virtual environment will not be considered during test\n-   collection unless ``--collect-in-virtualenv`` is given.  Note also that\n-   ``norecursedirs`` takes precedence over ``--collect-in-virtualenv``; e.g. if\n-   you intend to run tests in a virtualenv with a base directory that matches\n-   ``'.*'`` you *must* override ``norecursedirs`` in addition to using the\n+   Additionally, ``pytest`` will attempt to intelligently identify and ignore\n+   a virtualenv.  Any directory deemed to be the root of a virtual environment\n+   will not be considered during test collection unless\n+   ``--collect-in-virtualenv`` is given.  Note also that ``norecursedirs``\n+   takes precedence over ``--collect-in-virtualenv``; e.g. if you intend to\n+   run tests in a virtualenv with a base directory that matches ``'.*'`` you\n+   *must* override ``norecursedirs`` in addition to using the\n    ``--collect-in-virtualenv`` flag.\n \n \n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 47ebad4713..8ec2690600 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -369,22 +369,12 @@ def pytest_runtestloop(session: Session) -> bool:\n \n def _in_venv(path: Path) -> bool:\n     \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n-    checking for the existence of the appropriate activate script.\"\"\"\n-    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n+    checking for the existence of the pyvenv.cfg file.\n+    [https://peps.python.org/pep-0405/]\"\"\"\n     try:\n-        if not bindir.is_dir():\n-            return False\n+        return path.joinpath(\"pyvenv.cfg\").is_file()\n     except OSError:\n         return False\n-    activates = (\n-        \"activate\",\n-        \"activate.csh\",\n-        \"activate.fish\",\n-        \"Activate\",\n-        \"Activate.bat\",\n-        \"Activate.ps1\",\n-    )\n-    return any(fname.name in activates for fname in bindir.iterdir())\n \n \n def pytest_ignore_collect(collection_path: Path, config: Config) -> bool | None:\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex 821c424196..f582224033 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -152,20 +152,8 @@ def test_ignored_certain_directories(self, pytester: Pytester) -> None:\n         assert \"test_notfound\" not in s\n         assert \"test_found\" in s\n \n-    @pytest.mark.parametrize(\n-        \"fname\",\n-        (\n-            \"activate\",\n-            \"activate.csh\",\n-            \"activate.fish\",\n-            \"Activate\",\n-            \"Activate.bat\",\n-            \"Activate.ps1\",\n-        ),\n-    )\n-    def test_ignored_virtualenvs(self, pytester: Pytester, fname: str) -> None:\n-        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n-        ensure_file(pytester.path / \"virtual\" / bindir / fname)\n+    def test_ignored_virtualenvs(self, pytester: Pytester) -> None:\n+        ensure_file(pytester.path / \"virtual\" / \"pyvenv.cfg\")\n         testfile = ensure_file(pytester.path / \"virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n \n@@ -179,23 +167,11 @@ def test_ignored_virtualenvs(self, pytester: Pytester, fname: str) -> None:\n         result = pytester.runpytest(\"virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n-    @pytest.mark.parametrize(\n-        \"fname\",\n-        (\n-            \"activate\",\n-            \"activate.csh\",\n-            \"activate.fish\",\n-            \"Activate\",\n-            \"Activate.bat\",\n-            \"Activate.ps1\",\n-        ),\n-    )\n     def test_ignored_virtualenvs_norecursedirs_precedence(\n-        self, pytester: Pytester, fname: str\n+        self, pytester: Pytester\n     ) -> None:\n-        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n         # norecursedirs takes priority\n-        ensure_file(pytester.path / \".virtual\" / bindir / fname)\n+        ensure_file(pytester.path / \".virtual\" / \"pyvenv.cfg\")\n         testfile = ensure_file(pytester.path / \".virtual\" / \"test_invenv.py\")\n         testfile.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n         result = pytester.runpytest(\"--collect-in-virtualenv\")\n@@ -204,27 +180,13 @@ def test_ignored_virtualenvs_norecursedirs_precedence(\n         result = pytester.runpytest(\"--collect-in-virtualenv\", \".virtual\")\n         assert \"test_invenv\" in result.stdout.str()\n \n-    @pytest.mark.parametrize(\n-        \"fname\",\n-        (\n-            \"activate\",\n-            \"activate.csh\",\n-            \"activate.fish\",\n-            \"Activate\",\n-            \"Activate.bat\",\n-            \"Activate.ps1\",\n-        ),\n-    )\n-    def test__in_venv(self, pytester: Pytester, fname: str) -> None:\n+    def test__in_venv(self, pytester: Pytester) -> None:\n         \"\"\"Directly test the virtual env detection function\"\"\"\n-        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n-        # no bin/activate, not a virtualenv\n+        # no pyvenv.cfg, not a virtualenv\n         base_path = pytester.mkdir(\"venv\")\n         assert _in_venv(base_path) is False\n-        # with bin/activate, totally a virtualenv\n-        bin_path = base_path.joinpath(bindir)\n-        bin_path.mkdir()\n-        bin_path.joinpath(fname).touch()\n+        # with pyvenv.cfg, totally a virtualenv\n+        base_path.joinpath(\"pyvenv.cfg\").touch()\n         assert _in_venv(base_path) is True\n \n     def test_custom_norecursedirs(self, pytester: Pytester) -> None:\n", "problem_statement": "Support venv detection on Windows with mingw Python\n#### What's the problem this feature will solve?\r\n\r\nCurrently pytest checks platform depended paths in a directory to see if it might be a venv: https://github.com/pytest-dev/pytest/blob/0ed2d79457b499119693588b71233db957e972c0/src/_pytest/main.py#L370-L387\r\n\r\nThis works fine with the official CPython releases, but the mingw Python on Windows uses the Unix layout, which looks like this, despite being on Windows:\r\n\r\n```console\r\n$ tree -L 1 .venv\r\n.venv\r\n\u251c\u2500\u2500 bin\r\n\u251c\u2500\u2500 include\r\n\u251c\u2500\u2500 lib\r\n\u2514\u2500\u2500 pyvenv.cfg\r\n```\r\n\r\nThis results in pytest trying to collect tests in venv files by default.\r\n\r\n#### Describe the solution you'd like\r\n\r\nI can see three solutions to this:\r\n\r\n1) Check for both bin/Scripts\r\n\r\n2) First check for the existence of \"pyvenv.cfg\", which should be in every venv on every platform\r\n\r\n3) Replace the current logic and just check for \"pyvenv.cfg\". \"pyvenv.cfg\" was introduced in Python 3.3 with the venv module, so it might be enough to assume it exists in every venv. Maybe I'm missing something though.\r\n\r\n**Note:** I'm happy to create a PR for any of the above solutions.\n", "hints_text": "the initial code was added in b32cfc88daad55f6518fc828db7aa770d4e4c80a about 7  years ago when python 2.6 was still supported\r\n\r\nso as far as i'm aware there is no reason not to switch to this much simpler test - a pr would be appreciated\nAgreed, as far as I know, checking for pyvenv.cfg is sufficient.\nHello!\r\nI'm new to contributing to pytest. Can I take this up?\n@zachsnicker I think it's non-controversial enough, I'll assign you. Make sure to include test coverage for the patch in your pull request.\nJust to be safe I did some additional research, https://peps.python.org/pep-0405/ defines venvs and states \"Thus, a Python virtual environment in its simplest form would consist of nothing more than a copy or symlink of the Python binary accompanied by a pyvenv.cfg file and a site-packages directory.\". So it's safe to assume that every venv following the spec will contain a pyvenv.cfg.\r\n\r\nFor the external virtualenv package pyvenv.cfg was added in v20, released 4+ years ago, which is also in Ubuntu 20.04 for example.\r\n\r\nSo I think this is fine.\r\n\r\nI also had a look at the code already, so I'm happy to review if wanted.", "created_at": "2024-06-28T16:40:12Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12542, "instance_id": "pytest-dev__pytest-12542", "issue_numbers": ["12008"], "base_commit": "6c806b499ddbb844753b5c8c4d70a8b98b9d1c3a", "patch": "diff --git a/changelog/12008.bugfix.rst b/changelog/12008.bugfix.rst\nnew file mode 100644\nindex 0000000000..b9680b8923\n--- /dev/null\n+++ b/changelog/12008.bugfix.rst\n@@ -0,0 +1,1 @@\n+In :pr:`11220`, an unintended change in reordering was introduced by changing the way indices were assigned to direct params. More specifically, before that change, the indices of direct params to metafunc's callspecs were assigned after all parametrizations took place. Now, that change is reverted.\n", "test_patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 9182ce7dfe..094113bd1b 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -464,6 +464,7 @@ def _genfunctions(self, name: str, funcobj) -> Iterator[Function]:\n         if not metafunc._calls:\n             yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n         else:\n+            metafunc._recompute_direct_params_indices()\n             # Direct parametrizations taking place in module/class-specific\n             # `metafunc.parametrize` calls may have shadowed some fixtures, so make sure\n             # we update what the function really needs a.k.a its fixture closure. Note that\n@@ -1131,6 +1132,8 @@ def __init__(\n         # Result of parametrize().\n         self._calls: list[CallSpec2] = []\n \n+        self._params_directness: dict[str, Literal[\"indirect\", \"direct\"]] = {}\n+\n     def parametrize(\n         self,\n         argnames: str | Sequence[str],\n@@ -1273,6 +1276,7 @@ def parametrize(\n                 name2pseudofixturedef_key, default\n             )\n         arg_directness = self._resolve_args_directness(argnames, indirect)\n+        self._params_directness.update(arg_directness)\n         for argname in argnames:\n             if arg_directness[argname] == \"indirect\":\n                 continue\n@@ -1445,6 +1449,12 @@ def _validate_if_using_arg_names(\n                         pytrace=False,\n                     )\n \n+    def _recompute_direct_params_indices(self) -> None:\n+        for argname, param_type in self._params_directness.items():\n+            if param_type == \"direct\":\n+                for i, callspec in enumerate(self._calls):\n+                    callspec.indices[argname] = i\n+\n \n def _find_parametrized_scope(\n     argnames: Sequence[str],\ndiff --git a/testing/example_scripts/issue_519.py b/testing/example_scripts/issue_519.py\nindex 138c07e95b..da5f5ad6aa 100644\n--- a/testing/example_scripts/issue_519.py\n+++ b/testing/example_scripts/issue_519.py\n@@ -23,13 +23,13 @@ def checked_order():\n     assert order == [\n         (\"issue_519.py\", \"fix1\", \"arg1v1\"),\n         (\"test_one[arg1v1-arg2v1]\", \"fix2\", \"arg2v1\"),\n-        (\"test_one[arg1v1-arg2v2]\", \"fix2\", \"arg2v2\"),\n         (\"test_two[arg1v1-arg2v1]\", \"fix2\", \"arg2v1\"),\n+        (\"test_one[arg1v1-arg2v2]\", \"fix2\", \"arg2v2\"),\n         (\"test_two[arg1v1-arg2v2]\", \"fix2\", \"arg2v2\"),\n         (\"issue_519.py\", \"fix1\", \"arg1v2\"),\n         (\"test_one[arg1v2-arg2v1]\", \"fix2\", \"arg2v1\"),\n-        (\"test_one[arg1v2-arg2v2]\", \"fix2\", \"arg2v2\"),\n         (\"test_two[arg1v2-arg2v1]\", \"fix2\", \"arg2v1\"),\n+        (\"test_one[arg1v2-arg2v2]\", \"fix2\", \"arg2v2\"),\n         (\"test_two[arg1v2-arg2v2]\", \"fix2\", \"arg2v2\"),\n     ]\n \ndiff --git a/testing/python/metafunc.py b/testing/python/metafunc.py\nindex 2dd85607e7..be224d9e20 100644\n--- a/testing/python/metafunc.py\n+++ b/testing/python/metafunc.py\n@@ -1005,14 +1005,14 @@ def test3(arg1):\n         result.stdout.re_match_lines(\n             [\n                 r\"    <Function test1\\[0-3\\]>\",\n-                r\"    <Function test1\\[0-4\\]>\",\n                 r\"    <Function test3\\[0\\]>\",\n+                r\"    <Function test1\\[0-4\\]>\",\n+                r\"    <Function test3\\[1\\]>\",\n                 r\"    <Function test1\\[1-3\\]>\",\n+                r\"    <Function test3\\[2\\]>\",\n                 r\"    <Function test1\\[1-4\\]>\",\n-                r\"    <Function test3\\[1\\]>\",\n                 r\"    <Function test1\\[2-3\\]>\",\n                 r\"    <Function test1\\[2-4\\]>\",\n-                r\"    <Function test3\\[2\\]>\",\n                 r\"    <Function test2>\",\n             ]\n         )\n", "problem_statement": "pytest 8.0 sorting tests with multiple parameterization is broken\n\u0421ontinue #11976\r\n\r\nThe solution from #11976 did not solve the problem with sorting tests with multiple parameters\r\n\r\nTests\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\n@pytest.mark.parametrize('proto', ['serial', 'telnet', 'ssh'], scope='class')\r\n@pytest.mark.parametrize('unit', [1, 2, 3], scope='class')\r\nclass TestA:\r\n    def test_one(self, proto, unit):\r\n        pass\r\n\r\n    def test_two(self, proto, unit):\r\n        pass\r\n```\r\n\r\nCollecting items with pytest 7.4.4\r\n\r\n```\r\n11:07 $ pytest --co\r\n=========================================================================== test session starts ===========================================================================\r\nplatform linux -- Python 3.11.6, pytest-7.4.4, pluggy-1.4.0 -- /home/lolik/.cache/pypoetry/virtualenvs/pytest_strain-FQAfhJsh-py3.11/bin/python\r\ncachedir: .pytest_cache\r\nmetadata: {'Python': '3.11.6', 'Platform': 'Linux-6.7.4-arch1-1-x86_64-with-glibc2.39', 'Packages': {'pytest': '7.4.4', 'pluggy': '1.4.0'}, 'Plugins': {'metadata': '3.1.0'}, 'GIT_BRANCH': 'master'}\r\nrootdir: /home/lolik/Projects/straing/pytest\r\nconfigfile: pytest.ini\r\nplugins: metadata-3.1.0\r\ncollected 18 items                                                                                                                                                        \r\n\r\n<Package tests>\r\n  <Module test_asd.py>\r\n    <Class TestA>\r\n      <Function test_one[1-serial]>\r\n      <Function test_two[1-serial]>\r\n      <Function test_one[1-telnet]>\r\n      <Function test_two[1-telnet]>\r\n      <Function test_one[1-ssh]>\r\n      <Function test_two[1-ssh]>\r\n      <Function test_one[2-serial]>\r\n      <Function test_two[2-serial]>\r\n      <Function test_one[2-telnet]>\r\n      <Function test_two[2-telnet]>\r\n      <Function test_one[2-ssh]>\r\n      <Function test_two[2-ssh]>\r\n      <Function test_one[3-serial]>\r\n      <Function test_two[3-serial]>\r\n      <Function test_one[3-telnet]>\r\n      <Function test_two[3-telnet]>\r\n      <Function test_one[3-ssh]>\r\n      <Function test_two[3-ssh]>\r\n\r\n======================================================================= 18 tests collected in 0.01s =======================================================================\r\n```\r\n\r\nCollecting items with pytest 8.0.1\r\n\r\n```\r\n11:08 $ pytest --co\r\n=========================================================================== test session starts ===========================================================================\r\nplatform linux -- Python 3.11.6, pytest-8.0.1, pluggy-1.4.0 -- /home/lolik/.cache/pypoetry/virtualenvs/pytest_strain-FQAfhJsh-py3.11/bin/python\r\ncachedir: .pytest_cache\r\nmetadata: {'Python': '3.11.6', 'Platform': 'Linux-6.7.4-arch1-1-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.0.1', 'pluggy': '1.4.0'}, 'Plugins': {'metadata': '3.1.0'}, 'GIT_BRANCH': 'master'}\r\nrootdir: /home/lolik/Projects/straing/pytest\r\nconfigfile: pytest.ini\r\nplugins: metadata-3.1.0\r\ncollected 18 items                                                                                                                                                        \r\n\r\n<Dir pytest>\r\n  <Package tests>\r\n    <Module test_asd.py>\r\n      <Class TestA>\r\n        <Function test_one[1-serial]>\r\n        <Function test_two[1-serial]>\r\n        <Function test_one[2-serial]>\r\n        <Function test_two[2-serial]>\r\n        <Function test_one[2-telnet]>\r\n        <Function test_two[2-telnet]>\r\n        <Function test_one[1-telnet]>\r\n        <Function test_two[1-telnet]>\r\n        <Function test_one[3-telnet]>\r\n        <Function test_two[3-telnet]>\r\n        <Function test_one[3-serial]>\r\n        <Function test_two[3-serial]>\r\n        <Function test_one[3-ssh]>\r\n        <Function test_two[3-ssh]>\r\n        <Function test_one[2-ssh]>\r\n        <Function test_two[2-ssh]>\r\n        <Function test_one[1-ssh]>\r\n        <Function test_two[1-ssh]>\r\n\r\n======================================================================= 18 tests collected in 0.01s =======================================================================\r\n\r\n```\n", "hints_text": "Thanks, this does look wrong at first glance, I will look into it. Bisected to 09b78737a5bde23eb488d5d6649bf966c5809176 (PR #11220).\nMinimized example:\r\n\r\n```py\r\n@pytest.mark.parametrize('proto', ['a', 'b'], scope='class')\r\n@pytest.mark.parametrize('unit', [1, 2], scope='class')\r\nclass Test:\r\n    def test(self, proto, unit):\r\n        pass\r\n```\r\n\r\nThe items are reordered by `reorder_items()` in fixture.py (surely the most inscrutable function in all of pytest), whose aim is to minimize fixture setups and teardowns. In this respect it achieves its goal:\r\n\r\nSetup plan in pytest 7, has 6 setups/teardowns:\r\n\r\n```\r\n      SETUP    C proto['a']\r\n      SETUP    C unit[1]\r\n        x.py::Test::test[1-a] (fixtures used: proto, unit)\r\n      TEARDOWN C proto['a']\r\n      SETUP    C proto['b']\r\n        x.py::Test::test[1-b] (fixtures used: proto, unit)\r\n      TEARDOWN C proto['b']\r\n      SETUP    C proto['a']\r\n      TEARDOWN C unit[1]\r\n      SETUP    C unit[2]\r\n        x.py::Test::test[2-a] (fixtures used: proto, unit)\r\n      TEARDOWN C proto['a']\r\n      SETUP    C proto['b']\r\n        x.py::Test::test[2-b] (fixtures used: proto, unit)\r\n      TEARDOWN C unit[2]\r\n      TEARDOWN C proto['b']\r\n```\r\n\r\nin pytest 8, has 5 setups/teardowns:\r\n\r\n```\r\n      SETUP    C proto['a']\r\n      SETUP    C unit[1]\r\n        x.py::Test::test[1-a] (fixtures used: proto, unit)\r\n      TEARDOWN C unit[1]\r\n      SETUP    C unit[2]\r\n        x.py::Test::test[2-a] (fixtures used: proto, unit)\r\n      TEARDOWN C proto['a']\r\n      SETUP    C proto['b']\r\n        x.py::Test::test[2-b] (fixtures used: proto, unit)\r\n      TEARDOWN C unit[2]\r\n      SETUP    C unit[1]\r\n        x.py::Test::test[1-b] (fixtures used: proto, unit)\r\n      TEARDOWN C unit[1]\r\n      TEARDOWN C proto['b']\r\n```\r\n\r\nThe way `@pytest.mark.parametrize` works behind the scenes is that it basically desugars to this:\r\n\r\n```py\r\nimport pytest\r\n\r\n@pytest.fixture(params=[1, 2], scope='class')\r\ndef unit(request):\r\n    return request.param\r\n\r\n@pytest.fixture(params=['a', 'b'], scope='class')\r\ndef proto(request):\r\n    return request.param\r\n\r\nclass Test:\r\n    def test(self, unit, proto):\r\n        pass\r\n```\r\n\r\nIn this framing, it is clearer why we want to minimize the setups/teardowns -- the fixtures can do real work, not just return the param. Both pytest 7 and 8 reorder this version to have 5 setups/teardowns.\r\n\r\nI can't say why before 09b78737a5bde23eb488d5d6649bf966c5809176 the reordering *didn't* happen, and if this was intentional or accidental. Will look into it more.\n@bluetech i believe the change by @sadra-barikbin fixed a bug in pytest wrt scope ordering\r\n\r\nit dates back to #519 and the fix corrects the test scope ordering based on values and fixture values and scopes\r\n\r\nfor further validation we might want to add a variant of the example for #519 that mixes class scope in (in which case the old order is actually correct \r\n\r\nbut the basic gist to my current understanding is that pytest no longer has ordering differences between sugared and de-sugared parameterize as now parameterize is expressed in pseudo fixtures all the way\r\n\nTechnical details of the change:\r\n\r\nBefore 09b78737a5bde23eb488d5d6649bf966c5809176, Metafunc will generate CallSpec's with separate `params` (indirect parametrizations, i.e. through fixtures) and `funcargs` (direct parametrizations), and the desugaring of direct to indirect (i.e.g `funcargs` to `params`) happened as a separate step after `pytest_generate_functions`: https://github.com/pytest-dev/pytest/blob/7.4.4/src/_pytest/fixtures.py#L156.\r\n\r\nAfter 09b78737a5bde23eb488d5d6649bf966c5809176, Metafunc handles the desugaring itself, and there is no more `funcargs`.\r\n\r\nAll of this happens before `reorder_items` anyway, so why does it affect the item ordering? The difference is the `param_index` that the desugaring assigns to the (desguared) direct params. Before the code was this:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/7.4.4/src/_pytest/fixtures.py#L168-L181\r\n\r\nThe important bit is `callspec.indices[argname] = len(arg2params_list)` - this basically assigns a fresh param index *across* all callspecs. This results in the following arg keys in `reorder_items`:\r\n\r\n```py\r\n('proto', 0, <Function test[1-a]>)\r\n('proto', 1, <Function test[1-b]>)\r\n('proto', 2, <Function test[2-a]>)\r\n('proto', 3, <Function test[2-b]>)\r\n('unit',  0, <Function test[1-a]>)\r\n('unit',  1, <Function test[1-b]>)\r\n('unit',  2, <Function test[2-a]>)\r\n('unit',  3, <Function test[2-b]>)\r\n```\r\n\r\nAfter, there is no special handling of the param indexes of direct params, they are handled same as parametrized fixtures. This results in the following arg keys:\r\n\r\n```py\r\n('proto', 0, <Function test[1-a]>)\r\n('proto', 0, <Function test[2-a]>)\r\n('proto', 1, <Function test[1-b]>)\r\n('proto', 1, <Function test[2-b]>)\r\n('unit',  0, <Function test[1-a]>)\r\n('unit',  0, <Function test[1-b]>)\r\n('unit',  1, <Function test[2-a]>)\r\n('unit',  1, <Function test[2-b]>)\r\n```\r\n\r\nRephrasing the above in a way that may be clearer:\r\n\r\nBefore, indexes for direct params were assigned in a sequential manner per `argname` after all parametrizations are exploded, so we have a table of `argname`, `item` (= callspec) and we assign the param index:\r\n\r\n| argname | item | param index |\r\n|--------|--------|--------|\r\n| proto | test[1-a] | 0 |\r\n| proto | test[1-b] | 1 |\r\n| proto | test[2-a] | 2 |\r\n| proto | test[2-b] | 3 |\r\n| unit | test[1-a] | 0 | \r\n| unit | test[1-b] | 1 | \r\n| unit | test[2-a] | 2 | \r\n| unit | test[2-b] | 3 | \r\n\r\nAfter, the param indexes are assigned as they would for the desugaring I gave above:\r\n\r\n```py\r\nimport pytest\r\n\r\n# param indexes:        0  1\r\n@pytest.fixture(params=[1, 2], scope='class')\r\ndef unit(request):\r\n    return request.param\r\n\r\n# param indexes:         0    1\r\n@pytest.fixture(params=['a', 'b'], scope='class')\r\ndef proto(request):\r\n    return request.param\r\n```\n@ShurikMen I wonder, is the example you gave realistic or do you use `indirect` params maybe? I'm mainly curious why you're setting `scope='class'` on your `parametrize`s when the parameters are simple values. With `function` scope the ordering is as you expect.\n> @ShurikMen I wonder, is the example you gave realistic or do you use `indirect` params maybe? I'm mainly curious why you're setting `scope='class'` on your `parametrize`s when the parameters are simple values.\r\n\r\nThis is one of the simplest examples that are actually used in my projects. There are many examples with an even larger set of parameters including \"mixed\" scopes (class/function).\r\n\r\n> With `function` scope the ordering is as you expect.\r\n\r\nNot quite like that. Changing the order causes unwanted fixture calls. They are very expensive in terms of execution time.\r\nIt is important for me that tests with the same set of parameters are called sequentially.\r\n\r\nWith scope class (same optimal):\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\n@pytest.fixture(autouse=True, scope='class')\r\ndef some_fix(unit, proto):\r\n    yield\r\n\r\n\r\n@pytest.mark.parametrize('proto', ['serial', 'telnet'], scope='class')\r\n@pytest.mark.parametrize('unit', [1, 2], scope='class')\r\nclass TestA:\r\n    def test_one(self, unit, proto):\r\n        pass\r\n\r\n    def test_two(self, unit, proto):\r\n        pass\r\n```\r\n```\r\ntest_asd.py::TestA::test_one[1-serial] \r\n      SETUP    C unit[1]\r\n      SETUP    C proto['serial']\r\n      SETUP    C some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-serial] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_two[1-serial] \r\n        test_asd.py::TestA::test_two[1-serial] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_one[1-telnet] \r\n      TEARDOWN C some_fix\r\n      TEARDOWN C proto['serial']\r\n      SETUP    C proto['telnet']\r\n      SETUP    C some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-telnet] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_two[1-telnet] \r\n        test_asd.py::TestA::test_two[1-telnet] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_one[2-serial] \r\n      TEARDOWN C some_fix\r\n      TEARDOWN C unit[1]\r\n      SETUP    C unit[2]\r\n      TEARDOWN C proto['telnet']\r\n      SETUP    C proto['serial']\r\n      SETUP    C some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-serial] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_two[2-serial] \r\n        test_asd.py::TestA::test_two[2-serial] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_one[2-telnet] \r\n      TEARDOWN C some_fix\r\n      TEARDOWN C proto['serial']\r\n      SETUP    C proto['telnet']\r\n      SETUP    C some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-telnet] (fixtures used: proto, some_fix, unit)\r\ntest_asd.py::TestA::test_two[2-telnet] \r\n        test_asd.py::TestA::test_two[2-telnet] (fixtures used: proto, some_fix, unit)\r\n      TEARDOWN C some_fix\r\n      TEARDOWN C proto['telnet']\r\n      TEARDOWN C unit[2]\r\n```\r\n\r\nWith scope function\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\n@pytest.fixture(autouse=True, scope='function')\r\ndef some_fix(unit, proto):\r\n    yield\r\n\r\n\r\n@pytest.mark.parametrize('proto', ['serial', 'telnet'], scope='function')\r\n@pytest.mark.parametrize('unit', [1, 2], scope='function')\r\nclass TestA:\r\n    def test_one(self, unit, proto):\r\n        pass\r\n\r\n    def test_two(self, unit, proto):\r\n        pass\r\n\r\n```\r\n```\r\ntest_asd.py::TestA::test_one[1-serial] \r\n        SETUP    F unit[1]\r\n        SETUP    F proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['serial']\r\n        TEARDOWN F unit[1]\r\ntest_asd.py::TestA::test_one[1-telnet] \r\n        SETUP    F unit[1]\r\n        SETUP    F proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['telnet']\r\n        TEARDOWN F unit[1]\r\ntest_asd.py::TestA::test_one[2-serial] \r\n        SETUP    F unit[2]\r\n        SETUP    F proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['serial']\r\n        TEARDOWN F unit[2]\r\ntest_asd.py::TestA::test_one[2-telnet] \r\n        SETUP    F unit[2]\r\n        SETUP    F proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['telnet']\r\n        TEARDOWN F unit[2]\r\ntest_asd.py::TestA::test_two[1-serial] \r\n        SETUP    F unit[1]\r\n        SETUP    F proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[1-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['serial']\r\n        TEARDOWN F unit[1]\r\ntest_asd.py::TestA::test_two[1-telnet] \r\n        SETUP    F unit[1]\r\n        SETUP    F proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[1-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['telnet']\r\n        TEARDOWN F unit[1]\r\ntest_asd.py::TestA::test_two[2-serial] \r\n        SETUP    F unit[2]\r\n        SETUP    F proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[2-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['serial']\r\n        TEARDOWN F unit[2]\r\ntest_asd.py::TestA::test_two[2-telnet] \r\n        SETUP    F unit[2]\r\n        SETUP    F proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[2-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n        TEARDOWN F proto['telnet']\r\n        TEARDOWN F unit[2]\r\n```\r\n\r\nClass params with function fixture\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\n@pytest.fixture(autouse=True, scope='function')\r\ndef some_fix(unit, proto):\r\n    yield\r\n\r\n\r\n@pytest.mark.parametrize('proto', ['serial', 'telnet'], scope='class')\r\n@pytest.mark.parametrize('unit', [1, 2], scope='class')\r\nclass TestA:\r\n    def test_one(self, unit, proto):\r\n        pass\r\n\r\n    def test_two(self, unit, proto):\r\n        pass\r\n\r\n```\r\n```\r\ntest_asd.py::TestA::test_one[1-serial] \r\n      SETUP    C unit[1]\r\n      SETUP    C proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_two[1-serial] \r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[1-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_one[1-telnet] \r\n      TEARDOWN C proto['serial']\r\n      SETUP    C proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[1-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_two[1-telnet] \r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[1-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_one[2-serial] \r\n      TEARDOWN C unit[1]\r\n      SETUP    C unit[2]\r\n      TEARDOWN C proto['telnet']\r\n      SETUP    C proto['serial']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_two[2-serial] \r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[2-serial] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_one[2-telnet] \r\n      TEARDOWN C proto['serial']\r\n      SETUP    C proto['telnet']\r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_one[2-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\ntest_asd.py::TestA::test_two[2-telnet] \r\n        SETUP    F some_fix (fixtures used: proto, unit)\r\n        test_asd.py::TestA::test_two[2-telnet] (fixtures used: proto, some_fix, unit)\r\n        TEARDOWN F some_fix\r\n      TEARDOWN C proto['telnet']\r\n      TEARDOWN C unit[2]\r\n```\r\n\r\nHere I experimented a lot with various combinations of scope parameters and scope fixtures, including parameterization in fixtures (pytest.fixture(param=...)) to obtain the most optimal ways to perform fixtures and tests.\nCurrently when parameterize is taken for consideration, compound dependent fixtures are not\n\nId recommend having a single parameterset that creates the correct compound parameters to a single fixture so it will no longer be considered as independent parameters \n@bluetech take a look at #12082\nHere are the three approaches:\r\n![pytest-reorder](https://github.com/pytest-dev/pytest/assets/22097587/c0cbc2d3-891c-4909-8917-560bcaddbd9a)\r\n\nSeems we have an appearance-efficiency trade-off, with @ShurikMen's suggestion and v7.4.4 approach yielding better appearance but having lower efficiency in setup-teardowns in comparison with v8.0.0.\r\n\r\nThe three approaches could also be compared in terms of robustness to **parametrization varieties** which @ShurikMen 's suggestion for example performs better than v7.4.4 and solves the first example of #11257 but fails on the example below which v8.0.0 solves, unless the user be cautious and swap the order of parametrizations on `test1`.\r\n```python\r\n# Here `test1[\"b\",0]` and `test2[3]` would wrongfully have a common fixturekey in @ShurikMen 's method.\r\n@pytest.mark.parametrize(\"arg2\", [0, 1, 2], scope='module')\r\n@pytest.mark.parametrize(\"arg1\", [\"a\", \"b\"], scope='module')\r\ndef test1(arg1, arg2):\r\n    pass\r\n\r\n@pytest.mark.parametrize(\"arg2\", [0, 1, 2, 3], scope='module')\r\ndef test2(arg2):\r\n    pass\r\n```\r\nConsidering robustness alone, @ShurikMen method's gain over v7.4.4 seems remarkable but  I'm not sure about that of v8.0.0 over @ShurikMen 's.\nAside by the comments above,I'm for the notion of bug for current reordering in v8.0.0 as it has not been introduced by the intention to become more efficient which we discussed here about. It either has been an unnoticed side-effect of #11220 or something in my large initial PR, responsible for the first example of #11257 (which @ShurikMen 's method now solves as well). Sorry for inconvenience, mates!\nI have updated the pr. Unified indexing of parameters added through a marker and through fixtures. I think it's the right thing to do. Along the way, I corrected the tests related to parameterization through fixtures.\n@bluetech what about solving the problem on this issue?", "created_at": "2024-06-27T16:43:47Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12526, "instance_id": "pytest-dev__pytest-12526", "issue_numbers": ["12505"], "base_commit": "f74e947c1fdfef238235b7dd18c8fe52108268f2", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 5ae80eb02d..50e44038d4 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -429,6 +429,7 @@ Victor Rodriguez\n Victor Uriarte\n Vidar T. Fauske\n Vijay Arora\n+Virendra Patil\n Virgil Dupras\n Vitaly Lashmanov\n Vivaan Verma\ndiff --git a/changelog/12505.bugfix.rst b/changelog/12505.bugfix.rst\nnew file mode 100644\nindex 0000000000..f55a8a17e4\n--- /dev/null\n+++ b/changelog/12505.bugfix.rst\n@@ -0,0 +1,1 @@\n+Improve handling of invalid regex patterns in :func:`pytest.raises(match=r'...') <pytest.raises>` by providing a clear error message.\n", "test_patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex c1e851391b..4174a55b58 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -7,6 +7,7 @@\n import math\n from numbers import Complex\n import pprint\n+import re\n from types import TracebackType\n from typing import Any\n from typing import Callable\n@@ -986,6 +987,14 @@ def __init__(\n         self.message = message\n         self.match_expr = match_expr\n         self.excinfo: _pytest._code.ExceptionInfo[E] | None = None\n+        if self.match_expr is not None:\n+            re_error = None\n+            try:\n+                re.compile(self.match_expr)\n+            except re.error as e:\n+                re_error = e\n+            if re_error is not None:\n+                fail(f\"Invalid regex pattern provided to 'match': {re_error}\")\n \n     def __enter__(self) -> _pytest._code.ExceptionInfo[E]:\n         self.excinfo = _pytest._code.ExceptionInfo.for_later()\ndiff --git a/testing/python/raises.py b/testing/python/raises.py\nindex 271dd3e5a8..2011c81615 100644\n--- a/testing/python/raises.py\n+++ b/testing/python/raises.py\n@@ -132,6 +132,26 @@ def test_division(example_input, expectation):\n         result = pytester.runpytest()\n         result.stdout.fnmatch_lines([\"*2 failed*\"])\n \n+    def test_raises_with_invalid_regex(self, pytester: Pytester) -> None:\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_invalid_regex():\n+                with pytest.raises(ValueError, match=\"invalid regex character [\"):\n+                    raise ValueError()\n+            \"\"\"\n+        )\n+        result = pytester.runpytest()\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*Invalid regex pattern provided to 'match': unterminated character set at position 24*\",\n+            ]\n+        )\n+        result.stdout.no_fnmatch_line(\"*Traceback*\")\n+        result.stdout.no_fnmatch_line(\"*File*\")\n+        result.stdout.no_fnmatch_line(\"*line*\")\n+\n     def test_noclass(self) -> None:\n         with pytest.raises(TypeError):\n             pytest.raises(\"wrong\", lambda: None)  # type: ignore[call-overload]\n", "problem_statement": "`pytest.raises` with invalid regex in match kwarg fails with internal `re.error`\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\nUsing an invalid regex in `pytest.raises` fails in a messy way. \r\n\r\n```py\r\nwith pytest.raises(ValueError, match=\"invalid regex character [\"):\r\n    raise ValueError()\r\n```\r\n\r\n```shell\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 2, in <module>\r\nValueError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 2, in <module>\r\n  File \"C:\\Users\\user\\Documents\\Projects\\external\\pytest\\src\\_pytest\\python_api.py\", line 1011, in __exit__\r\n    self.excinfo.match(self.match_expr)\r\n  File \"C:\\Users\\user\\Documents\\Projects\\external\\pytest\\src\\_pytest\\_code\\code.py\", line 733, in match\r\n    assert re.search(regexp, value), msg\r\n  File \"C:\\Python38\\lib\\re.py\", line 201, in search\r\n    return _compile(pattern, flags).search(string)\r\n  File \"C:\\Python38\\lib\\re.py\", line 304, in _compile\r\n    p = sre_compile.compile(pattern, flags)\r\n  File \"C:\\Python38\\lib\\sre_compile.py\", line 764, in compile\r\n    p = sre_parse.parse(p, flags)\r\n  File \"C:\\Python38\\lib\\sre_parse.py\", line 948, in parse\r\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\r\n  File \"C:\\Python38\\lib\\sre_parse.py\", line 443, in _parse_sub\r\n    itemsappend(_parse(source, state, verbose, nested + 1,\r\n  File \"C:\\Python38\\lib\\sre_parse.py\", line 549, in _parse\r\n    raise source.error(\"unterminated character set\",\r\nre.error: unterminated character set at position 24\r\n```\r\n\r\nProposal would be to handle regex failures within `pytest.raises` and fail nicely for the user (`UsageError`).\r\n\r\n- [ ] a detailed description of the bug or problem you are having\r\n- [ ] output of `pip list` from the virtual environment you are using\r\n- [ ] pytest and operating system versions\r\n- [ ] minimal example if possible\r\n\n", "hints_text": "Here's how I would go about this:\r\n\r\n- Take the example from above and turn it into a test case\r\n    - `testing/python/raises.py` is where the existing tests are for `pytest.raises`\r\n    - Since we are mostly interested in the *output* of pytest, a test [using `pytester`](https://doc.pytest.org/en/latest/how-to/writing_plugins.html#testing-plugins) would be a good fit here.\r\n    - You could use one of the cases in `test_raises_as_contextmanager` as inspiration, but instead of matching that the test case passed, you use `result.stdout.fnmatch_lines` to see what output pytest produces when the pattern is invalid.\r\n    - I'd actually make the test pass initially, i.e. test the current output.\r\n- Improve pytest's output in that case.\r\n    - If you look at the traceback from above, you can see that the relevant lines *inside* pytest where this is happening are:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/329d3712146e69c471be3e30883d54bdde2f76cb/src/_pytest/python_api.py#L1005\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/329d3712146e69c471be3e30883d54bdde2f76cb/src/_pytest/_code/code.py#L728\r\n\r\n(line numbers slightly different, not sure what version @lovetheguitar was on above)\r\n\r\n- Find the correct place do do a change like this\r\n    - The latter (`code.py`) is the more internal machinery in pytest. It might be used across different places, some of which are not user-facing. So this would be the wrong place to do this kind of change.\r\n    - The former (`RaisesContext`) seems like the better place.\r\n    - In fact, a few lines above you can already spot [a call to `pytest.fail(...)`](https://github.com/pytest-dev/pytest/blob/329d3712146e69c471be3e30883d54bdde2f76cb/src/_pytest/python_api.py#L997), which is how we [explicitely fail a test case nicely](https://docs.pytest.org/en/8.2.x/reference/reference.html#pytest-fail).\r\n    - ...so the only thing that's left would be to catch the exception (`re.error`) and turn it into a `pytest.fail` call with a nice message\r\n    - Make sure you format the original exception text into the new message to retain the information about what's wrong exactly\r\n- Finally, adjust your test case to test the new output. Maybe [add an assertion](https://docs.pytest.org/en/8.2.x/reference/reference.html#pytest.LineMatcher.no_fnmatch_line) that makes sure that we don't print a full traceback, only a nice short message.\r\n- This will also need a changelog fragment - see the [contribution docs](https://github.com/pytest-dev/pytest/blob/main/CONTRIBUTING.rst#preparing-pull-requests) for more details.\r\n", "created_at": "2024-06-23T20:57:41Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12500, "instance_id": "pytest-dev__pytest-12500", "issue_numbers": ["12281"], "base_commit": "e8fa8dd31c365cb5b52f8bdf1966e13cbf66e9ec", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 4d34d2ba9b..5ae80eb02d 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -245,6 +245,7 @@ Levon Saldamli\n Lewis Cowles\n Llandy Riveron Del Risco\n Loic Esteve\n+lovetheguitar\n Lukas Bednar\n Luke Murphy\n Maciek Fijalkowski\ndiff --git a/changelog/12281.feature.rst b/changelog/12281.feature.rst\nnew file mode 100644\nindex 0000000000..c6e8e3b309\n--- /dev/null\n+++ b/changelog/12281.feature.rst\n@@ -0,0 +1,8 @@\n+Added support for keyword matching in marker expressions.\n+\n+Now tests can be selected by marker keyword arguments.\n+Supported values are :class:`int`, (unescaped) :class:`str`, :class:`bool` & :data:`None`.\n+\n+See :ref:`marker examples <marker_keyword_expression_example>` for more information.\n+\n+-- by :user:`lovetheguitar`\ndiff --git a/doc/en/example/markers.rst b/doc/en/example/markers.rst\nindex c04d2a078d..159ff2cd1d 100644\n--- a/doc/en/example/markers.rst\n+++ b/doc/en/example/markers.rst\n@@ -25,10 +25,12 @@ You can \"mark\" a test function with custom metadata like this:\n         pass  # perform some webtest test for your app\n \n \n+    @pytest.mark.device(serial=\"123\")\n     def test_something_quick():\n         pass\n \n \n+    @pytest.mark.device(serial=\"abc\")\n     def test_another():\n         pass\n \n@@ -71,6 +73,28 @@ Or the inverse, running all tests except the webtest ones:\n \n     ===================== 3 passed, 1 deselected in 0.12s ======================\n \n+.. _`marker_keyword_expression_example`:\n+\n+Additionally, you can restrict a test run to only run tests matching one or multiple marker\n+keyword arguments, e.g. to run only tests marked with ``device`` and the specific ``serial=\"123\"``:\n+\n+.. code-block:: pytest\n+\n+    $ pytest -v -m 'device(serial=\"123\")'\n+    =========================== test session starts ============================\n+    platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python\n+    cachedir: .pytest_cache\n+    rootdir: /home/sweet/project\n+    collecting ... collected 4 items / 3 deselected / 1 selected\n+\n+    test_server.py::test_something_quick PASSED                          [100%]\n+\n+    ===================== 1 passed, 3 deselected in 0.12s ======================\n+\n+.. note:: Only keyword argument matching is supported in marker expressions.\n+\n+.. note:: Only :class:`int`, (unescaped) :class:`str`, :class:`bool` & :data:`None` values are supported in marker expressions.\n+\n Selecting tests based on their node ID\n --------------------------------------\n \ndiff --git a/doc/en/how-to/usage.rst b/doc/en/how-to/usage.rst\nindex 705fa009ed..05ee046001 100644\n--- a/doc/en/how-to/usage.rst\n+++ b/doc/en/how-to/usage.rst\n@@ -76,11 +76,19 @@ Specifying a specific parametrization of a test:\n \n **Run tests by marker expressions**\n \n+To run all tests which are decorated with the ``@pytest.mark.slow`` decorator:\n+\n .. code-block:: bash\n \n     pytest -m slow\n \n-Will run all tests which are decorated with the ``@pytest.mark.slow`` decorator.\n+\n+To run all tests which are decorated with the annotated ``@pytest.mark.slow(phase=1)`` decorator,\n+with the ``phase`` keyword argument set to ``1``:\n+\n+.. code-block:: bash\n+\n+    pytest -m slow(phase=1)\n \n For more information see :ref:`marks <mark>`.\n \ndiff --git a/pyproject.toml b/pyproject.toml\nindex 14f69bc342..e0ed2b9006 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -358,6 +358,9 @@ markers = [\n     \"foo\",\n     \"bar\",\n     \"baz\",\n+    \"number_mark\",\n+    \"builtin_matchers_mark\",\n+    \"str_mark\",\n     # conftest.py reorders tests moving slow ones to the end of the list\n     \"slow\",\n     # experimental mark for all tests using pexpect\n", "test_patch": "diff --git a/src/_pytest/mark/__init__.py b/src/_pytest/mark/__init__.py\nindex b8a3092151..a4f942c5ae 100644\n--- a/src/_pytest/mark/__init__.py\n+++ b/src/_pytest/mark/__init__.py\n@@ -2,9 +2,11 @@\n \n from __future__ import annotations\n \n+import collections\n import dataclasses\n from typing import AbstractSet\n from typing import Collection\n+from typing import Iterable\n from typing import Optional\n from typing import TYPE_CHECKING\n \n@@ -21,6 +23,7 @@\n from _pytest.config import ExitCode\n from _pytest.config import hookimpl\n from _pytest.config import UsageError\n+from _pytest.config.argparsing import NOT_SET\n from _pytest.config.argparsing import Parser\n from _pytest.stash import StashKey\n \n@@ -181,7 +184,9 @@ def from_item(cls, item: Item) -> KeywordMatcher:\n \n         return cls(mapped_names)\n \n-    def __call__(self, subname: str) -> bool:\n+    def __call__(self, subname: str, /, **kwargs: str | int | bool | None) -> bool:\n+        if kwargs:\n+            raise UsageError(\"Keyword expressions do not support call parameters.\")\n         subname = subname.lower()\n         names = (name.lower() for name in self._names)\n \n@@ -218,17 +223,26 @@ class MarkMatcher:\n     Tries to match on any marker names, attached to the given colitem.\n     \"\"\"\n \n-    __slots__ = (\"own_mark_names\",)\n+    __slots__ = (\"own_mark_name_mapping\",)\n \n-    own_mark_names: AbstractSet[str]\n+    own_mark_name_mapping: dict[str, list[Mark]]\n \n     @classmethod\n-    def from_item(cls, item: Item) -> MarkMatcher:\n-        mark_names = {mark.name for mark in item.iter_markers()}\n-        return cls(mark_names)\n+    def from_markers(cls, markers: Iterable[Mark]) -> MarkMatcher:\n+        mark_name_mapping = collections.defaultdict(list)\n+        for mark in markers:\n+            mark_name_mapping[mark.name].append(mark)\n+        return cls(mark_name_mapping)\n+\n+    def __call__(self, name: str, /, **kwargs: str | int | bool | None) -> bool:\n+        if not (matches := self.own_mark_name_mapping.get(name, [])):\n+            return False\n+\n+        for mark in matches:\n+            if all(mark.kwargs.get(k, NOT_SET) == v for k, v in kwargs.items()):\n+                return True\n \n-    def __call__(self, name: str) -> bool:\n-        return name in self.own_mark_names\n+        return False\n \n \n def deselect_by_mark(items: list[Item], config: Config) -> None:\n@@ -240,7 +254,7 @@ def deselect_by_mark(items: list[Item], config: Config) -> None:\n     remaining: list[Item] = []\n     deselected: list[Item] = []\n     for item in items:\n-        if expr.evaluate(MarkMatcher.from_item(item)):\n+        if expr.evaluate(MarkMatcher.from_markers(item.iter_markers())):\n             remaining.append(item)\n         else:\n             deselected.append(item)\ndiff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex e65b028589..3f4071dcef 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -5,7 +5,8 @@\n expression: expr? EOF\n expr:       and_expr ('or' and_expr)*\n and_expr:   not_expr ('and' not_expr)*\n-not_expr:   'not' not_expr | '(' expr ')' | ident\n+not_expr:   'not' not_expr | '(' expr ')' | ident ( '(' name '=' value ( ', ' name '=' value )*  ')')*\n+\n ident:      (\\w|:|\\+|-|\\.|\\[|\\]|\\\\|/)+\n \n The semantics are:\n@@ -20,12 +21,15 @@\n import ast\n import dataclasses\n import enum\n+import keyword\n import re\n import types\n-from typing import Callable\n from typing import Iterator\n+from typing import Literal\n from typing import Mapping\n from typing import NoReturn\n+from typing import overload\n+from typing import Protocol\n from typing import Sequence\n \n \n@@ -43,6 +47,9 @@ class TokenType(enum.Enum):\n     NOT = \"not\"\n     IDENT = \"identifier\"\n     EOF = \"end of input\"\n+    EQUAL = \"=\"\n+    STRING = \"str\"\n+    COMMA = \",\"\n \n \n @dataclasses.dataclass(frozen=True)\n@@ -86,6 +93,27 @@ def lex(self, input: str) -> Iterator[Token]:\n             elif input[pos] == \")\":\n                 yield Token(TokenType.RPAREN, \")\", pos)\n                 pos += 1\n+            elif input[pos] == \"=\":\n+                yield Token(TokenType.EQUAL, \"=\", pos)\n+                pos += 1\n+            elif input[pos] == \",\":\n+                yield Token(TokenType.COMMA, \",\", pos)\n+                pos += 1\n+            elif (quote_char := input[pos]) in (\"'\", '\"'):\n+                end_quote_pos = input.find(quote_char, pos + 1)\n+                if end_quote_pos == -1:\n+                    raise ParseError(\n+                        pos + 1,\n+                        f'closing quote \"{quote_char}\" is missing',\n+                    )\n+                value = input[pos : end_quote_pos + 1]\n+                if (backslash_pos := input.find(\"\\\\\")) != -1:\n+                    raise ParseError(\n+                        backslash_pos + 1,\n+                        r'escaping with \"\\\" not supported in marker expression',\n+                    )\n+                yield Token(TokenType.STRING, value, pos)\n+                pos += len(value)\n             else:\n                 match = re.match(r\"(:?\\w|:|\\+|-|\\.|\\[|\\]|\\\\|/)+\", input[pos:])\n                 if match:\n@@ -106,6 +134,14 @@ def lex(self, input: str) -> Iterator[Token]:\n                     )\n         yield Token(TokenType.EOF, \"\", pos)\n \n+    @overload\n+    def accept(self, type: TokenType, *, reject: Literal[True]) -> Token: ...\n+\n+    @overload\n+    def accept(\n+        self, type: TokenType, *, reject: Literal[False] = False\n+    ) -> Token | None: ...\n+\n     def accept(self, type: TokenType, *, reject: bool = False) -> Token | None:\n         if self.current.type is type:\n             token = self.current\n@@ -166,18 +202,87 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n-        return ast.Name(IDENT_PREFIX + ident.value, ast.Load())\n+        name = ast.Name(IDENT_PREFIX + ident.value, ast.Load())\n+        if s.accept(TokenType.LPAREN):\n+            ret = ast.Call(func=name, args=[], keywords=all_kwargs(s))\n+            s.accept(TokenType.RPAREN, reject=True)\n+        else:\n+            ret = name\n+        return ret\n+\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n \n-class MatcherAdapter(Mapping[str, bool]):\n+BUILTIN_MATCHERS = {\"True\": True, \"False\": False, \"None\": None}\n+\n+\n+def single_kwarg(s: Scanner) -> ast.keyword:\n+    keyword_name = s.accept(TokenType.IDENT, reject=True)\n+    if not keyword_name.value.isidentifier():\n+        raise ParseError(\n+            keyword_name.pos + 1,\n+            f\"not a valid python identifier {keyword_name.value}\",\n+        )\n+    if keyword.iskeyword(keyword_name.value):\n+        raise ParseError(\n+            keyword_name.pos + 1,\n+            f\"unexpected reserved python keyword `{keyword_name.value}`\",\n+        )\n+    s.accept(TokenType.EQUAL, reject=True)\n+\n+    if value_token := s.accept(TokenType.STRING):\n+        value: str | int | bool | None = value_token.value[1:-1]  # strip quotes\n+    else:\n+        value_token = s.accept(TokenType.IDENT, reject=True)\n+        if (\n+            (number := value_token.value).isdigit()\n+            or number.startswith(\"-\")\n+            and number[1:].isdigit()\n+        ):\n+            value = int(number)\n+        elif value_token.value in BUILTIN_MATCHERS:\n+            value = BUILTIN_MATCHERS[value_token.value]\n+        else:\n+            raise ParseError(\n+                value_token.pos + 1,\n+                f'unexpected character/s \"{value_token.value}\"',\n+            )\n+\n+    ret = ast.keyword(keyword_name.value, ast.Constant(value))\n+    return ret\n+\n+\n+def all_kwargs(s: Scanner) -> list[ast.keyword]:\n+    ret = [single_kwarg(s)]\n+    while s.accept(TokenType.COMMA):\n+        ret.append(single_kwarg(s))\n+    return ret\n+\n+\n+class MatcherCall(Protocol):\n+    def __call__(self, name: str, /, **kwargs: str | int | bool | None) -> bool: ...\n+\n+\n+@dataclasses.dataclass\n+class MatcherNameAdapter:\n+    matcher: MatcherCall\n+    name: str\n+\n+    def __bool__(self) -> bool:\n+        return self.matcher(self.name)\n+\n+    def __call__(self, **kwargs: str | int | bool | None) -> bool:\n+        return self.matcher(self.name, **kwargs)\n+\n+\n+class MatcherAdapter(Mapping[str, MatcherNameAdapter]):\n     \"\"\"Adapts a matcher function to a locals mapping as required by eval().\"\"\"\n \n-    def __init__(self, matcher: Callable[[str], bool]) -> None:\n+    def __init__(self, matcher: MatcherCall) -> None:\n         self.matcher = matcher\n \n-    def __getitem__(self, key: str) -> bool:\n-        return self.matcher(key[len(IDENT_PREFIX) :])\n+    def __getitem__(self, key: str) -> MatcherNameAdapter:\n+        return MatcherNameAdapter(matcher=self.matcher, name=key[len(IDENT_PREFIX) :])\n \n     def __iter__(self) -> Iterator[str]:\n         raise NotImplementedError()\n@@ -211,7 +316,7 @@ def compile(self, input: str) -> Expression:\n         )\n         return Expression(code)\n \n-    def evaluate(self, matcher: Callable[[str], bool]) -> bool:\n+    def evaluate(self, matcher: MatcherCall) -> bool:\n         \"\"\"Evaluate the match expression.\n \n         :param matcher:\n@@ -220,5 +325,5 @@ def evaluate(self, matcher: Callable[[str], bool]) -> bool:\n \n         :returns: Whether the expression matches or not.\n         \"\"\"\n-        ret: bool = eval(self.code, {\"__builtins__\": {}}, MatcherAdapter(matcher))\n+        ret: bool = bool(eval(self.code, {\"__builtins__\": {}}, MatcherAdapter(matcher)))\n         return ret\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 090e10ee9c..6a94cc9f7c 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -233,6 +233,54 @@ def test_two():\n     assert passed_str == expected_passed\n \n \n+@pytest.mark.parametrize(\n+    (\"expr\", \"expected_passed\"),\n+    [  # TODO: improve/sort out\n+        (\"car(color='red')\", [\"test_one\"]),\n+        (\"car(color='red') or car(color='blue')\", [\"test_one\", \"test_two\"]),\n+        (\"car and not car(temp=5)\", [\"test_one\", \"test_three\"]),\n+        (\"car(temp=4)\", [\"test_one\"]),\n+        (\"car(temp=4) or car(temp=5)\", [\"test_one\", \"test_two\"]),\n+        (\"car(temp=4) and car(temp=5)\", []),\n+        (\"car(temp=-5)\", [\"test_three\"]),\n+        (\"car(ac=True)\", [\"test_one\"]),\n+        (\"car(ac=False)\", [\"test_two\"]),\n+        (\"car(ac=None)\", [\"test_three\"]),  # test NOT_NONE_SENTINEL\n+    ],\n+    ids=str,\n+)\n+def test_mark_option_with_kwargs(\n+    expr: str, expected_passed: list[str | None], pytester: Pytester\n+) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        @pytest.mark.car\n+        @pytest.mark.car(ac=True)\n+        @pytest.mark.car(temp=4)\n+        @pytest.mark.car(color=\"red\")\n+        def test_one():\n+            pass\n+        @pytest.mark.car\n+        @pytest.mark.car(ac=False)\n+        @pytest.mark.car(temp=5)\n+        @pytest.mark.car(color=\"blue\")\n+        def test_two():\n+            pass\n+        @pytest.mark.car\n+        @pytest.mark.car(ac=None)\n+        @pytest.mark.car(temp=-5)\n+        def test_three():\n+            pass\n+\n+    \"\"\"\n+    )\n+    rec = pytester.inline_run(\"-m\", expr)\n+    passed, skipped, fail = rec.listoutcomes()\n+    passed_str = [x.nodeid.split(\"::\")[-1] for x in passed]\n+    assert passed_str == expected_passed\n+\n+\n @pytest.mark.parametrize(\n     (\"expr\", \"expected_passed\"),\n     [(\"interface\", [\"test_interface\"]), (\"not interface\", [\"test_nointer\"])],\n@@ -372,6 +420,10 @@ def test_func(arg):\n             \"not or\",\n             \"at column 5: expected not OR left parenthesis OR identifier; got or\",\n         ),\n+        (\n+            \"nonexistent_mark(non_supported='kwarg')\",\n+            \"Keyword expressions do not support call parameters\",\n+        ),\n     ],\n )\n def test_keyword_option_wrong_arguments(\ndiff --git a/testing/test_mark_expression.py b/testing/test_mark_expression.py\nindex 5bce004cb1..c31ab44704 100644\n--- a/testing/test_mark_expression.py\n+++ b/testing/test_mark_expression.py\n@@ -1,14 +1,17 @@\n from __future__ import annotations\n \n from typing import Callable\n+from typing import cast\n \n+from _pytest.mark import MarkMatcher\n from _pytest.mark.expression import Expression\n+from _pytest.mark.expression import MatcherCall\n from _pytest.mark.expression import ParseError\n import pytest\n \n \n def evaluate(input: str, matcher: Callable[[str], bool]) -> bool:\n-    return Expression.compile(input).evaluate(matcher)\n+    return Expression.compile(input).evaluate(cast(MatcherCall, matcher))\n \n \n def test_empty_is_false() -> None:\n@@ -153,6 +156,8 @@ def test_syntax_errors(expr: str, column: int, message: str) -> None:\n         \"1234\",\n         \"1234abcd\",\n         \"1234and\",\n+        \"1234or\",\n+        \"1234not\",\n         \"notandor\",\n         \"not_and_or\",\n         \"not[and]or\",\n@@ -195,3 +200,119 @@ def test_valid_idents(ident: str) -> None:\n def test_invalid_idents(ident: str) -> None:\n     with pytest.raises(ParseError):\n         evaluate(ident, lambda ident: True)\n+\n+\n+@pytest.mark.parametrize(\n+    \"expr, expected_error_msg\",\n+    (\n+        (\"mark(True=False)\", \"unexpected reserved python keyword `True`\"),\n+        (\"mark(def=False)\", \"unexpected reserved python keyword `def`\"),\n+        (\"mark(class=False)\", \"unexpected reserved python keyword `class`\"),\n+        (\"mark(if=False)\", \"unexpected reserved python keyword `if`\"),\n+        (\"mark(else=False)\", \"unexpected reserved python keyword `else`\"),\n+        (\"mark(valid=False, def=1)\", \"unexpected reserved python keyword `def`\"),\n+        (\"mark(1)\", \"not a valid python identifier 1\"),\n+        (\"mark(var:=False\", \"not a valid python identifier var:\"),\n+        (\"mark(1=2)\", \"not a valid python identifier 1\"),\n+        (\"mark(/=2)\", \"not a valid python identifier /\"),\n+        (\"mark(var==\", \"expected identifier; got =\"),\n+        (\"mark(var)\", \"expected =; got right parenthesis\"),\n+        (\"mark(var=none)\", 'unexpected character/s \"none\"'),\n+        (\"mark(var=1.1)\", 'unexpected character/s \"1.1\"'),\n+        (\"mark(var=')\", \"\"\"closing quote \"'\" is missing\"\"\"),\n+        ('mark(var=\")', 'closing quote \"\"\" is missing'),\n+        (\"\"\"mark(var=\"')\"\"\", 'closing quote \"\"\" is missing'),\n+        (\"\"\"mark(var='\")\"\"\", \"\"\"closing quote \"'\" is missing\"\"\"),\n+        (\n+            r\"mark(var='\\hugo')\",\n+            r'escaping with \"\\\\\" not supported in marker expression',\n+        ),\n+        (\"mark(empty_list=[])\", r'unexpected character/s \"\\[\\]\"'),\n+    ),\n+)\n+def test_invalid_kwarg_name_or_value(  # TODO: move to `test_syntax_errors` ?\n+    expr: str, expected_error_msg: str, mark_matcher: MarkMatcher\n+) -> None:\n+    with pytest.raises(ParseError, match=expected_error_msg):\n+        assert evaluate(expr, mark_matcher)\n+\n+\n+@pytest.fixture(scope=\"session\")\n+def mark_matcher() -> MarkMatcher:\n+    markers = [\n+        pytest.mark.number_mark(a=1, b=2, c=3, d=999_999).mark,\n+        pytest.mark.builtin_matchers_mark(x=True, y=False, z=None).mark,\n+        pytest.mark.str_mark(\n+            m=\"M\", space=\"with space\", empty=\"\", aa\u05d0\u05d1\u05d2\u05d3cc=\"aa\u05d0\u05d1\u05d2\u05d3cc\", \u05d0\u05d1\u05d2\u05d3=\"\u05d0\u05d1\u05d2\u05d3\"\n+        ).mark,\n+    ]\n+\n+    return MarkMatcher.from_markers(markers)\n+\n+\n+@pytest.mark.parametrize(\n+    \"expr, expected\",\n+    (\n+        # happy cases\n+        (\"number_mark(a=1)\", True),\n+        (\"number_mark(b=2)\", True),\n+        (\"number_mark(a=1,b=2)\", True),\n+        (\"number_mark(a=1,     b=2)\", True),\n+        (\"number_mark(d=999999)\", True),\n+        (\"number_mark(a   =   1,b= 2,     c = 3)\", True),\n+        # sad cases\n+        (\"number_mark(a=6)\", False),\n+        (\"number_mark(b=6)\", False),\n+        (\"number_mark(a=1,b=6)\", False),\n+        (\"number_mark(a=6,b=2)\", False),\n+        (\"number_mark(a   =   1,b= 2,     c = 6)\", False),\n+        (\"number_mark(a='1')\", False),\n+    ),\n+)\n+def test_keyword_expressions_with_numbers(\n+    expr: str, expected: bool, mark_matcher: MarkMatcher\n+) -> None:\n+    assert evaluate(expr, mark_matcher) is expected\n+\n+\n+@pytest.mark.parametrize(\n+    \"expr, expected\",\n+    (\n+        (\"builtin_matchers_mark(x=True)\", True),\n+        (\"builtin_matchers_mark(x=False)\", False),\n+        (\"builtin_matchers_mark(y=True)\", False),\n+        (\"builtin_matchers_mark(y=False)\", True),\n+        (\"builtin_matchers_mark(z=None)\", True),\n+        (\"builtin_matchers_mark(z=False)\", False),\n+        (\"builtin_matchers_mark(z=True)\", False),\n+        (\"builtin_matchers_mark(z=0)\", False),\n+        (\"builtin_matchers_mark(z=1)\", False),\n+    ),\n+)\n+def test_builtin_matchers_keyword_expressions(  # TODO: naming when decided\n+    expr: str, expected: bool, mark_matcher: MarkMatcher\n+) -> None:\n+    assert evaluate(expr, mark_matcher) is expected\n+\n+\n+@pytest.mark.parametrize(\n+    \"expr, expected\",\n+    (\n+        (\"str_mark(m='M')\", True),\n+        ('str_mark(m=\"M\")', True),\n+        (\"str_mark(aa\u05d0\u05d1\u05d2\u05d3cc='aa\u05d0\u05d1\u05d2\u05d3cc')\", True),\n+        (\"str_mark(\u05d0\u05d1\u05d2\u05d3='\u05d0\u05d1\u05d2\u05d3')\", True),\n+        (\"str_mark(space='with space')\", True),\n+        (\"str_mark(empty='')\", True),\n+        ('str_mark(empty=\"\")', True),\n+        (\"str_mark(m='wrong')\", False),\n+        (\"str_mark(aa\u05d0\u05d1\u05d2\u05d3cc='wrong')\", False),\n+        (\"str_mark(\u05d0\u05d1\u05d2\u05d3='wrong')\", False),\n+        (\"str_mark(m='')\", False),\n+        ('str_mark(m=\"\")', False),\n+    ),\n+)\n+def test_str_keyword_expressions(\n+    expr: str, expected: bool, mark_matcher: MarkMatcher\n+) -> None:\n+    assert evaluate(expr, mark_matcher) is expected\n", "problem_statement": "Support marker keyword arguments in marker expression (test selection via `-m`)  \n<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\n<!-- What are you trying to do, that you are unable to achieve with pytest as it currently stands? -->\r\n\r\nIt's possible to create custom markers like so:\r\n```py\r\n@pytest.mark.my_device_under_test\r\n```\r\n\r\nThis marker can the be used to de/select tests via marker expressions, e.g.:\r\n`pytest -m \"not my_device_under_test\"`\r\n\r\nIt is also possible to define keyword arguments for custom markers, e.g.:\r\n\r\n```py\r\n@pytest.mark.my_device_under_test(with_serial=\"1234\")\r\n```\r\n\r\nNow, it would be amazing to select tests further depending on their keyword arguments + values, e.g.:\r\n\r\n`pytest -m \"my_device_under_test(with_serial=\"1234)\"`\r\n\r\nSo only tests with that specific marker + that specific keyword argument+value would be run.\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n\r\nMarker keyword argument selection in pytest's marker expression.\r\n\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\n\r\n#### Alternative Solutions\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\n\r\n- There was a `nose` test plugin, which supported something similar [here](https://github.com/nose-devs/nose/blob/master/nose/plugins/attrib.py). This could be ported to pytest but comes with it's own `attr` decorator.\r\n\r\n- A pytest plugin could probably do this in an extra step as well, but would somehow need to disable pytest's internal marker selection plugin [here](https://github.com/pytest-dev/pytest/blob/main/src/_pytest/mark/__init__.py#L261) as it would collide/fail otherwise.\r\n\r\n#### Additional context\r\nWhen skimming through the code I saw that @bluetech implemented a custom parsers some years ago. I'm not very familiar with the topic, as in how much effort it would be support such feature. I'd be interested to contribute though. \r\n<!-- Add any other context, links, etc. about the feature here. -->\r\n\n", "hints_text": "The feature request makes sense to me, I think it would be great to allow matching on mark arguments (there are two kinds -- positional and keyword arguments), and something like the function call syntax seems natural for this.\r\n\r\nFor the match expression grammar, it shouldn't pose a big challenge to add. We would need to decide whether the argument values (the `1234` in your example) can be just idents (simple), or more complex, e.g. to support `my_device_under_test(with_serial=1234 or 5678)` etc., which would be more complex.\r\n\r\nThe bigger implementation issue would be the evaluation of the expression. Currently, to optimize the evaluation, we compile the expression to a python AST, then `eval` the AST with an environment (\"locals\") where every ident returns either True (if matches) or False. This will need to be extended to support the function-call syntax. As a quick thought, we could replace the `locals` hack with injecting some `$match` symbol into the `eval` environment which has the form `matcher(name, *args: str, **kwargs: str)` (assuming we only allow idents).\nIf we are to implement this, I propose we keep it simple, as it would be possible to also write `my_device_under_test(with_serial=1234) or my_device_under_test(with_serial=5678)`.\r\n\r\n\nI can see the appeal of this, and I agree in theory it makes sense to keep things close to a Python-like syntax.\r\n\r\nHowever, at the same time, I'm also worried this might be a bottomless pit. Where do we stop in terms of types of arguments we support? Allowing `my_device_under_test(with_serial=1234)` or `use_case(\"ABC-1234\")` seems obvious (and would indeed cover things I've seen various companies implement custom arguments/filtering via plugin hooks for).\r\n\r\nHowever, what about, say, enums? Surely there's an argument to be made for enums, as in `size(Size.end2end)`. But then where is `Size` coming from? I'm playing devil's advocate here, but if we allow enums, why wouldn't we also allow, I don't know, custom dataclass instances (in the sense of `device(Multimeter(...))`)? Etc. etc., and then at some point we're back to essentially reimplementing the `eval()` solution we had at some point.\r\n\r\nMaybe though, we could limit this to `int` / `str` / `bool` / `None` or somesuch, or perhaps what [`ast.literal_eval`](https://docs.python.org/3/library/ast.html#ast.literal_eval) supports. But still, while I can absolutely see the need and usefulness, it seems very tempting to take this too far over time.\r\n\nRunning into this thought myself, I was wondering if we could instead consider a bit of a tangent to avoid pitfalls mentioned by @The-Compiler. How about introducing a new interface called `pytest.mark.annotated(*args: str)`?\r\n\r\nIt would look like:\r\n```python\r\n@pytest.mark.annotated(\"annotation1\", \"annotation2\", ...)\r\ndef test_my_function(...):\r\n    pass\r\n```\r\nThe selection can be with a slightly specialized syntax:\r\n```\r\npytest -m [annotation1]\r\n```\r\nwhich can be combined with other non-annotated markers if needed:\r\n```sh\r\npytest -m \"awesome and [annotation1] and [annotation2]\"\r\n```\r\nThis is surely limiting, but maybe that's not a bad thing. For my use case, this would help with adding bug number/jira ticket annotations to test cases.", "created_at": "2024-06-20T16:50:09Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12492, "instance_id": "pytest-dev__pytest-12492", "issue_numbers": ["389"], "base_commit": "9947ec3ad1a0fb9f85b092a50b0866b3870e37ad", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 347efad57b..4d34d2ba9b 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -149,6 +149,7 @@ Evgeny Seliverstov\n Fabian Sturm\n Fabien Zarifian\n Fabio Zadrozny\n+Farbod Ahmadian\n faph\n Felix Hofst\u00e4tter\n Felix Nieuwenhuizen\ndiff --git a/changelog/389.improvement.rst b/changelog/389.improvement.rst\nnew file mode 100644\nindex 0000000000..f8e2c19fde\n--- /dev/null\n+++ b/changelog/389.improvement.rst\n@@ -0,0 +1,38 @@\n+The readability of assertion introspection of bound methods has been enhanced\n+-- by :user:`farbodahm`, :user:`webknjaz`, :user:`obestwalter`, :user:`flub`\n+and :user:`glyphack`.\n+\n+Earlier, it was like:\n+\n+.. code-block:: console\n+\n+    =================================== FAILURES ===================================\n+    _____________________________________ test _____________________________________\n+\n+        def test():\n+    >       assert Help().fun() == 2\n+    E       assert 1 == 2\n+    E        +  where 1 = <bound method Help.fun of <example.Help instance at 0x256a830>>()\n+    E        +    where <bound method Help.fun of <example.Help instance at 0x256a830>> = <example.Help instance at 0x256a830>.fun\n+    E        +      where <example.Help instance at 0x256a830> = Help()\n+\n+    example.py:7: AssertionError\n+    =========================== 1 failed in 0.03 seconds ===========================\n+\n+\n+And now it's like:\n+\n+.. code-block:: console\n+\n+    =================================== FAILURES ===================================\n+    _____________________________________ test _____________________________________\n+\n+        def test():\n+    >       assert Help().fun() == 2\n+    E       assert 1 == 2\n+    E        +  where 1 = fun()\n+    E        +    where fun = <test_local.Help object at 0x1074be230>.fun\n+    E        +      where <test_local.Help object at 0x1074be230> = Help()\n+\n+    test_local.py:13: AssertionError\n+    =========================== 1 failed in 0.03 seconds ===========================\n", "test_patch": "diff --git a/src/_pytest/_io/saferepr.py b/src/_pytest/_io/saferepr.py\nindex 5ace418227..13b793f0a7 100644\n--- a/src/_pytest/_io/saferepr.py\n+++ b/src/_pytest/_io/saferepr.py\n@@ -60,7 +60,6 @@ def repr(self, x: object) -> str:\n                 s = ascii(x)\n             else:\n                 s = super().repr(x)\n-\n         except (KeyboardInterrupt, SystemExit):\n             raise\n         except BaseException as exc:\ndiff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 442fc5d9f3..bfcbcbd3f8 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -417,6 +417,10 @@ def _saferepr(obj: object) -> str:\n     sequences, especially '\\n{' and '\\n}' are likely to be present in\n     JSON reprs.\n     \"\"\"\n+    if isinstance(obj, types.MethodType):\n+        # for bound methods, skip redundant <bound method ...> information\n+        return obj.__name__\n+\n     maxsize = _get_maxsize_for_saferepr(util._config)\n     return saferepr(obj, maxsize=maxsize).replace(\"\\n\", \"\\\\n\")\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 185cd5ef2e..5ee40ee656 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -10,6 +10,7 @@\n import os\n from pathlib import Path\n import py_compile\n+import re\n import stat\n import sys\n import textwrap\n@@ -24,6 +25,7 @@\n from _pytest.assertion import util\n from _pytest.assertion.rewrite import _get_assertion_exprs\n from _pytest.assertion.rewrite import _get_maxsize_for_saferepr\n+from _pytest.assertion.rewrite import _saferepr\n from _pytest.assertion.rewrite import AssertionRewritingHook\n from _pytest.assertion.rewrite import get_cache_dir\n from _pytest.assertion.rewrite import PYC_TAIL\n@@ -2036,7 +2038,9 @@ def test_foo():\n         assert test_foo_pyc.is_file()\n \n         # normal file: not touched by pytest, normal cache tag\n-        bar_init_pyc = get_cache_dir(bar_init) / f\"__init__.{sys.implementation.cache_tag}.pyc\"\n+        bar_init_pyc = (\n+            get_cache_dir(bar_init) / f\"__init__.{sys.implementation.cache_tag}.pyc\"\n+        )\n         assert bar_init_pyc.is_file()\n \n \n@@ -2103,3 +2107,26 @@ def test_foo():\n         )\n         result = pytester.runpytest()\n         assert result.ret == 0\n+\n+\n+class TestSafereprUnbounded:\n+    class Help:\n+        def bound_method(self):  # pragma: no cover\n+            pass\n+\n+    def test_saferepr_bound_method(self):\n+        \"\"\"saferepr() of a bound method should show only the method name\"\"\"\n+        assert _saferepr(self.Help().bound_method) == \"bound_method\"\n+\n+    def test_saferepr_unbounded(self):\n+        \"\"\"saferepr() of an unbound method should still show the full information\"\"\"\n+        obj = self.Help()\n+        # using id() to fetch memory address fails on different platforms\n+        pattern = re.compile(\n+            rf\"<{Path(__file__).stem}.{self.__class__.__name__}.Help object at 0x[0-9a-fA-F]*>\",\n+        )\n+        assert pattern.match(_saferepr(obj))\n+        assert (\n+            _saferepr(self.Help)\n+            == f\"<class '{Path(__file__).stem}.{self.__class__.__name__}.Help'>\"\n+        )\n", "problem_statement": "enhance readability of assertion introspection on bound methods\nOriginally reported by: **Ronny Pfannschmidt (BitBucket: [RonnyPfannschmidt](http://bitbucket.org/RonnyPfannschmidt), GitHub: [RonnyPfannschmidt](http://github.com/RonnyPfannschmidt))**\n\n---\n\ngiven\n\n```\n#!python\n\nclass Help:\n    def fun(self):\n        return 1\n\ndef test():\n    assert Help().fun() == 2\n\n```\n\nresult\n\n```\n#!text\n\n=================================== FAILURES ===================================\n_____________________________________ test _____________________________________\n\n    def test():\n>       assert Help().fun() == 2\nE       assert 1 == 2\nE        +  where 1 = <bound method Help.fun of <example.Help instance at 0x256a830>>()\nE        +    where <bound method Help.fun of <example.Help instance at 0x256a830>> = <example.Help instance at 0x256a830>.fun\nE        +      where <example.Help instance at 0x256a830> = Help()\n\nexample.py:7: AssertionError\n=========================== 1 failed in 0.03 seconds ===========================\n\n```\n\ndesired:\n\n```\n#!text\n\n=================================== FAILURES ===================================\n_____________________________________ test _____________________________________\n\n    def test():\n>       assert Help().fun() == 2\nE       assert 1 == 2\nE        +  where 1 = Help().fun()\n\nexample.py:7: AssertionError\n=========================== 1 failed in 0.03 seconds ===========================\n\n```\n\nmore complex examples need a discussion\n\n---\n- Bitbucket: https://bitbucket.org/pytest-dev/pytest/issue/389\n\n", "hints_text": "I'd like to see this feature as well\n\nThis would help a lot with readability in many cases. I tried to see if I could do something about this, and it seems like the fix would be somewhere in src/_pytest/assertion/util.py since that's where the exception message is generated and where all the special cases for various types are. I guess in this case we want to swap the repr for something else, but I couldn't any existing examples where that is done. Any pointers?\ni started to work on this a little while ago, but got stalled as its required to change the structure of assertion rewriting\r\ni have no good pointer at the moment cause i havent investigate a structure of the rewrite which enables this\r\n\r\n", "created_at": "2024-06-19T20:46:13Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12491, "instance_id": "pytest-dev__pytest-12491", "issue_numbers": ["7662"], "base_commit": "237152552e1782bcfcae402e1540f12348ef9f0e", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 5ae80eb02d..ad7fccf6d5 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -213,6 +213,7 @@ Jordan Guymon\n Jordan Moldow\n Jordan Speicher\n Joseph Hunkeler\n+Joseph Sawaya\n Josh Karpel\n Joshua Bronson\n Jurko Gospodneti\u0107\ndiff --git a/changelog/7662.improvement.rst b/changelog/7662.improvement.rst\nnew file mode 100644\nindex 0000000000..b6ae1ba7e4\n--- /dev/null\n+++ b/changelog/7662.improvement.rst\n@@ -0,0 +1,1 @@\n+Added timezone information to the testsuite timestamp in the JUnit XML report.\n", "test_patch": "diff --git a/src/_pytest/junitxml.py b/src/_pytest/junitxml.py\nindex a525f1d14d..3a2cb59a6c 100644\n--- a/src/_pytest/junitxml.py\n+++ b/src/_pytest/junitxml.py\n@@ -11,6 +11,7 @@\n from __future__ import annotations\n \n from datetime import datetime\n+from datetime import timezone\n import functools\n import os\n import platform\n@@ -664,7 +665,9 @@ def pytest_sessionfinish(self) -> None:\n                 skipped=str(self.stats[\"skipped\"]),\n                 tests=str(numtests),\n                 time=f\"{suite_time_delta:.3f}\",\n-                timestamp=datetime.fromtimestamp(self.suite_start_time).isoformat(),\n+                timestamp=datetime.fromtimestamp(self.suite_start_time, timezone.utc)\n+                .astimezone()\n+                .isoformat(),\n                 hostname=platform.node(),\n             )\n             global_properties = self._get_global_properties_node()\ndiff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 67234302a8..fd1fecb54f 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -2,6 +2,7 @@\n from __future__ import annotations\n \n from datetime import datetime\n+from datetime import timezone\n import os\n from pathlib import Path\n import platform\n@@ -218,11 +219,11 @@ def test_pass():\n                 pass\n         \"\"\"\n         )\n-        start_time = datetime.now()\n+        start_time = datetime.now(timezone.utc)\n         result, dom = run_and_parse(family=xunit_family)\n         node = dom.find_first_by_tag(\"testsuite\")\n-        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n-        assert start_time <= timestamp < datetime.now()\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f%z\")\n+        assert start_time <= timestamp < datetime.now(timezone.utc)\n \n     def test_timing_function(\n         self, pytester: Pytester, run_and_parse: RunAndParse, mock_timing\n", "problem_statement": "Timestamp in Pytest JUnit XML test report doesn't have time zone infomation\n- [x] a detailed description of the bug or suggestion\r\nLast year,  pytest add <timestamp> attribute to the JUnit test report.   In the test report I can see the timestamp like \r\n`timestamp=\"2020-08-17T10:14:39.548365\"`\r\n\r\nIt looks like pytest just takes the system time from OS, and save it to test report.  \r\nUnfortunately,  this timestamp doesn't have any timezone infomation,  Our CI system will treat this timestamp as a UTC time, even the timestamp is actually from another time zone.  \r\n\r\n- [x] pytest and operating system versions\r\npytest 5.2.1,  I have seen the issue in both Linux and Windows\r\n\r\nIs it possible to add timezone information to the timestamp attribute,  or always use UTC time in timestamp?  \r\n\n", "hints_text": "I think it would be appropriate to always use UTC, and to include the timezone (i.e. utc) in the xml file.\r\n\r\nhttps://blog.ganssle.io/articles/2019/11/utcnow.html has some good advice on the topic.\nLocal time with zone and UTC offset is probably the most useful. It's just\nwhether or not JUnit supports it\n\nOn Thu, Aug 20, 2020, 04:47 Zac Hatfield-Dodds <notifications@github.com>\nwrote:\n\n> I think it would be appropriate to always use UTC, and to include the\n> timezone (i.e. utc) in the xml file.\n>\n> https://blog.ganssle.io/articles/2019/11/utcnow.html has some good advice\n> on the topic.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pytest-dev/pytest/issues/7662#issuecomment-676967717>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AADFATBT6G6QX525WZJ4KJDSBSMD3ANCNFSM4QFCZVNA>\n> .\n>\n\nCurrently the `timestamp` attribute is defined only as a `xsd:string`:\r\n\r\nhttps://github.com/jenkinsci/xunit-plugin/blob/master/src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd#L123\r\n\r\n```\r\n<xs:attribute name=\"timestamp\" type=\"xs:string\" />\r\n```\r\n\r\nSo I think it is reasonable to write local time + UTC offset as @graingert mentioned.\r\n\n@jinxudb would you like to give that a try? Should be a simple patch (change that line + test + a changelog).\nhttps://github.com/junit-team/junit5/issues/373 looks like it's sort of implementation defined, so would be a good idea to test it on a real Jenkins box\n@nicoddemus https://github.com/junit-team/junit5/blob/58bb81bfee73c5154b0a223ba68f7677bb98376d/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java#L119\nThanks @graingert. \ud83d\udc4d \r\n\r\nFrom the docs at https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html, that format does not include the time zone, but of course it doesn't mean that a Jenkins box cannot read time zone information if it is present.\r\n\r\nCan anybody with access to a Jenkins box test this?\n@nicoddemus we should also make sure that we store the timestamp of when the test started, not finished. This way a consumer can determine the end time of a test from `testsuite.timestamp + dt.timedelta(seconds=testsuite.time)`\n@nicoddemus I think we should only land this if Junit5 also lands the same change\ngetTimestamp is an undocumented String getter: https://javadoc.jenkins.io/plugin/junit/hudson/tasks/junit/SuiteResult.html#getTimestamp--\n> @nicoddemus we should also make sure that we store the timestamp of when the test started, not finished.\r\n\r\nI'm not sure how it is currently, but I would not change the current behavior.\r\n\r\n> @nicoddemus I think we should only land this if Junit5 also lands the same change\r\n\r\nHmmm sorry, what's junit5?\r\n\r\n> getTimestamp is an undocumented String getter: javadoc.jenkins.io/plugin/junit/hudson/tasks/junit/SuiteResult.html#getTimestamp--\r\n\r\nBummer. I guess someone can try that in a Jenkins instance and see if it works.\r\n\r\n@jinxudb could you check if adding the time zone information to that timestamp works on Jenkins? \r\n\r\nYou can do that by post-processing the generated XML file to include the time zone information using a custom script, just to check how Jenkins behaves. If it works we will feel safer to include that change into pytest.\n> > @nicoddemus I think we should only land this if Junit5 also lands the same change\r\n> \r\n> Hmmm sorry, what's junit5?\r\n> \r\n\r\nhttps://github.com/junit-team/junit5/pull/2388\r\n\r\nIt appears that \"junit\" xml is implementation defined by whatever junit5 emits and Jenkins consumes\r\n\ndo we need to make the same change for xunit2?\nfurther research I find: https://github.com/karma-runner/karma-junit-reporter/issues/98\r\n\r\nhttps://github.com/karma-runner/karma-junit-reporter/blob/master/junit-schema.xsd#L15\nalso Junit5 outputs timezone in the [//testsuite/properties/property](https://github.com/karma-runner/karma-junit-reporter/blob/master/junit-schema.xsd#L56)\r\n\r\n`    <property name=\"user.timezone\" value=\"Europe/London\"/>`\nhttps://github.com/karma-runner/karma-junit-reporter/blob/2f43e5063e050b7853ebcc82c24ecc26310e0cff/junit-schema.xsd#L165-L169\r\n\r\n```xml\r\n\t\t<xs:attribute name=\"timestamp\" type=\"ISO8601_DATETIME_PATTERN\" use=\"required\">\r\n\t\t\t<xs:annotation>\r\n\t\t\t\t<xs:documentation xml:lang=\"en\">when the test was executed. Timezone may not be specified.</xs:documentation>\r\n\t\t\t</xs:annotation>\r\n\t\t</xs:attribute>\r\n```\r\n\r\nYou could read this as \"Timezone *may* not be specified.\" or \"Timezone *may not* be specified.\"\nAny update on this issue? I think that having some timezone information in the timestamp makes sense.\r\n\r\nIt looks like the JUnit plugin for Jenkins does support datetimes with timezone information as shown in [this sample file](https://github.com/jenkinsci/junit-plugin/blob/63bd1315bfcddb63bf670270b31cf67ac4c09076/src/test/resources/hudson/tasks/junit/junit-report-testsuite-various-timestamps.xml#L2) that's a part of their tests. This [test](https://github.com/jenkinsci/junit-plugin/blob/63bd1315bfcddb63bf670270b31cf67ac4c09076/src/test/java/hudson/tasks/junit/TestResultTest.java#L331) here shows that the suites included in the sample junit xml file should be parsed correctly. \r\n\r\nSo I think as long as the timestamp generated by the junitxml plugin matches one of the valid ones shown in the sample file then it should be compatible with Jenkins.", "created_at": "2024-06-19T19:13:08Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12436, "instance_id": "pytest-dev__pytest-12436", "issue_numbers": ["12424"], "base_commit": "8585c5882624662916a71e87258fbdaaba967569", "patch": "diff --git a/changelog/12424.bugfix.rst b/changelog/12424.bugfix.rst\nnew file mode 100644\nindex 0000000000..7ad1126858\n--- /dev/null\n+++ b/changelog/12424.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix crash with `assert testcase is not None` assertion failure when re-running unittest tests using plugins like pytest-rerunfailures. Regressed in 8.2.2.\ndiff --git a/tox.ini b/tox.ini\nindex 0a3f0acf5b..35b335a015 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -141,7 +141,7 @@ commands =\n     pytest --cov=. simple_integration.py\n     pytest --ds=django_settings simple_integration.py\n     pytest --html=simple.html simple_integration.py\n-    pytest --reruns 5 simple_integration.py\n+    pytest --reruns 5 simple_integration.py pytest_rerunfailures_integration.py\n     pytest pytest_anyio_integration.py\n     pytest pytest_asyncio_integration.py\n     pytest pytest_mock_integration.py\n", "test_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 643443f08c..ca82ac5c14 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -222,7 +222,7 @@ def teardown(self) -> None:\n             self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._obj = None\n-        self._instance = None\n+        del self._instance\n         super().teardown()\n \n     def startTest(self, testcase: \"unittest.TestCase\") -> None:\ndiff --git a/testing/plugins_integration/pytest_rerunfailures_integration.py b/testing/plugins_integration/pytest_rerunfailures_integration.py\nnew file mode 100644\nindex 0000000000..9a13a3279a\n--- /dev/null\n+++ b/testing/plugins_integration/pytest_rerunfailures_integration.py\n@@ -0,0 +1,11 @@\n+import unittest\n+\n+\n+class MyTestCase(unittest.TestCase):\n+    first_time = True\n+\n+    def test_fail_the_first_time(self) -> None:\n+        \"\"\"Regression test for issue #12424.\"\"\"\n+        if self.first_time:\n+            type(self).first_time = False\n+            self.fail()\n", "problem_statement": "pytest 8.2.2 breaks pytest-rerunfailures for tests that inherit unittest.TestCase\n## pytest 8.2.2 breaks pytest-rerunfailures for tests that inherit unittest.TestCase\r\n\r\nThe code: (placed in `new_file.py`)\r\n\r\n```python\r\nfrom unittest import TestCase\r\n\r\nclass MyTestClass(TestCase):\r\n    def test_base(self):\r\n        self.fail()\r\n```\r\n\r\nRun command:\r\n\r\n```bash\r\npytest new_file.py --reruns=1\r\n```\r\n\r\nExpected output: (Using `pytest==8.2.1` / previous version)\r\n\r\n```\r\nself = <examples.new_file.MyTestClass testMethod=test_base>\r\n\r\n    def test_base(self):\r\n>       self.fail()\r\nE       AssertionError: None\r\n\r\nnew_file.py:5: AssertionError\r\n```\r\n\r\nRegression output: (Using `pytest==8.2.2` / latest version)\r\n\r\n```\r\nself = <TestCaseFunction test_base>\r\n\r\n    def runtest(self) -> None:\r\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\r\n    \r\n        testcase = self.instance\r\n>       assert testcase is not None\r\nE       AssertionError\r\n```\r\n\r\nThe error occurs during the `rerun` of the test.\r\n\r\nThe failure line should be `self.fail()`. Instead, it's `assert testcase is not None`.\r\n<b>This causes the `rerun` to never happen. (The test only ran the first time)</b>\r\n\r\nTested on a Mac. Here's the `pip list`:\r\n\r\n```bash\r\nPackage              Version\r\n-------------------- -------\r\niniconfig            2.0.0\r\npackaging            24.0\r\npip                  24.0\r\npluggy               1.5.0\r\npytest               8.2.2\r\npytest-rerunfailures 14.0\r\n```\n", "hints_text": "Thank you for filing this with succinct replication steps. I spent hours yesterday trying to figure out why our CI/CD was failing\nWe can probably accommodate rerunfailures here. I will take a look.\nI think switching pytest_runtest_makereport to the \"new style\" hook will make the issue go away\r\n\r\nBEFORE\r\n```python\r\n@pytest.hookimpl(hookwrapper=True)\r\ndef pytest_runtest_makereport(item, call):\r\n    outcome = yield\r\n    result = outcome.get_result()\r\n    if result.when == \"setup\":\r\n        # clean failed statuses at the beginning of each test/rerun\r\n        setattr(item, \"_test_failed_statuses\", {})\r\n\r\n        # create a dict to store error-check results for each stage\r\n        setattr(item, \"_terminal_errors\", {})\r\n\r\n    _test_failed_statuses = getattr(item, \"_test_failed_statuses\", {})\r\n    _test_failed_statuses[result.when] = result.failed\r\n    item._test_failed_statuses = _test_failed_statuses\r\n\r\n    item._terminal_errors[result.when] = _should_hard_fail_on_error(item, result)\r\n```\r\n\r\nAFTER\r\n```python\r\n@pytest.hookimpl(wrapper=True)\r\ndef pytest_runtest_makereport(item, call):\r\n    result = yield\r\n    if result.when == \"setup\":\r\n        # clean failed statuses at the beginning of each test/rerun\r\n        setattr(item, \"_test_failed_statuses\", {})\r\n\r\n        # create a dict to store error-check results for each stage\r\n        setattr(item, \"_terminal_errors\", {})\r\n\r\n    _test_failed_statuses = getattr(item, \"_test_failed_statuses\", {})\r\n    _test_failed_statuses[result.when] = result.failed\r\n    item._test_failed_statuses = _test_failed_statuses\r\n\r\n    item._terminal_errors[result.when] = _should_hard_fail_on_error(item, result)\r\n    return result\r\n```", "created_at": "2024-06-07T07:11:05Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12414, "instance_id": "pytest-dev__pytest-12414", "issue_numbers": ["12355"], "base_commit": "b41d5a52bbb808780ab310456d71e5ce509fd402", "patch": "diff --git a/changelog/12355.bugfix.rst b/changelog/12355.bugfix.rst\nnew file mode 100644\nindex 00000000000..1ce43e60ebd\n--- /dev/null\n+++ b/changelog/12355.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix possible catastrophic performance slowdown on a certain parametrization pattern involving many higher-scoped parameters.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 7fd63f937c1..647328e3bea 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -23,6 +23,7 @@\n from typing import MutableMapping\n from typing import NoReturn\n from typing import Optional\n+from typing import OrderedDict\n from typing import overload\n from typing import Sequence\n from typing import Set\n@@ -75,8 +76,6 @@\n \n \n if TYPE_CHECKING:\n-    from typing import Deque\n-\n     from _pytest.main import Session\n     from _pytest.python import CallSpec2\n     from _pytest.python import Function\n@@ -207,16 +206,18 @@ def get_parametrized_fixture_keys(\n \n def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:\n     argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]] = {}\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, Deque[nodes.Item]]] = {}\n+    items_by_argkey: Dict[\n+        Scope, Dict[FixtureArgKey, OrderedDict[nodes.Item, None]]\n+    ] = {}\n     for scope in HIGH_SCOPES:\n         scoped_argkeys_cache = argkeys_cache[scope] = {}\n-        scoped_items_by_argkey = items_by_argkey[scope] = defaultdict(deque)\n+        scoped_items_by_argkey = items_by_argkey[scope] = defaultdict(OrderedDict)\n         for item in items:\n             keys = dict.fromkeys(get_parametrized_fixture_keys(item, scope), None)\n             if keys:\n                 scoped_argkeys_cache[item] = keys\n                 for key in keys:\n-                    scoped_items_by_argkey[key].append(item)\n+                    scoped_items_by_argkey[key][item] = None\n     items_dict = dict.fromkeys(items, None)\n     return list(\n         reorder_items_atscope(items_dict, argkeys_cache, items_by_argkey, Scope.Session)\n@@ -226,17 +227,19 @@ def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:\n def fix_cache_order(\n     item: nodes.Item,\n     argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]],\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, \"Deque[nodes.Item]\"]],\n+    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, OrderedDict[nodes.Item, None]]],\n ) -> None:\n     for scope in HIGH_SCOPES:\n+        scoped_items_by_argkey = items_by_argkey[scope]\n         for key in argkeys_cache[scope].get(item, []):\n-            items_by_argkey[scope][key].appendleft(item)\n+            scoped_items_by_argkey[key][item] = None\n+            scoped_items_by_argkey[key].move_to_end(item, last=False)\n \n \n def reorder_items_atscope(\n     items: Dict[nodes.Item, None],\n     argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]],\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, \"Deque[nodes.Item]\"]],\n+    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, OrderedDict[nodes.Item, None]]],\n     scope: Scope,\n ) -> Dict[nodes.Item, None]:\n     if scope is Scope.Function or len(items) < 3:\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 741cf7dcf42..ebdf451e40b 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -2219,6 +2219,25 @@ def test_check():\n         reprec = pytester.inline_run(\"-s\")\n         reprec.assertoutcome(passed=2)\n \n+    def test_reordering_catastrophic_performance(self, pytester: Pytester) -> None:\n+        \"\"\"Check that a certain high-scope parametrization pattern doesn't cause\n+        a catasrophic slowdown.\n+\n+        Regression test for #12355.\n+        \"\"\"\n+        pytester.makepyfile(\"\"\"\n+            import pytest\n+\n+            params = tuple(\"abcdefghijklmnopqrstuvwxyz\")\n+            @pytest.mark.parametrize(params, [range(len(params))] * 3, scope=\"module\")\n+            def test_parametrize(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):\n+                pass\n+        \"\"\")\n+\n+        result = pytester.runpytest()\n+\n+        result.assert_outcomes(passed=3)\n+\n \n class TestFixtureMarker:\n     def test_parametrize(self, pytester: Pytester) -> None:\n", "problem_statement": "\"Collecting\" hangs forever if mark.parametrize is used with scope session or module \n- [x] a detailed description of the bug or problem you are having\r\n\r\nIf you parametrize a test function with several parameters with `@mark.parametrize` and set scope to \"session\" or \"module\" the collection step will take forever*. Debugging shows that `_pytest/fixtures.py:fix_cache_order()` is called repeatedly:\r\n```\r\n__hash__ (/usr/lib/python3.11/enum.py:1230)\r\nfix_cache_order (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:233)\r\nreorder_items_atscope (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:269)\r\nreorder_items (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:222)\r\npytest_collection_modifyitems (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:1617)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nperform_collect (.venv/lib/python3.11/site-packages/_pytest/main.py:814)\r\npytest_collection (.venv/lib/python3.11/site-packages/_pytest/main.py:349)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\n_main (.venv/lib/python3.11/site-packages/_pytest/main.py:338)\r\nwrap_session (.venv/lib/python3.11/site-packages/_pytest/main.py:285)\r\npytest_cmdline_main (.venv/lib/python3.11/site-packages/_pytest/main.py:332)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nmain (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:178)\r\nconsole_main (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:206)\r\n<module> (.venv/lib/python3.11/site-packages/pytest/__main__.py:7)\r\n_run_code (/usr/lib/python3.11/runpy.py:88)\r\n_run_module_as_main (/usr/lib/python3.11/runpy.py:198)\r\n```\r\n\r\n*forever scales with the number of parameters.\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n```\r\nPackage                        Version   Editable project location\r\n------------------------------ --------- ------------------------------------\r\naenum                          3.1.15\r\naiohttp                        3.9.3\r\naiosignal                      1.3.1\r\nalabaster                      0.7.16\r\nastroid                        3.1.0\r\nattrs                          23.2.0\r\nBabel                          2.14.0\r\nbcrypt                         4.1.2\r\nbeautifulsoup4                 4.12.3\r\nblack                          23.12.1\r\nbuild                          1.2.1\r\nCacheControl                   0.14.0\r\ncertifi                        2024.2.2\r\ncffi                           1.16.0\r\ncfgv                           3.4.0\r\ncharset-normalizer             3.3.2\r\ncleo                           2.1.0\r\nclick                          8.1.7\r\nconstruct                      2.10.70\r\ncrashtest                      0.4.1\r\ncryptography                   42.0.5\r\ndill                           0.3.8\r\ndistlib                        0.3.8\r\ndocutils                       0.20.1\r\ndulwich                        0.21.7\r\nfastjsonschema                 2.19.1\r\nfilelock                       3.13.3\r\nfrozenlist                     1.4.1\r\nfuro                           2024.5.6\r\ngrpcio                         1.62.1\r\ngrpcio-tools                   1.62.1\r\nidentify                       2.5.35\r\nidna                           3.6\r\nimagesize                      1.4.1\r\nimportlib_metadata             7.1.0\r\niniconfig                      2.0.0\r\ninstaller                      0.7.0\r\nisort                          5.13.2\r\niterators                      0.2.0\r\njaraco.classes                 3.4.0\r\njeepney                        0.8.0\r\nJinja2                         3.1.3\r\nkeyring                        24.3.1\r\nMarkupSafe                     2.1.5\r\nmccabe                         0.7.0\r\nmore-itertools                 10.2.0\r\nmsgpack                        1.0.8\r\nmultidict                      6.0.5\r\nmypy-extensions                1.0.0\r\nnodeenv                        1.8.0\r\nnumpy                          1.26.4\r\nopencv-contrib-python-headless 4.9.0.80\r\npackaging                      24.0\r\nparamiko                       3.4.0\r\nparamiko-expect                0.3.5\r\npastel                         0.2.1\r\npathspec                       0.12.1\r\npexpect                        4.9.0\r\npip                            24.0\r\npkginfo                        1.10.0\r\nplatformdirs                   4.2.0\r\npluggy                         1.5.0\r\npoethepoet                     0.25.1\r\npoetry                         1.8.3\r\npoetry-core                    1.9.0\r\npoetry-plugin-export           1.8.0\r\npooch                          1.8.1\r\npre-commit                     3.7.0\r\nprotobuf                       4.25.3\r\nptyprocess                     0.7.0\r\npycparser                      2.22\r\npydocstyle                     6.3.0\r\nPygments                       2.17.2\r\npylint                         3.1.0\r\nPyNaCl                         1.5.0\r\npyproject_hooks                1.1.0\r\npyright                        1.1.362\r\npytest                         8.2.1\r\npytest-reportportal            5.4.1\r\nPyYAML                         6.0.1\r\nrapidfuzz                      3.9.1\r\nreportportal-client            5.5.6\r\nrequests                       2.31.0\r\nrequests-toolbelt              1.0.0\r\nrstr                           3.2.2\r\nSecretStorage                  3.3.3\r\nsetuptools                     69.2.0\r\nshellingham                    1.5.4\r\nsnowballstemmer                2.2.0\r\nsoupsieve                      2.5\r\nSphinx                         7.3.7\r\nsphinx-basic-ng                1.0.0b2\r\nsphinx-rtd-theme               2.0.0\r\nsphinxcontrib-applehelp        1.0.8\r\nsphinxcontrib-devhelp          1.0.6\r\nsphinxcontrib-htmlhelp         2.0.5\r\nsphinxcontrib-jquery           4.1\r\nsphinxcontrib-jsmath           1.0.1\r\nsphinxcontrib-qthelp           1.0.7\r\nsphinxcontrib-serializinghtml  1.1.10\r\ntimecode                       1.4.0\r\ntomli                          2.0.1\r\ntomlkit                        0.12.4\r\ntrove-classifiers              2024.5.17\r\nurllib3                        2.2.1\r\nvirtualenv                     20.25.1\r\nyarl                           1.9.4\r\nzipp                           3.18.2\r\n```\r\n\r\n- [x] pytest and operating system versions\r\n\r\n    - Linux 03b812391caf 5.10.0-29-amd64 SMP Debian 5.10.216-1 (2024-05-03) x86_64 GNU/Linux\r\n    -  Python 3.11.2\r\n    - pytest  8.2.1\r\n    - pytest 7.4.0\r\n    \r\n- [x] minimal example if possible\r\n\r\nThe issue is reproducible with pytest 7.4.0 and 8.2.1 with the following minimal example.\r\n```python\r\nfrom pytest import mark\r\n\r\nparams = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\r\n\r\n@mark.parametrize(argnames=params, argvalues=[range(len(params))] * 3, scope=\"module\")\r\ndef test_parametrize(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):\r\n    pass\r\n```\r\n\n", "hints_text": "Thanks for the report.\r\n\r\nBy gradually increasing the number of parameters, this looks like an [\"accidentally quadratic\"](https://accidentallyquadratic.tumblr.com/) (or worse...) situation.\r\n\r\nA (not so...) quick profile run puts the blame on [`_pytest/fixtures.py:238(reorder_items_atscope)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L238-L281) which calls [`_pytest/fixtures.py:228(fix_cache_order)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L228-L235).\r\n\r\n<details><summary>Profile output</summary>\r\n<p>\r\n\r\n```\r\n         225490710 function calls (225482776 primitive calls) in 79.889 seconds\r\n\r\n   Ordered by: cumulative time\r\n   List reduced from 3530 to 30 due to restriction <30>\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n    501/1    0.022    0.000   79.891   79.891 {built-in method builtins.exec}\r\n        1    0.000    0.000   79.891   79.891 <string>:1(<module>)\r\n        1    0.000    0.000   79.891   79.891 <frozen runpy>:201(run_module)\r\n        1    0.000    0.000   79.703   79.703 <frozen runpy>:65(_run_code)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/pytest/__main__.py:1(<module>)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:199(console_main)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:142(main)\r\n   475/71    0.001    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_manager.py:111(_hookexec)\r\n   475/71    0.004    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_callers.py:53(_multicall)\r\n    291/2    0.001    0.000   79.670   39.835 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_hooks.py:498(__call__)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:331(pytest_cmdline_main)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:272(wrap_session)\r\n        1    0.000    0.000   79.219   79.219 pytest/src/_pytest/main.py:335(_main)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:348(pytest_collection)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:746(perform_collect)\r\n        1    0.139    0.139   79.165   79.165 pytest/src/_pytest/fixtures.py:1617(pytest_collection_modifyitems)\r\n        1    0.000    0.000   79.025   79.025 pytest/src/_pytest/fixtures.py:210(reorder_items)\r\n      6/1    2.334    0.389   79.025   79.025 pytest/src/_pytest/fixtures.py:238(reorder_items_atscope)\r\n  1572861   27.109    0.000   74.492    0.000 pytest/src/_pytest/fixtures.py:228(fix_cache_order)\r\n 29886354    8.917    0.000   23.305    0.000 <string>:2(__hash__)\r\n77074144/77073790   17.417    0.000   20.581    0.000 {built-in method builtins.hash}\r\n 36175863    8.681    0.000   13.444    0.000 /usr/lib/python3.12/enum.py:1267(__hash__)\r\n 31457220    5.894    0.000    5.894    0.000 {method 'appendleft' of 'collections.deque' objects}\r\n  6298142    2.611    0.000    5.103    0.000 {method 'get' of 'dict' objects}\r\n 11010191    2.636    0.000    4.066    0.000 pytest/src/_pytest/nodes.py:289(__hash__)\r\n 29886863    3.164    0.000    3.166    0.000 /usr/lib/python3.12/pathlib.py:524(__hash__)\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nI don't have time to look into it right now and will look at it later, but this looks like a fun issue if someone else would like to try to figure it out. There are probably some python-level optimizations which could bring down the processing time, and algorithmic-level optimizations which could eliminate it entirely. Both are welcome.", "created_at": "2024-06-04T07:36:59Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12409, "instance_id": "pytest-dev__pytest-12409", "issue_numbers": ["12355", "12355"], "base_commit": "3433c7adf52a79592438d7af0637ae905657ee56", "patch": "diff --git a/changelog/12355.bugfix.rst b/changelog/12355.bugfix.rst\nnew file mode 100644\nindex 00000000000..1ce43e60ebd\n--- /dev/null\n+++ b/changelog/12355.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix possible catastrophic performance slowdown on a certain parametrization pattern involving many higher-scoped parameters.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex b7a58081ba8..353082c17e1 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -21,9 +21,11 @@\n from typing import Iterable\n from typing import Iterator\n from typing import List\n+from typing import Mapping\n from typing import MutableMapping\n from typing import NoReturn\n from typing import Optional\n+from typing import OrderedDict\n from typing import overload\n from typing import Sequence\n from typing import Set\n@@ -76,8 +78,6 @@\n \n \n if TYPE_CHECKING:\n-    from typing import Deque\n-\n     from _pytest.main import Session\n     from _pytest.python import CallSpec2\n     from _pytest.python import Function\n@@ -161,6 +161,12 @@ def getfixturemarker(obj: object) -> Optional[\"FixtureFunctionMarker\"]:\n     )\n \n \n+# Algorithm for sorting on a per-parametrized resource setup basis.\n+# It is called for Session scope first and performs sorting\n+# down to the lower scopes such as to minimize number of \"high scope\"\n+# setups and teardowns.\n+\n+\n @dataclasses.dataclass(frozen=True)\n class FixtureArgKey:\n     argname: str\n@@ -169,97 +175,95 @@ class FixtureArgKey:\n     item_cls: Optional[type]\n \n \n-def get_parametrized_fixture_keys(\n+_V = TypeVar(\"_V\")\n+OrderedSet = Dict[_V, None]\n+\n+\n+def get_parametrized_fixture_argkeys(\n     item: nodes.Item, scope: Scope\n ) -> Iterator[FixtureArgKey]:\n     \"\"\"Return list of keys for all parametrized arguments which match\n     the specified scope.\"\"\"\n     assert scope is not Scope.Function\n+\n     try:\n         callspec: CallSpec2 = item.callspec  # type: ignore[attr-defined]\n     except AttributeError:\n         return\n+\n+    item_cls = None\n+    if scope is Scope.Session:\n+        scoped_item_path = None\n+    elif scope is Scope.Package:\n+        # Package key = module's directory.\n+        scoped_item_path = item.path.parent\n+    elif scope is Scope.Module:\n+        scoped_item_path = item.path\n+    elif scope is Scope.Class:\n+        scoped_item_path = item.path\n+        item_cls = item.cls  # type: ignore[attr-defined]\n+    else:\n+        assert_never(scope)\n+\n     for argname in callspec.indices:\n         if callspec._arg2scope[argname] != scope:\n             continue\n-\n-        item_cls = None\n-        if scope is Scope.Session:\n-            scoped_item_path = None\n-        elif scope is Scope.Package:\n-            # Package key = module's directory.\n-            scoped_item_path = item.path.parent\n-        elif scope is Scope.Module:\n-            scoped_item_path = item.path\n-        elif scope is Scope.Class:\n-            scoped_item_path = item.path\n-            item_cls = item.cls  # type: ignore[attr-defined]\n-        else:\n-            assert_never(scope)\n-\n         param_index = callspec.indices[argname]\n         yield FixtureArgKey(argname, param_index, scoped_item_path, item_cls)\n \n \n-# Algorithm for sorting on a per-parametrized resource setup basis.\n-# It is called for Session scope first and performs sorting\n-# down to the lower scopes such as to minimize number of \"high scope\"\n-# setups and teardowns.\n-\n-\n def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:\n-    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]] = {}\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, Deque[nodes.Item]]] = {}\n+    argkeys_by_item: Dict[Scope, Dict[nodes.Item, OrderedSet[FixtureArgKey]]] = {}\n+    items_by_argkey: Dict[\n+        Scope, Dict[FixtureArgKey, OrderedDict[nodes.Item, None]]\n+    ] = {}\n     for scope in HIGH_SCOPES:\n-        scoped_argkeys_cache = argkeys_cache[scope] = {}\n-        scoped_items_by_argkey = items_by_argkey[scope] = defaultdict(deque)\n+        scoped_argkeys_by_item = argkeys_by_item[scope] = {}\n+        scoped_items_by_argkey = items_by_argkey[scope] = defaultdict(OrderedDict)\n         for item in items:\n-            keys = dict.fromkeys(get_parametrized_fixture_keys(item, scope), None)\n-            if keys:\n-                scoped_argkeys_cache[item] = keys\n-                for key in keys:\n-                    scoped_items_by_argkey[key].append(item)\n-    items_dict = dict.fromkeys(items, None)\n+            argkeys = dict.fromkeys(get_parametrized_fixture_argkeys(item, scope))\n+            if argkeys:\n+                scoped_argkeys_by_item[item] = argkeys\n+                for argkey in argkeys:\n+                    scoped_items_by_argkey[argkey][item] = None\n+\n+    items_set = dict.fromkeys(items)\n     return list(\n-        reorder_items_atscope(items_dict, argkeys_cache, items_by_argkey, Scope.Session)\n+        reorder_items_atscope(\n+            items_set, argkeys_by_item, items_by_argkey, Scope.Session\n+        )\n     )\n \n \n-def fix_cache_order(\n-    item: nodes.Item,\n-    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]],\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, \"Deque[nodes.Item]\"]],\n-) -> None:\n-    for scope in HIGH_SCOPES:\n-        for key in argkeys_cache[scope].get(item, []):\n-            items_by_argkey[scope][key].appendleft(item)\n-\n-\n def reorder_items_atscope(\n-    items: Dict[nodes.Item, None],\n-    argkeys_cache: Dict[Scope, Dict[nodes.Item, Dict[FixtureArgKey, None]]],\n-    items_by_argkey: Dict[Scope, Dict[FixtureArgKey, \"Deque[nodes.Item]\"]],\n+    items: OrderedSet[nodes.Item],\n+    argkeys_by_item: Mapping[Scope, Mapping[nodes.Item, OrderedSet[FixtureArgKey]]],\n+    items_by_argkey: Mapping[\n+        Scope, Mapping[FixtureArgKey, OrderedDict[nodes.Item, None]]\n+    ],\n     scope: Scope,\n-) -> Dict[nodes.Item, None]:\n+) -> OrderedSet[nodes.Item]:\n     if scope is Scope.Function or len(items) < 3:\n         return items\n-    ignore: Set[Optional[FixtureArgKey]] = set()\n-    items_deque = deque(items)\n-    items_done: Dict[nodes.Item, None] = {}\n+\n     scoped_items_by_argkey = items_by_argkey[scope]\n-    scoped_argkeys_cache = argkeys_cache[scope]\n+    scoped_argkeys_by_item = argkeys_by_item[scope]\n+\n+    ignore: Set[FixtureArgKey] = set()\n+    items_deque = deque(items)\n+    items_done: OrderedSet[nodes.Item] = {}\n     while items_deque:\n-        no_argkey_group: Dict[nodes.Item, None] = {}\n+        no_argkey_items: OrderedSet[nodes.Item] = {}\n         slicing_argkey = None\n         while items_deque:\n             item = items_deque.popleft()\n-            if item in items_done or item in no_argkey_group:\n+            if item in items_done or item in no_argkey_items:\n                 continue\n             argkeys = dict.fromkeys(\n-                (k for k in scoped_argkeys_cache.get(item, []) if k not in ignore), None\n+                k for k in scoped_argkeys_by_item.get(item, ()) if k not in ignore\n             )\n             if not argkeys:\n-                no_argkey_group[item] = None\n+                no_argkey_items[item] = None\n             else:\n                 slicing_argkey, _ = argkeys.popitem()\n                 # We don't have to remove relevant items from later in the\n@@ -268,16 +272,23 @@ def reorder_items_atscope(\n                     i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                 ]\n                 for i in reversed(matching_items):\n-                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                     items_deque.appendleft(i)\n+                    # Fix items_by_argkey order.\n+                    for other_scope in HIGH_SCOPES:\n+                        other_scoped_items_by_argkey = items_by_argkey[other_scope]\n+                        for argkey in argkeys_by_item[other_scope].get(i, ()):\n+                            other_scoped_items_by_argkey[argkey][i] = None\n+                            other_scoped_items_by_argkey[argkey].move_to_end(\n+                                i, last=False\n+                            )\n                 break\n-        if no_argkey_group:\n-            no_argkey_group = reorder_items_atscope(\n-                no_argkey_group, argkeys_cache, items_by_argkey, scope.next_lower()\n+        if no_argkey_items:\n+            reordered_no_argkey_items = reorder_items_atscope(\n+                no_argkey_items, argkeys_by_item, items_by_argkey, scope.next_lower()\n             )\n-            for item in no_argkey_group:\n-                items_done[item] = None\n-        ignore.add(slicing_argkey)\n+            items_done.update(reordered_no_argkey_items)\n+        if slicing_argkey is not None:\n+            ignore.add(slicing_argkey)\n     return items_done\n \n \ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex d54bcc4d4eb..d3cff38f977 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -2219,6 +2219,25 @@ def test_check():\n         reprec = pytester.inline_run(\"-s\")\n         reprec.assertoutcome(passed=2)\n \n+    def test_reordering_catastrophic_performance(self, pytester: Pytester) -> None:\n+        \"\"\"Check that a certain high-scope parametrization pattern doesn't cause\n+        a catasrophic slowdown.\n+\n+        Regression test for #12355.\n+        \"\"\"\n+        pytester.makepyfile(\"\"\"\n+            import pytest\n+\n+            params = tuple(\"abcdefghijklmnopqrstuvwxyz\")\n+            @pytest.mark.parametrize(params, [range(len(params))] * 3, scope=\"module\")\n+            def test_parametrize(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):\n+                pass\n+        \"\"\")\n+\n+        result = pytester.runpytest()\n+\n+        result.assert_outcomes(passed=3)\n+\n \n class TestFixtureMarker:\n     def test_parametrize(self, pytester: Pytester) -> None:\n", "problem_statement": "\"Collecting\" hangs forever if mark.parametrize is used with scope session or module \n- [x] a detailed description of the bug or problem you are having\r\n\r\nIf you parametrize a test function with several parameters with `@mark.parametrize` and set scope to \"session\" or \"module\" the collection step will take forever*. Debugging shows that `_pytest/fixtures.py:fix_cache_order()` is called repeatedly:\r\n```\r\n__hash__ (/usr/lib/python3.11/enum.py:1230)\r\nfix_cache_order (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:233)\r\nreorder_items_atscope (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:269)\r\nreorder_items (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:222)\r\npytest_collection_modifyitems (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:1617)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nperform_collect (.venv/lib/python3.11/site-packages/_pytest/main.py:814)\r\npytest_collection (.venv/lib/python3.11/site-packages/_pytest/main.py:349)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\n_main (.venv/lib/python3.11/site-packages/_pytest/main.py:338)\r\nwrap_session (.venv/lib/python3.11/site-packages/_pytest/main.py:285)\r\npytest_cmdline_main (.venv/lib/python3.11/site-packages/_pytest/main.py:332)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nmain (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:178)\r\nconsole_main (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:206)\r\n<module> (.venv/lib/python3.11/site-packages/pytest/__main__.py:7)\r\n_run_code (/usr/lib/python3.11/runpy.py:88)\r\n_run_module_as_main (/usr/lib/python3.11/runpy.py:198)\r\n```\r\n\r\n*forever scales with the number of parameters.\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n```\r\nPackage                        Version   Editable project location\r\n------------------------------ --------- ------------------------------------\r\naenum                          3.1.15\r\naiohttp                        3.9.3\r\naiosignal                      1.3.1\r\nalabaster                      0.7.16\r\nastroid                        3.1.0\r\nattrs                          23.2.0\r\nBabel                          2.14.0\r\nbcrypt                         4.1.2\r\nbeautifulsoup4                 4.12.3\r\nblack                          23.12.1\r\nbuild                          1.2.1\r\nCacheControl                   0.14.0\r\ncertifi                        2024.2.2\r\ncffi                           1.16.0\r\ncfgv                           3.4.0\r\ncharset-normalizer             3.3.2\r\ncleo                           2.1.0\r\nclick                          8.1.7\r\nconstruct                      2.10.70\r\ncrashtest                      0.4.1\r\ncryptography                   42.0.5\r\ndill                           0.3.8\r\ndistlib                        0.3.8\r\ndocutils                       0.20.1\r\ndulwich                        0.21.7\r\nfastjsonschema                 2.19.1\r\nfilelock                       3.13.3\r\nfrozenlist                     1.4.1\r\nfuro                           2024.5.6\r\ngrpcio                         1.62.1\r\ngrpcio-tools                   1.62.1\r\nidentify                       2.5.35\r\nidna                           3.6\r\nimagesize                      1.4.1\r\nimportlib_metadata             7.1.0\r\niniconfig                      2.0.0\r\ninstaller                      0.7.0\r\nisort                          5.13.2\r\niterators                      0.2.0\r\njaraco.classes                 3.4.0\r\njeepney                        0.8.0\r\nJinja2                         3.1.3\r\nkeyring                        24.3.1\r\nMarkupSafe                     2.1.5\r\nmccabe                         0.7.0\r\nmore-itertools                 10.2.0\r\nmsgpack                        1.0.8\r\nmultidict                      6.0.5\r\nmypy-extensions                1.0.0\r\nnodeenv                        1.8.0\r\nnumpy                          1.26.4\r\nopencv-contrib-python-headless 4.9.0.80\r\npackaging                      24.0\r\nparamiko                       3.4.0\r\nparamiko-expect                0.3.5\r\npastel                         0.2.1\r\npathspec                       0.12.1\r\npexpect                        4.9.0\r\npip                            24.0\r\npkginfo                        1.10.0\r\nplatformdirs                   4.2.0\r\npluggy                         1.5.0\r\npoethepoet                     0.25.1\r\npoetry                         1.8.3\r\npoetry-core                    1.9.0\r\npoetry-plugin-export           1.8.0\r\npooch                          1.8.1\r\npre-commit                     3.7.0\r\nprotobuf                       4.25.3\r\nptyprocess                     0.7.0\r\npycparser                      2.22\r\npydocstyle                     6.3.0\r\nPygments                       2.17.2\r\npylint                         3.1.0\r\nPyNaCl                         1.5.0\r\npyproject_hooks                1.1.0\r\npyright                        1.1.362\r\npytest                         8.2.1\r\npytest-reportportal            5.4.1\r\nPyYAML                         6.0.1\r\nrapidfuzz                      3.9.1\r\nreportportal-client            5.5.6\r\nrequests                       2.31.0\r\nrequests-toolbelt              1.0.0\r\nrstr                           3.2.2\r\nSecretStorage                  3.3.3\r\nsetuptools                     69.2.0\r\nshellingham                    1.5.4\r\nsnowballstemmer                2.2.0\r\nsoupsieve                      2.5\r\nSphinx                         7.3.7\r\nsphinx-basic-ng                1.0.0b2\r\nsphinx-rtd-theme               2.0.0\r\nsphinxcontrib-applehelp        1.0.8\r\nsphinxcontrib-devhelp          1.0.6\r\nsphinxcontrib-htmlhelp         2.0.5\r\nsphinxcontrib-jquery           4.1\r\nsphinxcontrib-jsmath           1.0.1\r\nsphinxcontrib-qthelp           1.0.7\r\nsphinxcontrib-serializinghtml  1.1.10\r\ntimecode                       1.4.0\r\ntomli                          2.0.1\r\ntomlkit                        0.12.4\r\ntrove-classifiers              2024.5.17\r\nurllib3                        2.2.1\r\nvirtualenv                     20.25.1\r\nyarl                           1.9.4\r\nzipp                           3.18.2\r\n```\r\n\r\n- [x] pytest and operating system versions\r\n\r\n    - Linux 03b812391caf 5.10.0-29-amd64 SMP Debian 5.10.216-1 (2024-05-03) x86_64 GNU/Linux\r\n    -  Python 3.11.2\r\n    - pytest  8.2.1\r\n    - pytest 7.4.0\r\n    \r\n- [x] minimal example if possible\r\n\r\nThe issue is reproducible with pytest 7.4.0 and 8.2.1 with the following minimal example.\r\n```python\r\nfrom pytest import mark\r\n\r\nparams = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\r\n\r\n@mark.parametrize(argnames=params, argvalues=[range(len(params))] * 3, scope=\"module\")\r\ndef test_parametrize(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):\r\n    pass\r\n```\r\n\n\"Collecting\" hangs forever if mark.parametrize is used with scope session or module \n- [x] a detailed description of the bug or problem you are having\r\n\r\nIf you parametrize a test function with several parameters with `@mark.parametrize` and set scope to \"session\" or \"module\" the collection step will take forever*. Debugging shows that `_pytest/fixtures.py:fix_cache_order()` is called repeatedly:\r\n```\r\n__hash__ (/usr/lib/python3.11/enum.py:1230)\r\nfix_cache_order (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:233)\r\nreorder_items_atscope (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:269)\r\nreorder_items (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:222)\r\npytest_collection_modifyitems (.venv/lib/python3.11/site-packages/_pytest/fixtures.py:1617)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nperform_collect (.venv/lib/python3.11/site-packages/_pytest/main.py:814)\r\npytest_collection (.venv/lib/python3.11/site-packages/_pytest/main.py:349)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\n_main (.venv/lib/python3.11/site-packages/_pytest/main.py:338)\r\nwrap_session (.venv/lib/python3.11/site-packages/_pytest/main.py:285)\r\npytest_cmdline_main (.venv/lib/python3.11/site-packages/_pytest/main.py:332)\r\n_multicall (.venv/lib/python3.11/site-packages/pluggy/_callers.py:103)\r\n_hookexec (.venv/lib/python3.11/site-packages/pluggy/_manager.py:120)\r\n__call__ (.venv/lib/python3.11/site-packages/pluggy/_hooks.py:513)\r\nmain (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:178)\r\nconsole_main (.venv/lib/python3.11/site-packages/_pytest/config/__init__.py:206)\r\n<module> (.venv/lib/python3.11/site-packages/pytest/__main__.py:7)\r\n_run_code (/usr/lib/python3.11/runpy.py:88)\r\n_run_module_as_main (/usr/lib/python3.11/runpy.py:198)\r\n```\r\n\r\n*forever scales with the number of parameters.\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n```\r\nPackage                        Version   Editable project location\r\n------------------------------ --------- ------------------------------------\r\naenum                          3.1.15\r\naiohttp                        3.9.3\r\naiosignal                      1.3.1\r\nalabaster                      0.7.16\r\nastroid                        3.1.0\r\nattrs                          23.2.0\r\nBabel                          2.14.0\r\nbcrypt                         4.1.2\r\nbeautifulsoup4                 4.12.3\r\nblack                          23.12.1\r\nbuild                          1.2.1\r\nCacheControl                   0.14.0\r\ncertifi                        2024.2.2\r\ncffi                           1.16.0\r\ncfgv                           3.4.0\r\ncharset-normalizer             3.3.2\r\ncleo                           2.1.0\r\nclick                          8.1.7\r\nconstruct                      2.10.70\r\ncrashtest                      0.4.1\r\ncryptography                   42.0.5\r\ndill                           0.3.8\r\ndistlib                        0.3.8\r\ndocutils                       0.20.1\r\ndulwich                        0.21.7\r\nfastjsonschema                 2.19.1\r\nfilelock                       3.13.3\r\nfrozenlist                     1.4.1\r\nfuro                           2024.5.6\r\ngrpcio                         1.62.1\r\ngrpcio-tools                   1.62.1\r\nidentify                       2.5.35\r\nidna                           3.6\r\nimagesize                      1.4.1\r\nimportlib_metadata             7.1.0\r\niniconfig                      2.0.0\r\ninstaller                      0.7.0\r\nisort                          5.13.2\r\niterators                      0.2.0\r\njaraco.classes                 3.4.0\r\njeepney                        0.8.0\r\nJinja2                         3.1.3\r\nkeyring                        24.3.1\r\nMarkupSafe                     2.1.5\r\nmccabe                         0.7.0\r\nmore-itertools                 10.2.0\r\nmsgpack                        1.0.8\r\nmultidict                      6.0.5\r\nmypy-extensions                1.0.0\r\nnodeenv                        1.8.0\r\nnumpy                          1.26.4\r\nopencv-contrib-python-headless 4.9.0.80\r\npackaging                      24.0\r\nparamiko                       3.4.0\r\nparamiko-expect                0.3.5\r\npastel                         0.2.1\r\npathspec                       0.12.1\r\npexpect                        4.9.0\r\npip                            24.0\r\npkginfo                        1.10.0\r\nplatformdirs                   4.2.0\r\npluggy                         1.5.0\r\npoethepoet                     0.25.1\r\npoetry                         1.8.3\r\npoetry-core                    1.9.0\r\npoetry-plugin-export           1.8.0\r\npooch                          1.8.1\r\npre-commit                     3.7.0\r\nprotobuf                       4.25.3\r\nptyprocess                     0.7.0\r\npycparser                      2.22\r\npydocstyle                     6.3.0\r\nPygments                       2.17.2\r\npylint                         3.1.0\r\nPyNaCl                         1.5.0\r\npyproject_hooks                1.1.0\r\npyright                        1.1.362\r\npytest                         8.2.1\r\npytest-reportportal            5.4.1\r\nPyYAML                         6.0.1\r\nrapidfuzz                      3.9.1\r\nreportportal-client            5.5.6\r\nrequests                       2.31.0\r\nrequests-toolbelt              1.0.0\r\nrstr                           3.2.2\r\nSecretStorage                  3.3.3\r\nsetuptools                     69.2.0\r\nshellingham                    1.5.4\r\nsnowballstemmer                2.2.0\r\nsoupsieve                      2.5\r\nSphinx                         7.3.7\r\nsphinx-basic-ng                1.0.0b2\r\nsphinx-rtd-theme               2.0.0\r\nsphinxcontrib-applehelp        1.0.8\r\nsphinxcontrib-devhelp          1.0.6\r\nsphinxcontrib-htmlhelp         2.0.5\r\nsphinxcontrib-jquery           4.1\r\nsphinxcontrib-jsmath           1.0.1\r\nsphinxcontrib-qthelp           1.0.7\r\nsphinxcontrib-serializinghtml  1.1.10\r\ntimecode                       1.4.0\r\ntomli                          2.0.1\r\ntomlkit                        0.12.4\r\ntrove-classifiers              2024.5.17\r\nurllib3                        2.2.1\r\nvirtualenv                     20.25.1\r\nyarl                           1.9.4\r\nzipp                           3.18.2\r\n```\r\n\r\n- [x] pytest and operating system versions\r\n\r\n    - Linux 03b812391caf 5.10.0-29-amd64 SMP Debian 5.10.216-1 (2024-05-03) x86_64 GNU/Linux\r\n    -  Python 3.11.2\r\n    - pytest  8.2.1\r\n    - pytest 7.4.0\r\n    \r\n- [x] minimal example if possible\r\n\r\nThe issue is reproducible with pytest 7.4.0 and 8.2.1 with the following minimal example.\r\n```python\r\nfrom pytest import mark\r\n\r\nparams = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\r\n\r\n@mark.parametrize(argnames=params, argvalues=[range(len(params))] * 3, scope=\"module\")\r\ndef test_parametrize(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z):\r\n    pass\r\n```\r\n\n", "hints_text": "Thanks for the report.\r\n\r\nBy gradually increasing the number of parameters, this looks like an [\"accidentally quadratic\"](https://accidentallyquadratic.tumblr.com/) (or worse...) situation.\r\n\r\nA (not so...) quick profile run puts the blame on [`_pytest/fixtures.py:238(reorder_items_atscope)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L238-L281) which calls [`_pytest/fixtures.py:228(fix_cache_order)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L228-L235).\r\n\r\n<details><summary>Profile output</summary>\r\n<p>\r\n\r\n```\r\n         225490710 function calls (225482776 primitive calls) in 79.889 seconds\r\n\r\n   Ordered by: cumulative time\r\n   List reduced from 3530 to 30 due to restriction <30>\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n    501/1    0.022    0.000   79.891   79.891 {built-in method builtins.exec}\r\n        1    0.000    0.000   79.891   79.891 <string>:1(<module>)\r\n        1    0.000    0.000   79.891   79.891 <frozen runpy>:201(run_module)\r\n        1    0.000    0.000   79.703   79.703 <frozen runpy>:65(_run_code)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/pytest/__main__.py:1(<module>)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:199(console_main)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:142(main)\r\n   475/71    0.001    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_manager.py:111(_hookexec)\r\n   475/71    0.004    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_callers.py:53(_multicall)\r\n    291/2    0.001    0.000   79.670   39.835 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_hooks.py:498(__call__)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:331(pytest_cmdline_main)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:272(wrap_session)\r\n        1    0.000    0.000   79.219   79.219 pytest/src/_pytest/main.py:335(_main)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:348(pytest_collection)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:746(perform_collect)\r\n        1    0.139    0.139   79.165   79.165 pytest/src/_pytest/fixtures.py:1617(pytest_collection_modifyitems)\r\n        1    0.000    0.000   79.025   79.025 pytest/src/_pytest/fixtures.py:210(reorder_items)\r\n      6/1    2.334    0.389   79.025   79.025 pytest/src/_pytest/fixtures.py:238(reorder_items_atscope)\r\n  1572861   27.109    0.000   74.492    0.000 pytest/src/_pytest/fixtures.py:228(fix_cache_order)\r\n 29886354    8.917    0.000   23.305    0.000 <string>:2(__hash__)\r\n77074144/77073790   17.417    0.000   20.581    0.000 {built-in method builtins.hash}\r\n 36175863    8.681    0.000   13.444    0.000 /usr/lib/python3.12/enum.py:1267(__hash__)\r\n 31457220    5.894    0.000    5.894    0.000 {method 'appendleft' of 'collections.deque' objects}\r\n  6298142    2.611    0.000    5.103    0.000 {method 'get' of 'dict' objects}\r\n 11010191    2.636    0.000    4.066    0.000 pytest/src/_pytest/nodes.py:289(__hash__)\r\n 29886863    3.164    0.000    3.166    0.000 /usr/lib/python3.12/pathlib.py:524(__hash__)\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nI don't have time to look into it right now and will look at it later, but this looks like a fun issue if someone else would like to try to figure it out. There are probably some python-level optimizations which could bring down the processing time, and algorithmic-level optimizations which could eliminate it entirely. Both are welcome.\nThanks for the report.\r\n\r\nBy gradually increasing the number of parameters, this looks like an [\"accidentally quadratic\"](https://accidentallyquadratic.tumblr.com/) (or worse...) situation.\r\n\r\nA (not so...) quick profile run puts the blame on [`_pytest/fixtures.py:238(reorder_items_atscope)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L238-L281) which calls [`_pytest/fixtures.py:228(fix_cache_order)`](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/fixtures.py#L228-L235).\r\n\r\n<details><summary>Profile output</summary>\r\n<p>\r\n\r\n```\r\n         225490710 function calls (225482776 primitive calls) in 79.889 seconds\r\n\r\n   Ordered by: cumulative time\r\n   List reduced from 3530 to 30 due to restriction <30>\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n    501/1    0.022    0.000   79.891   79.891 {built-in method builtins.exec}\r\n        1    0.000    0.000   79.891   79.891 <string>:1(<module>)\r\n        1    0.000    0.000   79.891   79.891 <frozen runpy>:201(run_module)\r\n        1    0.000    0.000   79.703   79.703 <frozen runpy>:65(_run_code)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/pytest/__main__.py:1(<module>)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:199(console_main)\r\n        1    0.000    0.000   79.703   79.703 pytest/src/_pytest/config/__init__.py:142(main)\r\n   475/71    0.001    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_manager.py:111(_hookexec)\r\n   475/71    0.004    0.000   79.672    1.122 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_callers.py:53(_multicall)\r\n    291/2    0.001    0.000   79.670   39.835 pytest/.tox/venv/lib/python3.12/site-packages/pluggy/_hooks.py:498(__call__)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:331(pytest_cmdline_main)\r\n        1    0.000    0.000   79.550   79.550 pytest/src/_pytest/main.py:272(wrap_session)\r\n        1    0.000    0.000   79.219   79.219 pytest/src/_pytest/main.py:335(_main)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:348(pytest_collection)\r\n        1    0.000    0.000   79.201   79.201 pytest/src/_pytest/main.py:746(perform_collect)\r\n        1    0.139    0.139   79.165   79.165 pytest/src/_pytest/fixtures.py:1617(pytest_collection_modifyitems)\r\n        1    0.000    0.000   79.025   79.025 pytest/src/_pytest/fixtures.py:210(reorder_items)\r\n      6/1    2.334    0.389   79.025   79.025 pytest/src/_pytest/fixtures.py:238(reorder_items_atscope)\r\n  1572861   27.109    0.000   74.492    0.000 pytest/src/_pytest/fixtures.py:228(fix_cache_order)\r\n 29886354    8.917    0.000   23.305    0.000 <string>:2(__hash__)\r\n77074144/77073790   17.417    0.000   20.581    0.000 {built-in method builtins.hash}\r\n 36175863    8.681    0.000   13.444    0.000 /usr/lib/python3.12/enum.py:1267(__hash__)\r\n 31457220    5.894    0.000    5.894    0.000 {method 'appendleft' of 'collections.deque' objects}\r\n  6298142    2.611    0.000    5.103    0.000 {method 'get' of 'dict' objects}\r\n 11010191    2.636    0.000    4.066    0.000 pytest/src/_pytest/nodes.py:289(__hash__)\r\n 29886863    3.164    0.000    3.166    0.000 /usr/lib/python3.12/pathlib.py:524(__hash__)\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nI don't have time to look into it right now and will look at it later, but this looks like a fun issue if someone else would like to try to figure it out. There are probably some python-level optimizations which could bring down the processing time, and algorithmic-level optimizations which could eliminate it entirely. Both are welcome.", "created_at": "2024-06-02T15:38:07Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12408, "instance_id": "pytest-dev__pytest-12408", "issue_numbers": ["12381"], "base_commit": "98021838fd97e10e1c9095fcbd0abbb6432a83cb", "patch": "diff --git a/changelog/12381.bugfix.rst b/changelog/12381.bugfix.rst\nnew file mode 100644\nindex 00000000000..02233cd4a84\n--- /dev/null\n+++ b/changelog/12381.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix possible \"Directory not empty\" crashes arising from concurent cache dir (``.pytest_cache``) creation. Regressed in pytest 8.2.0.\n", "test_patch": "diff --git a/src/_pytest/cacheprovider.py b/src/_pytest/cacheprovider.py\nindex 5aa8f483522..7e00135a4c1 100755\n--- a/src/_pytest/cacheprovider.py\n+++ b/src/_pytest/cacheprovider.py\n@@ -4,6 +4,7 @@\n # This plugin was not named \"cache\" to avoid conflicts with the external\n # pytest-cache version.\n import dataclasses\n+import errno\n import json\n import os\n from pathlib import Path\n@@ -227,14 +228,24 @@ def _ensure_cache_dir_and_supporting_files(self) -> None:\n             with open(path.joinpath(\"CACHEDIR.TAG\"), \"xb\") as f:\n                 f.write(CACHEDIR_TAG_CONTENT)\n \n-            path.rename(self._cachedir)\n-            # Create a directory in place of the one we just moved so that `TemporaryDirectory`'s\n-            # cleanup doesn't complain.\n-            #\n-            # TODO: pass ignore_cleanup_errors=True when we no longer support python < 3.10. See\n-            # https://github.com/python/cpython/issues/74168. Note that passing delete=False would\n-            # do the wrong thing in case of errors and isn't supported until python 3.12.\n-            path.mkdir()\n+            try:\n+                path.rename(self._cachedir)\n+            except OSError as e:\n+                # If 2 concurrent pytests both race to the rename, the loser\n+                # gets \"Directory not empty\" from the rename. In this case,\n+                # everything is handled so just continue (while letting the\n+                # temporary directory be cleaned up).\n+                if e.errno != errno.ENOTEMPTY:\n+                    raise\n+            else:\n+                # Create a directory in place of the one we just moved so that\n+                # `TemporaryDirectory`'s cleanup doesn't complain.\n+                #\n+                # TODO: pass ignore_cleanup_errors=True when we no longer support python < 3.10.\n+                # See https://github.com/python/cpython/issues/74168. Note that passing\n+                # delete=False would do the wrong thing in case of errors and isn't supported\n+                # until python 3.12.\n+                path.mkdir()\n \n \n class LFPluginCollWrapper:\n", "problem_statement": "`OSError: [Errno 39] Directory not empty` when doing `cache.mkdir()` from session fixture + pytest-xdist\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\n`cache.mkdir()` in a session-level fixture, in combination with xdist, sometimes results in `OSError: [Errno 39] Directory not empty` when pytest tries to rename the cache directory.\r\n\r\nThis is a regression in 8.2.0, most likely introduced by https://github.com/pytest-dev/pytest/pull/12168 / https://github.com/pytest-dev/pytest/issues/12167\r\n\r\nOn 8.1.x `cache.mkdir()` works fine in the same case.\r\n\r\nIn `conftest.py`:\r\n\r\n```py\r\n@pytest.fixture(scope='session')\r\ndef my_fixture(request):\r\n    return request.config.cache.mkdir('testdir')\r\n```\r\n\r\nIn `test_tests.py`:\r\n\r\n```py\r\n@pytest.mark.parametrize('n', list((n,) for n in range(42)))\r\ndef test_test(my_fixture, n):\r\n    pass\r\n```\r\n\r\nRunning with `pytest -n auto` results in:\r\n\r\n```\r\nself = PosixPath('/home/runner/work/pytest-cache-race/pytest-cache-race/.tox/python/pytest-cache-files-8ulls0nm')\r\ntarget = PosixPath('/home/runner/work/pytest-cache-race/pytest-cache-race/.tox/python/.pytest_cache')\r\n\r\n    def rename(self, target):\r\n        \"\"\"\r\n        Rename this path to the target path.\r\n    \r\n        The target path may be absolute or relative. Relative paths are\r\n        interpreted relative to the current working directory, *not* the\r\n        directory of the Path object.\r\n    \r\n        Returns the new Path instance pointing to the target path.\r\n        \"\"\"\r\n>       self._accessor.rename(self, target)\r\nE       OSError: [Errno 39] Directory not empty: '/home/runner/work/pytest-cache-race/pytest-cache-race/.tox/python/pytest-cache-files-8ulls0nm' -> '/home/runner/work/pytest-cache-race/pytest-cache-race/.tox/python/.pytest_cache'\r\n```\r\n\r\nOperating System: Ubuntu 22.04.4 LTS\r\nPython 3.10.12, pytest-8.2.1\r\nVirtualenv content: `exceptiongroup==1.2.1,execnet==2.1.1,iniconfig==2.0.0,packaging==24.0,pluggy==1.5.0,pytest==8.2.1,pytest-xdist==3.6.1,tomli==2.0.1`\r\n\r\nhttps://github.com/amezin/pytest-cache-race\r\n\r\nReproduced in GitHub Actions: https://github.com/amezin/pytest-cache-race/actions/runs/9261012859/job/25475719651\n", "hints_text": "Hmm, so now we have a different race. I think we should be able to ignore this error, i.e. if it happens just continue (while removing the directory). This is because we can assume that the first worker correctly created the directory atomically.", "created_at": "2024-06-02T14:06:51Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12368, "instance_id": "pytest-dev__pytest-12368", "issue_numbers": ["12367"], "base_commit": "3fbf4d3cbd7cf2421ec2b699f7a74324b33b6f70", "patch": "diff --git a/changelog/12367.bugfix.rst b/changelog/12367.bugfix.rst\nnew file mode 100644\nindex 00000000000..e8bf2e4f155\n--- /dev/null\n+++ b/changelog/12367.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.2.0 where unittest class instances (a fresh one is created for each test) were not released promptly on test teardown but only on session teardown.\n", "test_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 919b497c295..643443f08c6 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -218,11 +218,12 @@ def setup(self) -> None:\n         super().setup()\n \n     def teardown(self) -> None:\n-        super().teardown()\n         if self._explicit_tearDown is not None:\n             self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._obj = None\n+        self._instance = None\n+        super().teardown()\n \n     def startTest(self, testcase: \"unittest.TestCase\") -> None:\n         pass\ndiff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 003a74d3849..c359715dc2e 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1,5 +1,4 @@\n # mypy: allow-untyped-defs\n-import gc\n import sys\n from typing import List\n \n@@ -192,30 +191,35 @@ def test_check(self):\n def test_teardown_issue1649(pytester: Pytester) -> None:\n     \"\"\"\n     Are TestCase objects cleaned up? Often unittest TestCase objects set\n-    attributes that are large and expensive during setUp.\n+    attributes that are large and expensive during test run or setUp.\n \n     The TestCase will not be cleaned up if the test fails, because it\n     would then exist in the stackframe.\n+\n+    Regression test for #1649 (see also #12367).\n     \"\"\"\n-    testpath = pytester.makepyfile(\n+    pytester.makepyfile(\n         \"\"\"\n         import unittest\n-        class TestCaseObjectsShouldBeCleanedUp(unittest.TestCase):\n-            def setUp(self):\n-                self.an_expensive_object = 1\n-            def test_demo(self):\n-                pass\n+        import gc\n \n-    \"\"\"\n+        class TestCaseObjectsShouldBeCleanedUp(unittest.TestCase):\n+            def test_expensive(self):\n+                self.an_expensive_obj = object()\n+\n+            def test_is_it_still_alive(self):\n+                gc.collect()\n+                for obj in gc.get_objects():\n+                    if type(obj).__name__ == \"TestCaseObjectsShouldBeCleanedUp\":\n+                        assert not hasattr(obj, \"an_expensive_obj\")\n+                        break\n+                else:\n+                    assert False, \"Could not find TestCaseObjectsShouldBeCleanedUp instance\"\n+        \"\"\"\n     )\n \n-    pytester.inline_run(\"-s\", testpath)\n-    gc.collect()\n-\n-    # Either already destroyed, or didn't run setUp.\n-    for obj in gc.get_objects():\n-        if type(obj).__name__ == \"TestCaseObjectsShouldBeCleanedUp\":\n-            assert not hasattr(obj, \"an_expensive_obj\")\n+    result = pytester.runpytest()\n+    assert result.ret == ExitCode.OK\n \n \n def test_unittest_skip_issue148(pytester: Pytester) -> None:\n", "problem_statement": "Unittest class instances no longer released on test teardown since pytest 8.2.0\nFollow up to #12266. Related to #12198.\r\n\r\nSince 0dc036035107b213c9b73bf965cbd7356111b85a in pytest 8.2, pytest started holding onto class instances on the Function items, where previously the instance was gone on teardown.\r\n\r\nI was a bit confused how the previous behavior happened, since it *doesn't* happen for non-unittest test classes. The secret is this line:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/src/_pytest/unittest.py#L225C9-L225C25\r\n\r\nturns out unittest explicitly clears up the obj on teardown, since e46e653794e3b72d7cc02d374086191224221501 (pytest 3.0.4). The reason this regressed in 0dc036035107b213c9b73bf965cbd7356111b85a is that we now also need to clear `_instance`.  So the fix is simple.\r\n\r\nCommit 0dc036035107b213c9b73bf965cbd7356111b85a came with [a test](https://github.com/pytest-dev/pytest/blob/889d9b28d786c75b66f4d1acb80123bdb341639c/testing/test_unittest.py#L192), but it didn't catch the regression. I will try to improve it.\r\n\r\n---\r\n\r\nOne obvious question I think is, why do we only clear `_obj` for `TestCaseFunction` and not for `Function` itself (superclass of `TestCaseFunction` used for regular test methods and functions)? As far as I can see there is no good reason, we should do it and gain the same \"prompt release\" behavior for all tests. All of pytest's tests pass when I try it.\r\n\r\nUnfortunately there *is* a hitch involving plugins. The `Function` item has a feature where it can take a `callobj` argument to use as the `obj` instead of getting it itself. In this case the `Function` doesn't \"own\" the obj and can't clear it, otherwise when the item is re-run (as is done by plugins such as pytest-rerunfailures) the `obj` will not be the `callobj` on the second run.\r\n\r\nInternally, `callobj` is only used for `FunctionDefinition` and it's not a problem to handle this, but `callobj` is also used by several plugins, most notably [pytest-asyncio](https://github.com/pytest-dev/pytest-asyncio/blob/2bfffea3a8eb615a934d6ab175804e28ee9edb60/pytest_asyncio/plugin.py#L400) and we can't break that.\r\n\r\nSo while it will be good to do this change more generally, it requires care. So for now I'll only do the fix for unittest.\n", "hints_text": "", "created_at": "2024-05-25T19:20:09Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12334, "instance_id": "pytest-dev__pytest-12334", "issue_numbers": ["12323"], "base_commit": "ee9ea703f98df811738e7ea58bffe6c1bc660371", "patch": "diff --git a/changelog/12334.improvement.rst b/changelog/12334.improvement.rst\nnew file mode 100644\nindex 00000000000..7fd52e9dbb8\n--- /dev/null\n+++ b/changelog/12334.improvement.rst\n@@ -0,0 +1,1 @@\n+Support for Python 3.13 (beta1 at the time of writing).\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 2be02ee7e23..b85f39d856c 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -31,6 +31,7 @@ classifiers = [\n     \"Programming Language :: Python :: 3.10\",\n     \"Programming Language :: Python :: 3.11\",\n     \"Programming Language :: Python :: 3.12\",\n+    \"Programming Language :: Python :: 3.13\",\n     \"Topic :: Software Development :: Libraries\",\n     \"Topic :: Software Development :: Testing\",\n     \"Topic :: Utilities\",\ndiff --git a/tox.ini b/tox.ini\nindex 4e1ff111966..0a3f0acf5b8 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -9,6 +9,7 @@ envlist =\n     py310\n     py311\n     py312\n+    py313\n     pypy3\n     py38-{pexpect,xdist,unittestextras,numpy,pluggymain,pylib}\n     doctesting\n", "test_patch": "diff --git a/.github/workflows/test.yml b/.github/workflows/test.yml\nindex df801864fd8..09d37aaa2c8 100644\n--- a/.github/workflows/test.yml\n+++ b/.github/workflows/test.yml\n@@ -55,6 +55,7 @@ jobs:\n           \"windows-py310\",\n           \"windows-py311\",\n           \"windows-py312\",\n+          \"windows-py313\",\n \n           \"ubuntu-py38\",\n           \"ubuntu-py38-pluggy\",\n@@ -63,12 +64,14 @@ jobs:\n           \"ubuntu-py310\",\n           \"ubuntu-py311\",\n           \"ubuntu-py312\",\n+          \"ubuntu-py313\",\n           \"ubuntu-pypy3\",\n \n           \"macos-py38\",\n           \"macos-py39\",\n           \"macos-py310\",\n           \"macos-py312\",\n+          \"macos-py313\",\n \n           \"doctesting\",\n           \"plugins\",\n@@ -97,9 +100,13 @@ jobs:\n             os: windows-latest\n             tox_env: \"py311\"\n           - name: \"windows-py312\"\n-            python: \"3.12-dev\"\n+            python: \"3.12\"\n             os: windows-latest\n             tox_env: \"py312\"\n+          - name: \"windows-py313\"\n+            python: \"3.13-dev\"\n+            os: windows-latest\n+            tox_env: \"py313\"\n \n           - name: \"ubuntu-py38\"\n             python: \"3.8\"\n@@ -128,10 +135,15 @@ jobs:\n             tox_env: \"py311\"\n             use_coverage: true\n           - name: \"ubuntu-py312\"\n-            python: \"3.12-dev\"\n+            python: \"3.12\"\n             os: ubuntu-latest\n             tox_env: \"py312\"\n             use_coverage: true\n+          - name: \"ubuntu-py313\"\n+            python: \"3.13-dev\"\n+            os: ubuntu-latest\n+            tox_env: \"py313\"\n+            use_coverage: true\n           - name: \"ubuntu-pypy3\"\n             python: \"pypy-3.8\"\n             os: ubuntu-latest\n@@ -151,9 +163,13 @@ jobs:\n             os: macos-latest\n             tox_env: \"py310-xdist\"\n           - name: \"macos-py312\"\n-            python: \"3.12-dev\"\n+            python: \"3.12\"\n             os: macos-latest\n             tox_env: \"py312-xdist\"\n+          - name: \"macos-py313\"\n+            python: \"3.13-dev\"\n+            os: macos-latest\n+            tox_env: \"py313-xdist\"\n \n           - name: \"plugins\"\n             python: \"3.12\"\ndiff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex b80d53ca5f9..cfa226bb749 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -424,15 +424,14 @@ def recursionindex(self) -> Optional[int]:\n             # which generates code objects that have hash/value equality\n             # XXX needs a test\n             key = entry.frame.code.path, id(entry.frame.code.raw), entry.lineno\n-            # print \"checking for recursion at\", key\n             values = cache.setdefault(key, [])\n+            # Since Python 3.13 f_locals is a proxy, freeze it.\n+            loc = dict(entry.frame.f_locals)\n             if values:\n-                f = entry.frame\n-                loc = f.f_locals\n                 for otherloc in values:\n                     if otherloc == loc:\n                         return i\n-            values.append(entry.frame.f_locals)\n+            values.append(loc)\n         return None\n \n \ndiff --git a/src/_pytest/pytester.py b/src/_pytest/pytester.py\nindex 31c6de78195..f9ab007a4d1 100644\n--- a/src/_pytest/pytester.py\n+++ b/src/_pytest/pytester.py\n@@ -289,7 +289,8 @@ def assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None:\n         __tracebackhide__ = True\n         i = 0\n         entries = list(entries)\n-        backlocals = sys._getframe(1).f_locals\n+        # Since Python 3.13, f_locals is not a dict, but eval requires a dict.\n+        backlocals = dict(sys._getframe(1).f_locals)\n         while entries:\n             name, check = entries.pop(0)\n             for ind, call in enumerate(self.calls[i:]):\n@@ -760,6 +761,9 @@ def _makefile(\n     ) -> Path:\n         items = list(files.items())\n \n+        if ext is None:\n+            raise TypeError(\"ext must not be None\")\n+\n         if ext and not ext.startswith(\".\"):\n             raise ValueError(\n                 f\"pytester.makefile expects a file extension, try .{ext} instead of {ext}\"\ndiff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 86e30dc4830..b5474512987 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -1,6 +1,7 @@\n # mypy: allow-untyped-defs\n from __future__ import annotations\n \n+import fnmatch\n import importlib\n import io\n import operator\n@@ -237,7 +238,7 @@ def f(n):\n                 n += 1\n             f(n)\n \n-        excinfo = pytest.raises(RuntimeError, f, 8)\n+        excinfo = pytest.raises(RecursionError, f, 8)\n         traceback = excinfo.traceback\n         recindex = traceback.recursionindex()\n         assert recindex == 3\n@@ -373,7 +374,10 @@ def test_excinfo_no_sourcecode():\n     except ValueError:\n         excinfo = _pytest._code.ExceptionInfo.from_current()\n     s = str(excinfo.traceback[-1])\n-    assert s == \"  File '<string>':1 in <module>\\n  ???\\n\"\n+    # TODO: Since Python 3.13b1 under pytest-xdist, the * is `import\n+    # sys;exec(eval(sys.stdin.readline()))` (execnet bootstrap code)\n+    # instead of `???` like before. Is this OK?\n+    fnmatch.fnmatch(s, \"  File '<string>':1 in <module>\\n  *\\n\")\n \n \n def test_excinfo_no_python_sourcecode(tmp_path: Path) -> None:\ndiff --git a/testing/code/test_source.py b/testing/code/test_source.py\nindex 2fa85205795..a00259976c4 100644\n--- a/testing/code/test_source.py\n+++ b/testing/code/test_source.py\n@@ -370,7 +370,11 @@ class B:\n         pass\n \n     B.__name__ = B.__qualname__ = \"B2\"\n-    assert getfslineno(B)[1] == -1\n+    # Since Python 3.13 this started working.\n+    if sys.version_info >= (3, 13):\n+        assert getfslineno(B)[1] != -1\n+    else:\n+        assert getfslineno(B)[1] == -1\n \n \n def test_code_of_object_instance_with_call() -> None:\ndiff --git a/testing/test_cacheprovider.py b/testing/test_cacheprovider.py\nindex d7815f77b9a..8728ae84fdc 100644\n--- a/testing/test_cacheprovider.py\n+++ b/testing/test_cacheprovider.py\n@@ -194,7 +194,7 @@ def test_custom_cache_dir_with_env_var(\n         assert pytester.path.joinpath(\"custom_cache_dir\").is_dir()\n \n \n-@pytest.mark.parametrize(\"env\", ((), (\"TOX_ENV_DIR\", \"/tox_env_dir\")))\n+@pytest.mark.parametrize(\"env\", ((), (\"TOX_ENV_DIR\", \"mydir/tox-env\")))\n def test_cache_reportheader(\n     env: Sequence[str], pytester: Pytester, monkeypatch: MonkeyPatch\n ) -> None:\ndiff --git a/testing/test_doctest.py b/testing/test_doctest.py\nindex d731121795d..9b33d641a14 100644\n--- a/testing/test_doctest.py\n+++ b/testing/test_doctest.py\n@@ -224,11 +224,7 @@ def test_doctest_unexpected_exception(self, pytester: Pytester):\n                 \"Traceback (most recent call last):\",\n                 '  File \"*/doctest.py\", line *, in __run',\n                 \"    *\",\n-                *(\n-                    (\" *^^^^*\",)\n-                    if (3, 11, 0, \"beta\", 4) > sys.version_info >= (3, 11)\n-                    else ()\n-                ),\n+                *((\" *^^^^*\", \" *\", \" *\") if sys.version_info >= (3, 13) else ()),\n                 '  File \"<doctest test_doctest_unexpected_exception.txt[1]>\", line 1, in <module>',\n                 \"ZeroDivisionError: division by zero\",\n                 \"*/test_doctest_unexpected_exception.txt:2: UnexpectedException\",\n@@ -385,7 +381,7 @@ def some_property(self):\n                 \"*= FAILURES =*\",\n                 \"*_ [[]doctest[]] test_doctest_linedata_on_property.Sample.some_property _*\",\n                 \"004 \",\n-                \"005         >>> Sample().some_property\",\n+                \"005 *>>> Sample().some_property\",\n                 \"Expected:\",\n                 \"    'another thing'\",\n                 \"Got:\",\ndiff --git a/testing/test_main.py b/testing/test_main.py\nindex 345aa1e62cf..6294f66b360 100644\n--- a/testing/test_main.py\n+++ b/testing/test_main.py\n@@ -3,7 +3,6 @@\n import os\n from pathlib import Path\n import re\n-import sys\n from typing import Optional\n \n from _pytest.config import ExitCode\n@@ -45,32 +44,18 @@ def pytest_internalerror(excrepr, excinfo):\n         assert result.ret == ExitCode.INTERNAL_ERROR\n     assert result.stdout.lines[0] == \"INTERNALERROR> Traceback (most recent call last):\"\n \n-    end_lines = (\n-        result.stdout.lines[-4:]\n-        if (3, 11, 0, \"beta\", 4) > sys.version_info >= (3, 11)\n-        else result.stdout.lines[-3:]\n-    )\n+    end_lines = result.stdout.lines[-3:]\n \n     if exc == SystemExit:\n         assert end_lines == [\n             f'INTERNALERROR>   File \"{c1}\", line 4, in pytest_sessionstart',\n             'INTERNALERROR>     raise SystemExit(\"boom\")',\n-            *(\n-                (\"INTERNALERROR>     ^^^^^^^^^^^^^^^^^^^^^^^^\",)\n-                if (3, 11, 0, \"beta\", 4) > sys.version_info >= (3, 11)\n-                else ()\n-            ),\n             \"INTERNALERROR> SystemExit: boom\",\n         ]\n     else:\n         assert end_lines == [\n             f'INTERNALERROR>   File \"{c1}\", line 4, in pytest_sessionstart',\n             'INTERNALERROR>     raise ValueError(\"boom\")',\n-            *(\n-                (\"INTERNALERROR>     ^^^^^^^^^^^^^^^^^^^^^^^^\",)\n-                if (3, 11, 0, \"beta\", 4) > sys.version_info >= (3, 11)\n-                else ()\n-            ),\n             \"INTERNALERROR> ValueError: boom\",\n         ]\n     if returncode is False:\n", "problem_statement": "Test failures on Python 3.13.0b1\nI don't seem to be able to find a bug for tracking Python 3.13 support, so I hope it's fine if I file one.\r\n\r\n```pytb\r\n$ tox -e py313\r\n.pkg: _optional_hooks> python /usr/lib/python3.12/site-packages/pyproject_api/_backend.py True setuptools.build_meta\r\n.pkg: get_requires_for_build_sdist> python /usr/lib/python3.12/site-packages/pyproject_api/_backend.py True setuptools.build_meta\r\n.pkg: get_requires_for_build_editable> python /usr/lib/python3.12/site-packages/pyproject_api/_backend.py True setuptools.build_meta\r\n.pkg: build_sdist> python /usr/lib/python3.12/site-packages/pyproject_api/_backend.py True setuptools.build_meta\r\npy313: install_package> python -I -m pip install --force-reinstall --no-deps /tmp/pytest/.tox/.tmp/package/2/pytest-8.3.0.dev38+g93dd34e76.tar.gz\r\npy313: commands[0]> pytest\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.13.0b1, pytest-8.3.0.dev38+g93dd34e76, pluggy-1.5.0\r\ncachedir: .tox/py313/.pytest_cache\r\nrootdir: /tmp/pytest\r\nconfigfile: pyproject.toml\r\ntestpaths: testing\r\nplugins: hypothesis-6.102.1\r\ncollected 3668 items\r\n\r\n[\u2026]\r\n=========================== short test summary info ============================\r\nFAILED testing/code/test_excinfo.py::TestTraceback_f_g_h::test_traceback_recursion_index\r\nFAILED testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_traceback_recursion\r\nFAILED testing/code/test_excinfo.py::test_exception_repr_extraction_error_on_recursion\r\nFAILED testing/code/test_source.py::test_getfslineno - assert 368 == -1\r\nFAILED testing/test_collection.py::TestSession::test_collect_protocol_single_function\r\nFAILED testing/test_collection.py::TestSession::test_collect_custom_nodes_multi_id\r\nFAILED testing/test_collection.py::TestSession::test_collect_subdir_event_ordering\r\nFAILED testing/test_collection.py::TestSession::test_collect_two_commandline_args\r\nFAILED testing/test_doctest.py::TestDoctests::test_doctest_unexpected_exception\r\nFAILED testing/test_doctest.py::TestDoctests::test_doctest_linedata_on_property\r\nFAILED testing/test_legacypath.py::test_testdir_makefile_ext_none_raises_type_error\r\nXPASS testing/_py/test_local.py::TestLocalPath::test_make_numbered_dir_multiprocess_safe - #11603\r\n= 11 failed, 3535 passed, 110 skipped, 11 xfailed, 1 xpassed in 138.50s (0:02:18) =\r\npy313: exit 1 (139.10 seconds) /tmp/pytest> pytest pid=65870\r\n  py313: FAIL code 1 (145.84=setup[6.73]+cmd[139.10] seconds)\r\n  evaluation failed :( (146.00 seconds)\r\n```\r\n\r\nThis is on Gentoo Linux amd64, with 93dd34e76d9c687d1c249fe8cf94bdf46813f783.\r\n\r\nFull log: \r\n[py313.txt](https://github.com/pytest-dev/pytest/files/15310368/py313.txt)\r\n\n", "hints_text": "", "created_at": "2024-05-17T08:40:30Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12329, "instance_id": "pytest-dev__pytest-12329", "issue_numbers": ["12328"], "base_commit": "fa1d5be3e8b0a34106b35eff092adaa67c9de503", "patch": "diff --git a/changelog/12328.bugfix.rst b/changelog/12328.bugfix.rst\nnew file mode 100644\nindex 00000000000..f334425850b\n--- /dev/null\n+++ b/changelog/12328.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.0.0 where package-scoped parameterized items were not correctly reordered to minimize setups/teardowns in some cases.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 5a290718fe4..a271f947d45 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -187,7 +187,8 @@ def get_parametrized_fixture_keys(\n         if scope is Scope.Session:\n             scoped_item_path = None\n         elif scope is Scope.Package:\n-            scoped_item_path = item.path\n+            # Package key = module's directory.\n+            scoped_item_path = item.path.parent\n         elif scope is Scope.Module:\n             scoped_item_path = item.path\n         elif scope is Scope.Class:\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex aec0deb99a1..13ab4904c1a 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -4274,6 +4274,39 @@ def test_func(self, f2, f1, m2):\n         request = TopRequest(items[0], _ispytest=True)\n         assert request.fixturenames == \"s1 p1 m1 m2 c1 f2 f1\".split()\n \n+    def test_parametrized_package_scope_reordering(self, pytester: Pytester) -> None:\n+        \"\"\"A paramaterized package-scoped fixture correctly reorders items to\n+        minimize setups & teardowns.\n+\n+        Regression test for #12328.\n+        \"\"\"\n+        pytester.makepyfile(\n+            __init__=\"\",\n+            conftest=\"\"\"\n+                import pytest\n+                @pytest.fixture(scope=\"package\", params=[\"a\", \"b\"])\n+                def fix(request):\n+                    return request.param\n+            \"\"\",\n+            test_1=\"def test1(fix): pass\",\n+            test_2=\"def test2(fix): pass\",\n+        )\n+\n+        result = pytester.runpytest(\"--setup-plan\")\n+        assert result.ret == ExitCode.OK\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"  SETUP    P fix['a']\",\n+                \"        test_1.py::test1[a] (fixtures used: fix, request)\",\n+                \"        test_2.py::test2[a] (fixtures used: fix, request)\",\n+                \"  TEARDOWN P fix['a']\",\n+                \"  SETUP    P fix['b']\",\n+                \"        test_1.py::test1[b] (fixtures used: fix, request)\",\n+                \"        test_2.py::test2[b] (fixtures used: fix, request)\",\n+                \"  TEARDOWN P fix['b']\",\n+            ],\n+        )\n+\n     def test_multiple_packages(self, pytester: Pytester) -> None:\n         \"\"\"Complex test involving multiple package fixtures. Make sure teardowns\n         are executed in order.\n", "problem_statement": "Pytest 8 broke sorting for package-scoped fixtures\nPytest 8 has a regression where the test reordering no longer favours reuse of package-scoped fixtures. If a parametrised package-scoped fixture is used in multiple modules within the same package, then instead of running the whole package with one fixture instantiation before switching to the next, it runs a module at a time, causing the fixture to be torn down and recreated each time.\r\n\r\n## MWE\r\n\r\n`conftest.py`:\r\n```python\r\nimport pytest\r\n\r\n@pytest.fixture(scope=\"package\", params=[\"a\", \"b\", \"c\"])\r\ndef fixture(request):\r\n    return request.param\r\n```\r\n\r\n`pkg/__init__.py`: empty\r\n\r\n`pkg/test_things1.py`:\r\n```\r\ndef test1(fixture):\r\n    pass\r\n```\r\n\r\n`pkg/test_things2.py`:\r\n```\r\ndef test2(fixture):\r\n    pass\r\n```\r\n\r\nOutput of `pytest --setup-plan` from pytest 8.2.0:\r\n```\r\n======================================= test session starts ========================================\r\nplatform linux -- Python 3.12.3, pytest-8.2.0, pluggy-1.5.0\r\nrootdir: /home/bmerry/work/experiments/NGC-1318-pytest-ordering/simple\r\ncollected 6 items                                                                                  \r\n\r\npkg/test_things1.py \r\n  SETUP    P fixture['a']\r\n        pkg/test_things1.py::test1[a] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['a']\r\n  SETUP    P fixture['b']\r\n        pkg/test_things1.py::test1[b] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['b']\r\n  SETUP    P fixture['c']\r\n        pkg/test_things1.py::test1[c] (fixtures used: fixture, request)\r\npkg/test_things2.py \r\n  TEARDOWN P fixture['c']\r\n  SETUP    P fixture['a']\r\n        pkg/test_things2.py::test2[a] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['a']\r\n  SETUP    P fixture['b']\r\n        pkg/test_things2.py::test2[b] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['b']\r\n  SETUP    P fixture['c']\r\n        pkg/test_things2.py::test2[c] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['c']\r\n```\r\n\r\nWhereas pytest 7.4.4 produces:\r\n```======================================= test session starts ========================================\r\nplatform linux -- Python 3.12.3, pytest-7.4.4, pluggy-1.5.0\r\nrootdir: /home/bmerry/work/experiments/NGC-1318-pytest-ordering/simple\r\ncollected 6 items                                                                                  \r\n\r\npkg/test_things1.py \r\n  SETUP    P fixture['a']\r\n        pkg/test_things1.py::test1[a] (fixtures used: fixture, request)\r\npkg/test_things2.py \r\n        pkg/test_things2.py::test2[a] (fixtures used: fixture, request)\r\npkg/test_things1.py \r\n  TEARDOWN P fixture['a']\r\n  SETUP    P fixture['b']\r\n        pkg/test_things1.py::test1[b] (fixtures used: fixture, request)\r\npkg/test_things2.py \r\n        pkg/test_things2.py::test2[b] (fixtures used: fixture, request)\r\npkg/test_things1.py \r\n  TEARDOWN P fixture['b']\r\n  SETUP    P fixture['c']\r\n        pkg/test_things1.py::test1[c] (fixtures used: fixture, request)\r\npkg/test_things2.py \r\n        pkg/test_things2.py::test2[c] (fixtures used: fixture, request)\r\n  TEARDOWN P fixture['c']\r\n\r\n====================================== no tests ran in 0.01s =======================================\r\n```\r\n\r\nIf the fixture is not parametric (or has only one parameter), it does correctly re-use the fixture across the whole package, so the issue seems to be related to sorting rather than re-use.\r\n\r\nChanging the scope to `session` gives sensible behaviour, so it seems to be specific to package scope.\r\n\r\n## System information\r\n\r\npip list:\r\n```\r\nPackage    Version\r\n---------- -------\r\niniconfig  2.0.0\r\npackaging  24.0\r\npip        24.0\r\npluggy     1.5.0\r\npytest     8.2.0\r\nsetuptools 69.5.1\r\nwheel      0.43.0\r\n```\r\n\r\nOS: Ubuntu 24.04\r\n\r\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\n", "hints_text": "I think I agree this is a regression. This broke with a21fb87a90974189c1b8b26189959507189bb3a1 (released in 8.0.0). Specifically, the `reorder_items` function stopped reordering the items in this case. I will take a look.", "created_at": "2024-05-15T14:47:17Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12325, "instance_id": "pytest-dev__pytest-12325", "issue_numbers": ["12308"], "base_commit": "ae1a47e050fcf9715dd01e6b31412d9223662b60", "patch": "diff --git a/changelog/12308.bugfix.rst b/changelog/12308.bugfix.rst\nnew file mode 100644\nindex 00000000000..07995427a1a\n--- /dev/null\n+++ b/changelog/12308.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.2.0 where the permissions of automatically-created ``.pytest_cache`` directories became ``rwx------`` instead of the expected ``rwxr-xr-x``.\n", "test_patch": "diff --git a/src/_pytest/cacheprovider.py b/src/_pytest/cacheprovider.py\nindex 4593e2a8172..06def557e41 100755\n--- a/src/_pytest/cacheprovider.py\n+++ b/src/_pytest/cacheprovider.py\n@@ -213,6 +213,13 @@ def _ensure_cache_dir_and_supporting_files(self) -> None:\n             dir=self._cachedir.parent,\n         ) as newpath:\n             path = Path(newpath)\n+\n+            # Reset permissions to the default, see #12308.\n+            # Note: there's no way to get the current umask atomically, eek.\n+            umask = os.umask(0o022)\n+            os.umask(umask)\n+            path.chmod(0o777 - umask)\n+\n             with open(path.joinpath(\"README.md\"), \"xt\", encoding=\"UTF-8\") as f:\n                 f.write(README_CONTENT)\n             with open(path.joinpath(\".gitignore\"), \"xt\", encoding=\"UTF-8\") as f:\ndiff --git a/testing/test_cacheprovider.py b/testing/test_cacheprovider.py\nindex 6c18c358a80..c85c1d04cc7 100644\n--- a/testing/test_cacheprovider.py\n+++ b/testing/test_cacheprovider.py\n@@ -31,6 +31,21 @@ def test_config_cache_mkdir(self, pytester: Pytester) -> None:\n         p = config.cache.mkdir(\"name\")\n         assert p.is_dir()\n \n+    def test_cache_dir_permissions(self, pytester: Pytester) -> None:\n+        \"\"\"The .pytest_cache directory should have world-readable permissions\n+        (depending on umask).\n+\n+        Regression test for #12308.\n+        \"\"\"\n+        pytester.makeini(\"[pytest]\")\n+        config = pytester.parseconfigure()\n+        assert config.cache is not None\n+        p = config.cache.mkdir(\"name\")\n+        assert p.is_dir()\n+        # Instead of messing with umask, make sure .pytest_cache has the same\n+        # permissions as the default that `mkdir` gives `p`.\n+        assert (p.parent.stat().st_mode & 0o777) == (p.stat().st_mode & 0o777)\n+\n     def test_config_cache_dataerror(self, pytester: Pytester) -> None:\n         pytester.makeini(\"[pytest]\")\n         config = pytester.parseconfigure()\n", "problem_statement": "Error: EACCES: permission denied, scandir .pytest_cache with 8.2.0\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n- [X] pytest and operating system versions\r\n- [X] minimal example if possible\r\n\r\nWhen upgrading to Pytest 8.2.0, I was getting a `Error: The template is not valid. .github/workflows/full-build.yml (Line: 92, Col: 16): hashFiles('**/poetry.lock') failed. Fail to hash files under directory '/home/runner/work/gaphor/gaphor'`. When I turned on debug mode on the runner, it looks like the error is caused by an access issue with .pytest_cache which could be a regression caused by https://github.com/pytest-dev/pytest/pull/12168.\r\n\r\nOS: Fedora 39 Docker running on Ubuntu 22.04 VM\r\nPython: Python 3.11.9\r\nPytest: 8.2.0\r\n\r\nThe error happens during the Post Use Dependency Cache step with actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9.\r\n\r\nThe larger traceback is:\r\n```\r\n##[debug]..Evaluating hashFiles:\r\n##[debug]....Evaluating String:\r\n##[debug]....=> '**/poetry.lock'\r\n##[debug]Search root directory: '/home/runner/work/gaphor/gaphor'\r\n##[debug]Search pattern: '**/poetry.lock'\r\n##[debug]Starting process:\r\n##[debug]  File name: '/home/runner/runners/2.316.1/externals/node16/bin/node'\r\n##[debug]  Arguments: '\"/home/runner/runners/2.316.1/bin/hashFiles\"'\r\n##[debug]  Working directory: '/home/runner/work/gaphor/gaphor'\r\n##[debug]  Require exit code zero: 'False'\r\n##[debug]  Encoding web name:  ; code page: ''\r\n##[debug]  Force kill process on cancellation: 'False'\r\n##[debug]  Redirected STDIN: 'False'\r\n##[debug]  Persist current code page: 'False'\r\n##[debug]  Keep redirected STDIN open: 'False'\r\n##[debug]  High priority process: 'False'\r\n##[debug]Updated oom_score_adj to 500 for PID: 4319.\r\n##[debug]Process started with process id 4319, waiting for process exit.\r\n##[debug]Match Pattern: **/poetry.lock\r\n##[debug]::debug::followSymbolicLinks 'false'\r\n##[debug]::debug::followSymbolicLinks 'false'\r\n##[debug]::debug::implicitDescendants 'true'\r\n##[debug]::debug::matchDirectories 'true'\r\n##[debug]::debug::omitBrokenSymbolicLinks 'true'\r\n##[debug]::debug::Search path '/home/runner/work/gaphor/gaphor'\r\n##[debug][Error: EACCES: permission denied, scandir '/home/runner/work/gaphor/gaphor/.pytest_cache'] {\r\n##[debug]  errno: -13,\r\n##[debug]  code: 'EACCES',\r\n##[debug]  syscall: 'scandir',\r\n##[debug]  path: '/home/runner/work/gaphor/gaphor/.pytest_cache'\r\n##[debug]}\r\n##[debug]STDOUT/STDERR stream read finished.\r\n##[debug]STDOUT/STDERR stream read finished.\r\n##[debug]Finished process 4319 with exit code 1, and elapsed time 00:00:00.0692324.\r\n##[debug].github/workflows/full-build.yml (Line: 92, Col: 16):\r\nError: The template is not valid. .github/workflows/full-build.yml (Line: 92, Col: 16): hashFiles('**/poetry.lock') failed. Fail to hash files under directory '/home/runner/work/gaphor/gaphor'\r\n```\r\n\r\nThe full run is here: https://github.com/gaphor/gaphor/actions/runs/8976797623/job/24855725418\r\n\r\nThe output of pip list for this environment is:\r\n\r\n```\r\nPackage                       Version   Editable project location\r\n----------------------------- --------- -------------------------\r\nalabaster                     0.7.16\r\nasttokens                     2.4.1\r\nattrs                         23.2.0\r\nBabel                         2.15.0\r\nBabelGladeExtractor           0.7.0\r\nbeautifulsoup4                4.12.3\r\nbetter-exceptions             0.3.3\r\ncertifi                       2024.2.2\r\ncfgv                          3.4.0\r\ncharset-normalizer            3.3.2\r\nclick                         8.1.7\r\ncomm                          0.2.1\r\ncoverage                      7.4.3\r\ndebugpy                       1.8.1\r\ndecorator                     5.1.1\r\ndefusedxml                    0.7.1\r\ndistlib                       0.3.8\r\ndocutils                      0.20.1\r\ndulwich                       0.22.1\r\nexceptiongroup                1.2.0\r\nexecuting                     2.0.1\r\nfastjsonschema                2.19.1\r\nfilelock                      3.13.1\r\nfuro                          2024.1.29\r\ngaphas                        4.0.0\r\ngaphor                        2.25.1    /home/dan/Projects/gaphor\r\ngeneric                       1.1.2\r\ngreenlet                      3.0.3\r\nhypothesis                    6.100.5\r\nidentify                      2.5.35\r\nidna                          3.7\r\nimagesize                     1.4.1\r\nimportlib-metadata            7.0.1\r\niniconfig                     2.0.0\r\nipykernel                     6.29.3\r\nipython                       8.24.0\r\njedi                          0.19.1\r\nJinja2                        3.1.3\r\njsonschema                    4.21.1\r\njsonschema-specifications     2023.12.1\r\njupyter-cache                 1.0.0\r\njupyter_client                8.6.0\r\njupyter_core                  5.7.1\r\nmarkdown-it-py                3.0.0\r\nMarkupSafe                    2.1.5\r\nmatplotlib-inline             0.1.6\r\nmdit-py-plugins               0.4.0\r\nmdurl                         0.1.2\r\nmyst-nb                       1.1.0\r\nmyst-parser                   2.0.0\r\nnbclient                      0.9.0\r\nnbformat                      5.9.2\r\nnest-asyncio                  1.6.0\r\nnodeenv                       1.8.0\r\npackaging                     23.2\r\nparso                         0.8.3\r\npastel                        0.2.1\r\npexpect                       4.9.0\r\npillow                        10.3.0\r\npip                           24.0\r\nplatformdirs                  4.2.0\r\npluggy                        1.5.0\r\npoethepoet                    0.26.1\r\npre-commit                    3.7.0\r\nprompt-toolkit                3.0.43\r\npsutil                        5.9.8\r\nptyprocess                    0.7.0\r\npure-eval                     0.2.2\r\npycairo                       1.26.0\r\npydot                         2.0.0\r\nPygments                      2.17.2\r\nPyGObject                     3.48.2\r\npyparsing                     3.1.1\r\npytest                        8.2.0\r\npytest-archon                 0.0.6\r\npytest-cov                    5.0.0\r\npytest-randomly               3.15.0\r\npython-dateutil               2.8.2\r\nPyYAML                        6.0.1\r\npyzmq                         25.1.2\r\nreferencing                   0.33.0\r\nrequests                      2.31.0\r\nrpds-py                       0.18.0\r\nsetuptools                    69.1.1\r\nsix                           1.16.0\r\nsnowballstemmer               2.2.0\r\nsortedcontainers              2.4.0\r\nsoupsieve                     2.5\r\nSphinx                        7.3.7\r\nsphinx-basic-ng               1.0.0b2\r\nsphinx-copybutton             0.5.2\r\nsphinx-intl                   2.2.0\r\nsphinxcontrib-applehelp       1.0.8\r\nsphinxcontrib-devhelp         1.0.6\r\nsphinxcontrib-htmlhelp        2.0.5\r\nsphinxcontrib-jsmath          1.0.1\r\nsphinxcontrib-qthelp          1.0.7\r\nsphinxcontrib-serializinghtml 1.1.10\r\nSQLAlchemy                    2.0.27\r\nstack-data                    0.6.3\r\ntabulate                      0.9.0\r\ntinycss2                      1.3.0\r\ntomli                         2.0.1\r\ntornado                       6.4\r\ntraitlets                     5.14.1\r\ntyping_extensions             4.10.0\r\nurllib3                       2.2.1\r\nvirtualenv                    20.25.1\r\nwcwidth                       0.2.13\r\nwebencodings                  0.5.1\r\nxdoctest                      1.1.3\r\nzipp                          3.17.0\r\n```\n", "hints_text": "For understanding better, can you add a step `ls -l` after the pytest run but before the cache teardown step? Actually, also before the pytest run would be helpful.\nSpecifically `ls -l /home/runner/work/gaphor/gaphor/`.\nHi @bluetech yup, let me try to build up a quick minimum reproducible repo and I'll add that as a step.\nI created a minimum reproducible example with a single test, no dependencies except for Pytest 8.2.0, on a Fedora 39 image is here:\r\nhttps://github.com/danyeaw/pytest-issue-reproduction\r\n\r\nThe list of files is:\r\n\r\n```\r\nRun ls -l -a\r\ntotal 60\r\ndrwxr-xr-x 7 root root  4096 May 14 01:56 .\r\ndrwxr-xr-x 3 1001  127  4096 May 14 01:55 ..\r\ndrwxr-xr-x 8 root root  4096 May 14 01:56 .git\r\ndrwxr-xr-x 3 root root  4096 May 14 01:56 .github\r\n-rw-r--r-- 1 root root  3078 May 14 01:56 .gitignore\r\ndrwx------ 3 root root  4096 May 14 01:56 .pytest_cache\r\ndrwxr-xr-x 5 root root  4096 May 14 01:56 .venv\r\n-rw-r--r-- 1 root root 11357 May 14 01:56 LICENSE\r\n-rw-r--r-- 1 root root   180 May 14 01:56 README.md\r\ndrwxr-xr-x 2 root root  4096 May 14 01:56 __pycache__\r\n-rw-r--r-- 1 root root  2714 May 14 01:56 poetry.lock\r\n-rw-r--r-- 1 root root   349 May 14 01:56 pyproject.toml\r\n-rw-r--r-- 1 root root   103 May 14 01:56 test_example.py\r\n```\r\n\r\nThe test run with debugging enabled is here:\r\nhttps://github.com/danyeaw/pytest-issue-reproduction/actions/runs/9072535335\nMakes sense:\r\n\r\n```\r\ndrwx------ 3 root root  4096 May 14 01:56 .pytest_cache\r\n```\r\n\r\nI assume that the `TemporaryDirectory` we're using since #12168 is creating a directory with 700 permissions, while the github cache action wants to access the directory as another user so wants 755 permissions.\r\n\r\nThe fix would be to add `path.chmod(0o755)` after [this line](https://github.com/pytest-dev/pytest/blob/ae1a47e050fcf9715dd01e6b31412d9223662b60/src/_pytest/cacheprovider.py#L215). Let me see.", "created_at": "2024-05-14T20:48:07Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12318, "instance_id": "pytest-dev__pytest-12318", "issue_numbers": ["12275"], "base_commit": "eea04c289108749ba96ed42b410baaae5932708d", "patch": "diff --git a/changelog/12275.bugfix.rst b/changelog/12275.bugfix.rst\nnew file mode 100644\nindex 00000000000..2d040a3a063\n--- /dev/null\n+++ b/changelog/12275.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix collection error upon encountering an :mod:`abstract <abc>` class, including abstract `unittest.TestCase` subclasses.\n", "test_patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 68eceb7f4f3..5196b9fe891 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -368,7 +368,11 @@ def istestfunction(self, obj: object, name: str) -> bool:\n             return False\n \n     def istestclass(self, obj: object, name: str) -> bool:\n-        return self.classnamefilter(name) or self.isnosetest(obj)\n+        if not (self.classnamefilter(name) or self.isnosetest(obj)):\n+            return False\n+        if inspect.isabstract(obj):\n+            return False\n+        return True\n \n     def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:\n         \"\"\"Check if the given name matches the prefix or glob-pattern defined\ndiff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 8f1791bf744..919b497c295 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -1,6 +1,7 @@\n # mypy: allow-untyped-defs\n \"\"\"Discover and run std-library \"unittest\" style tests.\"\"\"\n \n+import inspect\n import sys\n import traceback\n import types\n@@ -49,14 +50,19 @@\n def pytest_pycollect_makeitem(\n     collector: Union[Module, Class], name: str, obj: object\n ) -> Optional[\"UnitTestCase\"]:\n-    # Has unittest been imported and is obj a subclass of its TestCase?\n     try:\n+        # Has unittest been imported?\n         ut = sys.modules[\"unittest\"]\n+        # Is obj a subclass of unittest.TestCase?\n         # Type ignored because `ut` is an opaque module.\n         if not issubclass(obj, ut.TestCase):  # type: ignore\n             return None\n     except Exception:\n         return None\n+    # Is obj a concrete class?\n+    # Abstract classes can't be instantiated so no point collecting them.\n+    if inspect.isabstract(obj):\n+        return None\n     # Yes, so let's collect it.\n     return UnitTestCase.from_parent(collector, name=name, obj=obj)\n \ndiff --git a/testing/python/collect.py b/testing/python/collect.py\nindex a1a7dc8978d..843fa3c0e6b 100644\n--- a/testing/python/collect.py\n+++ b/testing/python/collect.py\n@@ -262,6 +262,32 @@ def prop(self):\n         result = pytester.runpytest()\n         assert result.ret == ExitCode.NO_TESTS_COLLECTED\n \n+    def test_abstract_class_is_not_collected(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #12275 (non-unittest version).\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import abc\n+\n+            class TestBase(abc.ABC):\n+                @abc.abstractmethod\n+                def abstract1(self): pass\n+\n+                @abc.abstractmethod\n+                def abstract2(self): pass\n+\n+                def test_it(self): pass\n+\n+            class TestPartial(TestBase):\n+                def abstract1(self): pass\n+\n+            class TestConcrete(TestPartial):\n+                def abstract2(self): pass\n+            \"\"\"\n+        )\n+        result = pytester.runpytest()\n+        assert result.ret == ExitCode.OK\n+        result.assert_outcomes(passed=1)\n+\n \n class TestFunction:\n     def test_getmodulecollector(self, pytester: Pytester) -> None:\ndiff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex d726e74d603..f73e083be78 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1640,3 +1640,31 @@ def test_it2(self): pass\n     assert skipped == 1\n     assert failed == 0\n     assert reprec.ret == ExitCode.NO_TESTS_COLLECTED\n+\n+\n+def test_abstract_testcase_is_not_collected(pytester: Pytester) -> None:\n+    \"\"\"Regression test for #12275.\"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import abc\n+        import unittest\n+\n+        class TestBase(unittest.TestCase, abc.ABC):\n+            @abc.abstractmethod\n+            def abstract1(self): pass\n+\n+            @abc.abstractmethod\n+            def abstract2(self): pass\n+\n+            def test_it(self): pass\n+\n+        class TestPartial(TestBase):\n+            def abstract1(self): pass\n+\n+        class TestConcrete(TestPartial):\n+            def abstract2(self): pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest()\n+    assert result.ret == ExitCode.OK\n+    result.assert_outcomes(passed=1)\n", "problem_statement": "v8.2.0 raises `Can't instantiate abstract class` when a test class implements an abstract class\nBefore, we could have a test class inheriting from an ABC (and unittest.TestCase), now it errors because pytest is trying to instantiate the ABC itself. Running pytest should only instantiate the child test class (which indeed implements all the abstract methods of its ABC parent).\r\nThis issue does not appear in v8.1.2 and was likely introduced in https://github.com/pytest-dev/pytest/pull/12089.\r\n\r\nMinimal example:\r\n```python\r\nfrom abc import ABC, abstractmethod\r\nfrom unittest import TestCase\r\n\r\n\r\nclass Base(TestCase, ABC):\r\n    @abstractmethod\r\n    def foo(self): ...\r\n\r\n\r\nclass Tests(Base):\r\n\r\n    def foo(self): ...\r\n\r\n    def test(self): ...\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n(test) tests \ud83d\udd25pytest test.py    \r\n============================================================================= test session starts ==============================================================================\r\nplatform darwin -- Python 3.9.19, pytest-8.2.0, pluggy-1.5.0\r\nrootdir: ...\r\nconfigfile: pytest.ini\r\nplugins: env-1.1.3\r\ncollected 1 item / 1 error                                                                                                                                                     \r\n\r\n==================================================================================== ERRORS ====================================================================================\r\n________________________________________________________________ ERROR collecting test.py ________________________________________________________________\r\n/Users/martin/miniconda3/envs/test/lib/python3.9/site-packages/_pytest/runner.py:341: in from_call\r\n    result: Optional[TResult] = func()\r\n/Users/martin/miniconda3/envs/test/lib/python3.9/site-packages/_pytest/runner.py:389: in collect\r\n    return list(collector.collect())\r\n/Users/martin/miniconda3/envs/test/lib/python3.9/site-packages/_pytest/unittest.py:90: in collect\r\n    self.session._fixturemanager.parsefactories(self.newinstance(), self.nodeid)\r\n/Users/martin/miniconda3/envs/test/lib/python3.9/site-packages/_pytest/unittest.py:75: in newinstance\r\n    return self.obj(\"runTest\")\r\nE   TypeError: Can't instantiate abstract class Base with abstract method foo\r\n=========================================================================== short test summary info ============================================================================\r\nERROR test.py::Base - TypeError: Can't instantiate abstract class Base with abstract method foo\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n=============================================================================== 1 error in 0.04s ===============================================================================\r\n```\r\n\r\npip list:\r\n\r\n```\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.1\r\niniconfig      2.0.0\r\npackaging      24.0\r\npip            23.3.1\r\npluggy         1.5.0\r\npytest         8.2.0\r\npytest-env     1.1.3\r\nsetuptools     68.2.2\r\ntomli          2.0.1\r\nwheel          0.41.2\r\n```\r\nThanks for your work in general, it's a great package.\n", "hints_text": "Your suspicion is correct, a bisect indeed points to 1a5e0eb71d2af0ad113ccd9ee596c7d724d7a4b6.\nThanks for the report. I agree that what you're doing is very reasonable and should work.\r\n\r\nUntil we have some fix for this, if you want to remove the pin, a workaround would be to drop this snippet to a conftest.py file in the directory where the abc is defined:\r\n\r\n```py\r\nimport inspect\r\n\r\ndef pytest_pycollect_makeitem(collector, name, obj):\r\n    if inspect.isabstract(obj):\r\n        return []\r\n```", "created_at": "2024-05-13T10:01:29Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12311, "instance_id": "pytest-dev__pytest-12311", "issue_numbers": ["12120"], "base_commit": "5af46f3d4e8264c50ffd635dbb395199670e70b7", "patch": "diff --git a/changelog/12120.bugfix.rst b/changelog/12120.bugfix.rst\nnew file mode 100644\nindex 00000000000..b1ca4913b37\n--- /dev/null\n+++ b/changelog/12120.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix `PermissionError` crashes arising from directories which are not selected on the command-line.\n", "test_patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 68eceb7f4f3..8efaf80787a 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -176,7 +176,12 @@ def pytest_collect_directory(\n     path: Path, parent: nodes.Collector\n ) -> Optional[nodes.Collector]:\n     pkginit = path / \"__init__.py\"\n-    if pkginit.is_file():\n+    try:\n+        has_pkginit = pkginit.is_file()\n+    except PermissionError:\n+        # See https://github.com/pytest-dev/pytest/issues/12120#issuecomment-2106349096.\n+        return None\n+    if has_pkginit:\n         return Package.from_parent(parent, path=path)\n     return None\n \ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex 995e2999bbe..8ff38a334f4 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -285,6 +285,23 @@ def test_testpaths_ini(self, pytester: Pytester, monkeypatch: MonkeyPatch) -> No\n             items, reprec = pytester.inline_genitems()\n             assert [x.name for x in items] == [f\"test_{dirname}\"]\n \n+    def test_missing_permissions_on_unselected_directory_doesnt_crash(\n+        self, pytester: Pytester\n+    ) -> None:\n+        \"\"\"Regression test for #12120.\"\"\"\n+        test = pytester.makepyfile(test=\"def test(): pass\")\n+        bad = pytester.mkdir(\"bad\")\n+        try:\n+            bad.chmod(0)\n+\n+            result = pytester.runpytest(test)\n+        finally:\n+            bad.chmod(750)\n+            bad.rmdir()\n+\n+        assert result.ret == ExitCode.OK\n+        result.assert_outcomes(passed=1)\n+\n \n class TestCollectPluginHookRelay:\n     def test_pytest_collect_file(self, pytester: Pytester) -> None:\n", "problem_statement": "Pytest crashes if there is a subdirectory it does not have read access to\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\nPytest crashes if there is a subdirectory it does not have read access to.\r\n\r\nFor example:\r\n\r\n```bash\r\nrm -rf .venv chaff tests\r\nvirtualenv -p python3.10 .venv\r\nsource .venv/bin/activate\r\npip install pytest\r\npip list\r\nmkdir chaff\r\nmkdir tests\r\ncat <<EOF > tests/test_something.py\r\ndef test_something() -> None:\r\n    pass\r\nEOF\r\npytest tests\r\nchmod a-rwx chaff\r\npytest tests\r\n```\r\n\r\nyields:\r\n\r\n```\r\ncreated virtual environment CPython3.10.12.final.0-64 in 70ms\r\n  creator CPython3Posix(dest=/home/jn/src/pytesttest/.venv, clear=False, no_vcs_ignore=False, global=False)\r\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/home/jn/.local/share/virtualenv)\r\n    added seed packages: pip==22.0.2, setuptools==59.6.0, wheel==0.37.1\r\n  activators BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator\r\n\r\n<snip pip installation stuff...>\r\n\r\nInstalling collected packages: tomli, pluggy, packaging, iniconfig, exceptiongroup, pytest\r\nSuccessfully installed exceptiongroup-1.2.0 iniconfig-2.0.0 packaging-24.0 pluggy-1.4.0 pytest-8.1.1 tomli-2.0.1\r\n\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      24.0\r\npip            22.0.2\r\npluggy         1.4.0\r\npytest         8.1.1\r\nsetuptools     59.6.0\r\ntomli          2.0.1\r\nwheel          0.37.1\r\n\r\n=================================================================================================================== test session starts ====================================================================================================================\r\nplatform linux -- Python 3.10.12, pytest-8.1.1, pluggy-1.4.0 -- /home/jn/src/pytesttest/.venv/bin/python\r\ncachedir: .pytest_cache\r\nrootdir: /home/jn/src/pytesttest\r\ncollected 1 item\r\n\r\ntests/test_something.py::test_something PASSED\r\n\r\n==================================================================================================================== 1 passed in 0.00s =====================================================================================================================\r\n\r\n=================================================================================================================== test session starts ====================================================================================================================\r\nplatform linux -- Python 3.10.12, pytest-8.1.1, pluggy-1.4.0 -- /home/jn/src/pytesttest/.venv/bin/python\r\ncachedir: .pytest_cache\r\nrootdir: /home/jn/src/pytesttest\r\ncollected 0 items / 1 error\r\n\r\n========================================================================================================================== ERRORS ==========================================================================================================================\r\n____________________________________________________________________________________________________________________ ERROR collecting . ____________________________________________________________________________________________________________________\r\n.venv/lib/python3.10/site-packages/pluggy/_hooks.py:501: in __call__\r\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\r\n.venv/lib/python3.10/site-packages/pluggy/_manager.py:119: in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n.venv/lib/python3.10/site-packages/_pytest/python.py:212: in pytest_collect_directory\r\n    if pkginit.is_file():\r\n/usr/lib/python3.10/pathlib.py:1322: in is_file\r\n    return S_ISREG(self.stat().st_mode)\r\n/usr/lib/python3.10/pathlib.py:1097: in stat\r\n    return self._accessor.stat(self, follow_symlinks=follow_symlinks)\r\nE   PermissionError: [Errno 13] Permission denied: '/home/jn/src/pytesttest/chaff/__init__.py'\r\n================================================================================================================= short test summary info ==================================================================================================================\r\nERROR . - PermissionError: [Errno 13] Permission denied: '/home/jn/src/pytesttest/chaff/__init__.py'\r\n===================================================================================================================== 1 error in 0.04s =====================================================================================================================\r\nERROR: found no collectors for /home/jn/src/pytesttest/tests\r\n```\r\n\r\nI do not believe pytest should be this sensitive to what other subdirectories there might exist.\r\n\r\nThis is run under Ubuntu 22.04.3 LTS under WSL.\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\n", "hints_text": "What is the reason for having inaccessible files in the workspace? Trying to understand if this is something that you intentionally do.\nIt's some Docker containers with some databases we use for testing, that has a mounted volume that ends up belonging to another user. We probably could change that if we were sufficiently motivated, but in either case pytest shouldn't crash just because there's a directory it does not have read access to.\n@bluetech the regression (that was added by introducing Directories as is) is that we now collect multiple folders just to get to the given testdirs\r\n\r\n@jesnie can you try if a collect ignore is a sufficient workaround for now\r\n\r\n@bluetech i believe there is a need to ensure collect-towards for testpaths and/or test ids will in fact not look in other places that may trigger permission errors\nSorry about the late reply, but I've been on a small vacation.\r\nAdding a `--ignore` for the relevant subdirectory does seem to prevent the crash.\n@RonnyPfannschmidt can you not just put a `try ... except` around the relevant code and catch any permission errors?\n### Problem\r\n\r\n- When running `pytest a/b/c.py`, the `.`, `a` and `a/b` directories or packages are collected as part of building the collection tree.\r\n- When a directory is collected, it collects all files/dirs in it, including ones that will be filtered out, e.g. `a/mysecretdir` (the filtering happens separately later).\r\n- In the python.py plugin's `pytest_collect_directory` hookimpl, we are checking if `a/mysecretdir` is a `Package` by checking whether it contains an `__init__.py` file.\r\n- If the user doesn't have rx permission on `a/mysecretdir`, the collection fails, even though the user didn't select this directory at all.\r\n\r\nWe've had a bunch of issues about this, as far as I can see the issue mainly comes up in these two scenarios:\r\n\r\n- Users collecting a test in `/tmp`, which often has non-user-owned dirs. I think doing this is a bad idea -- some other user can drop a conftest.py file and execute stuff as the pytest user -- but who am I to judge.\r\n\r\n- Some Docker or such tool leaving root or service-user owned files in the project directory.\r\n\r\n### Proposed Solution\r\n\r\nI don't have a great proper solution, so for now I suggest we catch `PermissionError` in the `pytest_collect_directory` for `Package`s, and say it's not a package if so. This means it will be collected as a `Dir`. I think this is fine:\r\n\r\n- If the directory is selected, it will still fail a bit later when trying to run `collect()` on the `Dir` node. This is good, we want it to fail if it's actually selected.\r\n- If the directory is not selected, then it doesn't matter anyway.\r\n\r\nOK, so the last point is not 100% right, it might matter if a plugin hooks into the right place etc. That's why I'm not intellectually satisfied with this solution. But practicality beats purity, and practically I don't think anyone will ever notice.\r\n\r\n### Rejected Solution\r\n\r\nBefore pytest 8, the problem didn't happen because directory collection was \"centralized\" in `Session` which did the filtering *during* the collection. In pytest 8 we delegated the collection to the `Directory` nodes (`Dir`/`Package` are the built-in concrete ones).\r\n\r\nThe new scheme is IMO simpler and more pytest-y, and it unlocked further simplifications and optimizations (mostly around conftest loading), and also custom directory node support. So I don't think we want to go back.\r\n\r\nPossibly there's a way to keep the new scheme but also delegate the filtering, thus fixing the problem properly. If a future human or machine reads this and comes up with a proposal to do this, that'd be cool :)", "created_at": "2024-05-12T19:42:50Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12301, "instance_id": "pytest-dev__pytest-12301", "issue_numbers": ["12300"], "base_commit": "d49f1fc4dbf9e04da016335d9e82527423d9ad1f", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 4619cf1bc44..54ed85fc732 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -441,6 +441,7 @@ Yao Xiao\n Yoav Caspi\n Yuliang Shao\n Yusuke Kadowaki\n+Yutian Li\n Yuval Shimon\n Zac Hatfield-Dodds\n Zachary Kneupper\ndiff --git a/changelog/12300.bugfix.rst b/changelog/12300.bugfix.rst\nnew file mode 100644\nindex 00000000000..6c162482022\n--- /dev/null\n+++ b/changelog/12300.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed handling of 'Function not implemented' error under squashfuse_ll, which is a different way to say that the mountpoint is read-only.\n", "test_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex b6f14aa9294..3d5df0d6c34 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -1171,7 +1171,10 @@ def try_makedirs(cache_dir: Path) -> bool:\n         return False\n     except OSError as e:\n         # as of now, EROFS doesn't have an equivalent OSError-subclass\n-        if e.errno == errno.EROFS:\n+        #\n+        # squashfuse_ll returns ENOSYS \"OSError: [Errno 38] Function not\n+        # implemented\" for a read-only error\n+        if e.errno in {errno.EROFS, errno.ENOSYS}:\n             return False\n         raise\n     return True\ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex bedf6e27606..82c7055b968 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1972,6 +1972,11 @@ def fake_mkdir(p, exist_ok=False, *, exc):\n     monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=err))\n     assert not try_makedirs(p)\n \n+    err = OSError()\n+    err.errno = errno.ENOSYS\n+    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=err))\n+    assert not try_makedirs(p)\n+\n     # unhandled OSError should raise\n     err = OSError()\n     err.errno = errno.ECHILD\n", "problem_statement": "Crashing under a squashfuse_ll read-only mount\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n## a detailed description of the bug or problem you are having\r\npytest is crashing with `OSError: [Errno 38] Function not implemented` when it's run under a squashfuse_ll mountpoint. the exception comes from within \r\n```\r\n_pytest/assertion/rewrite.py:1102: in try_makedirs\r\n    os.makedirs(cache_dir, exist_ok=True)\r\n```\r\n\r\nthis is because squashfuse_ll returns ENOSYS instead of EROFS for a read-only filesystem, which pytest doesn't know how to handle\r\n\r\n## pytest and operating system versions\r\nd49f1fc4dbf9e04da016335d9e82527423d9ad1f (main as of Wed May 8 10:13:30 2024 -0300)\r\n\r\n\n", "hints_text": "", "created_at": "2024-05-09T01:01:30Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12279, "instance_id": "pytest-dev__pytest-12279", "issue_numbers": ["11706"], "base_commit": "1385ec117d651bc86cff16db66b8cfa68d27fc1f", "patch": "diff --git a/changelog/11706.bugfix.rst b/changelog/11706.bugfix.rst\nnew file mode 100644\nindex 00000000000..a86db5ef66a\n--- /dev/null\n+++ b/changelog/11706.bugfix.rst\n@@ -0,0 +1,4 @@\n+Fix reporting of teardown errors in higher-scoped fixtures when using `--maxfail` or `--stepwise`.\n+\n+Originally added in pytest 8.0.0, but reverted in 8.0.2 due to a regression in pytest-xdist.\n+This regression was fixed in pytest-xdist 3.6.1.\n", "test_patch": "diff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex 5b7cd3e1dad..dfefa73b72d 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -134,6 +134,10 @@ def runtestprotocol(\n             show_test_item(item)\n         if not item.config.getoption(\"setuponly\", False):\n             reports.append(call_and_report(item, \"call\", log))\n+    # If the session is about to fail or stop, teardown everything - this is\n+    # necessary to correctly report fixture teardown errors (see #11706)\n+    if item.session.shouldfail or item.session.shouldstop:\n+        nextitem = None\n     reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n     # After all teardown hooks have been called\n     # want funcargs and request info to go away.\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 6bd4a045db6..436ce2f1062 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -1216,3 +1216,53 @@ def test():\n     result = pytester.runpytest_inprocess()\n     assert result.ret == ExitCode.OK\n     assert os.environ[\"PYTEST_VERSION\"] == \"old version\"\n+\n+\n+def test_teardown_session_failed(pytester: Pytester) -> None:\n+    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n+    item after the test session bails early due to --maxfail.\n+\n+    Regression test for #11706.\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.fixture(scope=\"module\")\n+        def baz():\n+            yield\n+            pytest.fail(\"This is a failing teardown\")\n+\n+        def test_foo(baz):\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--maxfail=1\")\n+    result.assert_outcomes(failed=1, errors=1)\n+\n+\n+def test_teardown_session_stopped(pytester: Pytester) -> None:\n+    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n+    item after the test session bails early due to --stepwise.\n+\n+    Regression test for #11706.\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.fixture(scope=\"module\")\n+        def baz():\n+            yield\n+            pytest.fail(\"This is a failing teardown\")\n+\n+        def test_foo(baz):\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--stepwise\")\n+    result.assert_outcomes(failed=1, errors=1)\n", "problem_statement": "Pytest aborts when fixture errors during teardown and `--maxfail=1`\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\n## Description\r\n\r\nPytest aborts if a session-scoped fixture errors during teardown when (a) one or more test cases fail and (b) `--maxfail=1` is used.\r\n\r\nWhen this happens, `test-report.xml` does not contain the teardown fixture error. This is problematic as users may want to also record teardown fixture errors when their test cases fail.\r\n\r\n## Minimal Example\r\n\r\n### Code\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\ndef some_condition() -> bool:\r\n    return True\r\n\r\n\r\n@pytest.fixture(scope=\"session\", autouse=True)\r\ndef my_end_of_session_check():\r\n    yield\r\n\r\n    print(\"Running end of session check!\")\r\n    if some_condition():\r\n        pytest.fail(\"Oh noes\")\r\n\r\n\r\ndef test_case_1():\r\n    pytest.fail(\"This is a failing test\")\r\n\r\n\r\ndef test_case_2():\r\n     pytest.fail(\"This is also a failing test\")\r\n```\r\n\r\n### Args\r\n\r\n`pytest example.py --maxfail=1 --junitxml=test-report.xml`\r\n\r\n### Output\r\n\r\nConsole:\r\n\r\n```txt\r\n============================================================================== test session starts ===============================================================================\r\nplatform darwin -- Python 3.8.13, pytest-7.4.3, pluggy-1.3.0\r\nrootdir: /Users/bbrown/Downloads\r\ncollected 2 items\r\n\r\nexample.py FRunning end of session check!\r\nTraceback (most recent call last):\r\n  File \"/Users/bbrown/Downloads/.venv/bin/pytest\", line 8, in <module>\r\n    sys.exit(console_main())\r\n  <clipped>\r\n  File \"/Users/bbrown/Downloads/.venv/lib/python3.8/site-packages/_pytest/fixtures.py\", line 911, in _teardown_yield_fixture\r\n    next(it)\r\n  File \"/Users/bbrown/Downloads/example.py\", line 14, in my_end_of_session_check\r\n    pytest.fail(\"Oh noes\")\r\n  File \"/Users/bbrown/Downloads/.venv/lib/python3.8/site-packages/_pytest/outcomes.py\", line 198, in fail\r\n    raise Failed(msg=reason, pytrace=pytrace)\r\nFailed: Oh noes\r\n```\r\n\r\n`test-report.xml`:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites><testsuite name=\"pytest\" errors=\"0\" failures=\"1\" skipped=\"0\" tests=\"1\" time=\"0.035\" timestamp=\"2023-12-15T08:56:19.980572\" hostname=\"macbookpro\"><testcase classname=\"example\" name=\"test_case_1\" time=\"0.001\"><failure message=\"Failed: This is a failing test\">def test_case_1():\r\n&gt;       pytest.fail(\"This is a failing test\")\r\nE       Failed: This is a failing test\r\n\r\nexample.py:18: Failed</failure></testcase></testsuite></testsuites>\r\n```\r\n\r\n### Expected Output\r\n\r\nI expect pytest to not abort, and report \"1 failed, 1 error, 1 skipped\" in both the console and `test-report.xml` when this happens.\r\n\r\n### Environment\r\n\r\n__OS:__\r\n\r\nmacOS Sonoma 14.1.2\r\n\r\n__Virtual environment:__\r\n\r\n```txt\r\n(.venv) % pip list\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            23.3.1\r\npluggy         1.3.0\r\npytest         7.4.3\r\nsetuptools     56.0.0\r\ntomli          2.0.1\r\n```\n", "hints_text": "Note that this also happens when the fixture is `module` scoped, but does _not_ happen if the fixture is `function` scoped. Will update the issue name to indicate this.\nThis is an interesting edge case you've stumbled upon.\r\n\r\n### Background\r\n\r\npytest's setups/teardowns are managed by the [`SetupState`](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/runner.py#L401) class.\r\n\r\nYou can see the docstring for how it works, but the important part here is that we're tearing down some `item` (test), we look at the next item (`nextitem`), see which fixtures the nextitem won't be needing, and tear them down in the context of `item`. In particular, the last item gets `nextitem = None` which tears down everything.\r\n\r\nWhen `--maxfail=N` is used (or `-x` which is alias for `--maxfail=1`), if the N failures are reached, the runner [sets `session.shouldfail = ...`](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/main.py#L547-L548C20), then the runner loop checks it and [exits the loop](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/main.py#L355-L356).\r\n\r\n### Problem\r\n\r\nLet's call the Nth failing test \"test N\" and assume there is at least one test after it, \"test N + 1\", which shares some higher-scoped fixtures.\r\n\r\n\"test N\" is torn down with `nextitem = test N + 1`, then `shouldfail` is set and the loop exits. But, all of the remaining fixtures weren't torn down because nothing told them to.\r\n\r\nTo fix this, pytest in a last ditch effort runs the remaining teardowns in a [`pytest_sessionfinish` hook](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/runner.py#L106-L107). \r\n\r\nBut this `pytest_sessionfinish` hook currently is not written to handle exceptions, except for `pytest.exit`, even though it executes user code. So if one of the remaining teardowns raises, the exception just propagates.\r\n\r\n### Possible solution 1\r\n\r\nCatch the exceptions from the `pytest_sessionfinish` and issue some warning.\r\n\r\nThis would work, however then the teardown failures aren't reported in the context of any test. In particular they won't show in any xml reports and such.\r\n\r\n### Possible solution 2\r\n\r\nDetect when an item had set `shouldfail = True`, then instead of tearing it down with `nextitem = item N+1`, tear it down with `nextitem = None`.\r\n\r\nThis would work and run the teardowns in the context of the test, but is a bit dangerous - doesn't handle the case where plugins reset `shouldfail`. Also, I think there are other cases where we bail early, those would still need `pytest_sessionfinish` and the problem would still be possible there.\nThanks for the detailed reply @bluetech! \r\n\r\nThe real pain point here is the lack of reporting - my team's observability tools consume `test-report.xml` and want all errors/failures to be reported such that we can triage them. Because of that, I'll try to investigate _Possible solution 2_ you've outlined above.\n> Detect when an item had set shouldfail = True, then instead of tearing it down with nextitem = item N+1, tear it down with nextitem = None.\r\n\r\nThis was pretty easy to implement, basically a one-line change in `pytest_runtest_teardown`:\r\n\r\n```python\r\ndef pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\r\n    _update_current_test_var(item, \"teardown\")\r\n    nextitem = None if item.session.shouldfail else nextitem\r\n    item.session._setupstate.teardown_exact(nextitem)\r\n    _update_current_test_var(item, None)\r\n```\r\n\r\nI also added a unittest in `test_runner.py` mimicking the sample code above. I can open a PR with this change, however I'm not sure what to do about these comments:\r\n\r\n> This would work and run the teardowns in the context of the test, but is a bit dangerous - doesn't handle the case where plugins reset shouldfail. \r\n\r\nA plugin resetting `shouldfail` feels like even more of an edge-case, not sure if we should be that concerned about it?\r\n\r\n> Also, I think there are other cases where we bail early, those would still need pytest_sessionfinish and the problem would still be possible there.\r\n\r\nI'm not really following this comment, likely just due to my lack of context about the codebase.\r\n\nReopening since the fix was reverted.\n@bluetech do you think we can \"revert the revert\" (93cd7ba857471dc9f2322246f37ec5eb10cbc91c) now that we have a fix in `pytest-xdist`? Or will we need to wait for a release of `pytest-xdist`?\nLet's wait for a pytest-xdist release as there is no rush on the pytest side (there's probably some time until we release 8.2).\r\n\r\nI think we will do a pytest-xdist release soon (once we tie up so some typing changes there). I will notify you when we can reapply the fix here (unless I forget...).\r\n\r\nI do foresee we'll get some complaints from users who will be using new pytest with old pytest-xdist, since we can't use dependency constraints to prevent this scenario, but that's OK.\n> I think we will do a pytest-xdist release soon (once we tie up so some typing changes there). I will notify you when we can reapply the fix here (unless I forget...).\r\n\r\n@bbrown1867 We has some issues with the 3.6.0 xdist release which had to be yanked, but I released 3.6.1 now and hopefully it'd be fine. So we can proceed on the pytest side.\nOkay sounds good, I'll open a PR to revert 4cc87ad1f6b3bc694ecdbf5567902aeecb03783d", "created_at": "2024-05-01T16:17:54Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12264, "instance_id": "pytest-dev__pytest-12264", "issue_numbers": ["12204"], "base_commit": "127a372928cb68e2023ae3c6f8b407c4d2f1f2f7", "patch": "diff --git a/changelog/12204.bugfix.rst b/changelog/12204.bugfix.rst\nnew file mode 100644\nindex 00000000000..9690f513a38\n--- /dev/null\n+++ b/changelog/12204.bugfix.rst\n@@ -0,0 +1,7 @@\n+Fix a regression in pytest 8.0 where tracebacks get longer and longer when multiple tests fail due to a shared higher-scope fixture which raised.\n+\n+Also fix a similar regression in pytest 5.4 for collectors which raise during setup.\n+\n+The fix necessitated internal changes which may affect some plugins:\n+- ``FixtureDef.cached_result[2]`` is now a tuple ``(exc, tb)`` instead of ``exc``.\n+- ``SetupState.stack`` failures are now a tuple ``(exc, tb)`` instead of ``exc``.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 09fd07422fc..5f10d565f32 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -8,6 +8,7 @@\n import os\n from pathlib import Path\n import sys\n+import types\n from typing import AbstractSet\n from typing import Any\n from typing import Callable\n@@ -104,8 +105,8 @@\n         None,\n         # Cache key.\n         object,\n-        # Exception if raised.\n-        BaseException,\n+        # The exception and the original traceback.\n+        Tuple[BaseException, Optional[types.TracebackType]],\n     ],\n ]\n \n@@ -1049,8 +1050,8 @@ def execute(self, request: SubRequest) -> FixtureValue:\n             # numpy arrays (#6497).\n             if my_cache_key is cache_key:\n                 if self.cached_result[2] is not None:\n-                    exc = self.cached_result[2]\n-                    raise exc\n+                    exc, exc_tb = self.cached_result[2]\n+                    raise exc.with_traceback(exc_tb)\n                 else:\n                     result = self.cached_result[0]\n                     return result\n@@ -1126,7 +1127,7 @@ def pytest_fixture_setup(\n             # Don't show the fixture as the skip location, as then the user\n             # wouldn't know which test skipped.\n             e._use_item_location = True\n-        fixturedef.cached_result = (None, my_cache_key, e)\n+        fixturedef.cached_result = (None, my_cache_key, (e, e.__traceback__))\n         raise\n     fixturedef.cached_result = (result, my_cache_key, None)\n     return result\ndiff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex a551f715aa8..bf4d9a37f60 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -5,6 +5,7 @@\n import dataclasses\n import os\n import sys\n+import types\n from typing import Callable\n from typing import cast\n from typing import Dict\n@@ -488,8 +489,13 @@ def __init__(self) -> None:\n             Tuple[\n                 # Node's finalizers.\n                 List[Callable[[], object]],\n-                # Node's exception, if its setup raised.\n-                Optional[Union[OutcomeException, Exception]],\n+                # Node's exception and original traceback, if its setup raised.\n+                Optional[\n+                    Tuple[\n+                        Union[OutcomeException, Exception],\n+                        Optional[types.TracebackType],\n+                    ]\n+                ],\n             ],\n         ] = {}\n \n@@ -502,7 +508,7 @@ def setup(self, item: Item) -> None:\n         for col, (finalizers, exc) in self.stack.items():\n             assert col in needed_collectors, \"previous item was not torn down properly\"\n             if exc:\n-                raise exc\n+                raise exc[0].with_traceback(exc[1])\n \n         for col in needed_collectors[len(self.stack) :]:\n             assert col not in self.stack\n@@ -511,7 +517,7 @@ def setup(self, item: Item) -> None:\n             try:\n                 col.setup()\n             except TEST_OUTCOME as exc:\n-                self.stack[col] = (self.stack[col][0], exc)\n+                self.stack[col] = (self.stack[col][0], (exc, exc.__traceback__))\n                 raise\n \n     def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 12ca6e92630..77914fed75d 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -3397,6 +3397,28 @@ def test_something():\n             [\"*def gen(qwe123):*\", \"*fixture*qwe123*not found*\", \"*1 error*\"]\n         )\n \n+    def test_cached_exception_doesnt_get_longer(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #12204.\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+            @pytest.fixture(scope=\"session\")\n+            def bad(): 1 / 0\n+\n+            def test_1(bad): pass\n+            def test_2(bad): pass\n+            def test_3(bad): pass\n+            \"\"\"\n+        )\n+\n+        result = pytester.runpytest_inprocess(\"--tb=native\")\n+        assert result.ret == ExitCode.TESTS_FAILED\n+        failures = result.reprec.getfailures()  # type: ignore[attr-defined]\n+        assert len(failures) == 3\n+        lines1 = failures[1].longrepr.reprtraceback.reprentries[0].lines\n+        lines2 = failures[2].longrepr.reprtraceback.reprentries[0].lines\n+        assert len(lines1) == len(lines2)\n+\n \n class TestShowFixtures:\n     def test_funcarg_compat(self, pytester: Pytester) -> None:\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 8b41ec28a38..ecb98f2ffc2 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -142,6 +142,43 @@ def raiser(exc):\n         assert isinstance(func.exceptions[0], TypeError)  # type: ignore\n         assert isinstance(func.exceptions[1], ValueError)  # type: ignore\n \n+    def test_cached_exception_doesnt_get_longer(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #12204 (the \"BTW\" case).\"\"\"\n+        pytester.makepyfile(test=\"\")\n+        # If the collector.setup() raises, all collected items error with this\n+        # exception.\n+        pytester.makeconftest(\n+            \"\"\"\n+            import pytest\n+\n+            class MyItem(pytest.Item):\n+                def runtest(self) -> None: pass\n+\n+            class MyBadCollector(pytest.Collector):\n+                def collect(self):\n+                    return [\n+                        MyItem.from_parent(self, name=\"one\"),\n+                        MyItem.from_parent(self, name=\"two\"),\n+                        MyItem.from_parent(self, name=\"three\"),\n+                    ]\n+\n+                def setup(self):\n+                    1 / 0\n+\n+            def pytest_collect_file(file_path, parent):\n+                if file_path.name == \"test.py\":\n+                    return MyBadCollector.from_parent(parent, name='bad')\n+            \"\"\"\n+        )\n+\n+        result = pytester.runpytest_inprocess(\"--tb=native\")\n+        assert result.ret == ExitCode.TESTS_FAILED\n+        failures = result.reprec.getfailures()  # type: ignore[attr-defined]\n+        assert len(failures) == 3\n+        lines1 = failures[1].longrepr.reprtraceback.reprentries[0].lines\n+        lines2 = failures[2].longrepr.reprtraceback.reprentries[0].lines\n+        assert len(lines1) == len(lines2)\n+\n \n class BaseFunctionalTests:\n     def test_passfunction(self, pytester: Pytester) -> None:\n", "problem_statement": "ExceptionGroup traceback of session fixture unlimitedly grows from test to test\nMy session fixture can raise `ExceptionGroup` and I see huge traceback which grows unlimitedly from test to test.\r\n\r\npip list:\r\n```\r\niniconfig 2.0.0  \r\npackaging 24.0   \r\npluggy    1.4.0  \r\npytest    8.1.1 \r\n```\r\n\r\nOperation system: macOS 14.3\r\nPython: 3.12.0\r\n\r\nExample:\r\n```python\r\nimport pytest\r\n\r\n@pytest.fixture(scope='session', autouse=True)\r\ndef f1():\r\n    raise ExceptionGroup('', [ValueError()])\r\n\r\ndef test_smth1():\r\n    pass\r\n\r\ndef test_smth2():\r\n    pass\r\n\r\ndef test_smth3():\r\n    pass\r\n```\r\n\r\nWith such code I get 495 lines of logs:\r\n\r\n<details><summary>Details</summary>\r\n<pre><code>\r\n============================= test session starts ==============================\r\nplatform darwin -- Python 3.12.0, pytest-8.0.0, pluggy-1.3.0\r\nrootdir: /Users/tkukushkin/Projects/test/tests\r\nconfigfile: pytest.ini\r\nplugins: cov-4.1.0\r\ncollected 3 items\r\n\r\ntests/test_foo.py EEE                                                    [100%]\r\n\r\n==================================== ERRORS ====================================\r\n_________________________ ERROR at setup of test_smth1 _________________________\r\n  + Exception Group Traceback (most recent call last):\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1095, in execute\r\n  |     result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/setuponly.py\", line 36, in pytest_fixture_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1149, in pytest_fixture_setup\r\n  |     result = call_fixture_func(fixturefunc, request, kwargs)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 923, in call_fixture_func\r\n  |     fixture_result = fixturefunc(**kwargs)\r\n  |                      ^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/Projects/test/tests/test_foo.py\", line 6, in f1\r\n  |     raise ExceptionGroup('', [ValueError('foo')])\r\n  | ExceptionGroup:  (1 sub-exception)\r\n  +-+---------------- 1 ----------------\r\n    | ValueError: foo\r\n    +------------------------------------\r\n_________________________ ERROR at setup of test_smth2 _________________________\r\n  + Exception Group Traceback (most recent call last):\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1085, in execute\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1095, in execute\r\n  |     result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/setuponly.py\", line 36, in pytest_fixture_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1149, in pytest_fixture_setup\r\n  |     result = call_fixture_func(fixturefunc, request, kwargs)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 923, in call_fixture_func\r\n  |     fixture_result = fixturefunc(**kwargs)\r\n  |                      ^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/Projects/test/tests/test_foo.py\", line 6, in f1\r\n  |     raise ExceptionGroup('', [ValueError('foo')])\r\n  | ExceptionGroup:  (1 sub-exception)\r\n  +-+---------------- 1 ----------------\r\n    | ValueError: foo\r\n    +------------------------------------\r\n_________________________ ERROR at setup of test_smth3 _________________________\r\n  + Exception Group Traceback (most recent call last):\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1085, in execute\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1085, in execute\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 345, in from_call\r\n  |     result: Optional[TResult] = func()\r\n  |                                 ^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 266, in <lambda>\r\n  |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise\r\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 85, in pytest_runtest_setup\r\n  |     yield from unraisable_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/unraisableexception.py\", line 65, in unraisable_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 833, in pytest_runtest_setup\r\n  |     yield from self._runtest_for(item, \"setup\")\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/logging.py\", line 822, in _runtest_for\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/capture.py\", line 877, in pytest_runtest_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 82, in pytest_runtest_setup\r\n  |     yield from thread_exception_runtest_hook()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/threadexception.py\", line 63, in thread_exception_runtest_hook\r\n  |     yield\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 161, in pytest_runtest_setup\r\n  |     item.session._setupstate.setup(item)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 517, in setup\r\n  |     raise exc\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/runner.py\", line 514, in setup\r\n  |     col.setup()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/python.py\", line 1839, in setup\r\n  |     self._request._fillfixtures()\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 693, in _fillfixtures\r\n  |     item.funcargs[argname] = self.getfixturevalue(argname)\r\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 547, in getfixturevalue\r\n  |     fixturedef = self._get_active_fixturedef(argname)\r\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 566, in _get_active_fixturedef\r\n  |     self._compute_fixture_value(fixturedef)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 652, in _compute_fixture_value\r\n  |     fixturedef.execute(request=subrequest)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1095, in execute\r\n  |     result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n  |     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n  |     raise exception.with_traceback(exception.__traceback__)\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 96, in _multicall\r\n  |     teardown.throw(exception)  # type: ignore[union-attr]\r\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/setuponly.py\", line 36, in pytest_fixture_setup\r\n  |     return (yield)\r\n  |             ^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n  |     res = hook_impl.function(*args)\r\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1149, in pytest_fixture_setup\r\n  |     result = call_fixture_func(fixturefunc, request, kwargs)\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/.pyenv/versions/3.12.0/lib/python3.12/site-packages/_pytest/fixtures.py\", line 923, in call_fixture_func\r\n  |     fixture_result = fixturefunc(**kwargs)\r\n  |                      ^^^^^^^^^^^^^^^^^^^^^\r\n  |   File \"/Users/tkukushkin/Projects/test/tests/test_foo.py\", line 6, in f1\r\n  |     raise ExceptionGroup('', [ValueError('foo')])\r\n  | ExceptionGroup:  (1 sub-exception)\r\n  +-+---------------- 1 ----------------\r\n    | ValueError: foo\r\n    +------------------------------------\r\n=========================== short test summary info ============================\r\nERROR tests/test_foo.py::test_smth1 - ExceptionGroup:  (1 sub-exception)\r\nERROR tests/test_foo.py::test_smth2 - ExceptionGroup:  (1 sub-exception)\r\nERROR tests/test_foo.py::test_smth3 - ExceptionGroup:  (1 sub-exception)\r\n============================== 3 errors in 0.02s ===============================\r\n</code></pre>\r\n</details> \r\n\r\nTraceback of first test: 95 lines\r\nTraceback of second test: 159 lines\r\nTraceback of third test: 223 lines\r\n\r\nIn more complex example with several hundred of tests I got 2.7 GiB logs :-)\r\n\n", "hints_text": "Interesting, thanks for the report.\r\n\r\n### Problem\r\n\r\nFirst, this is actually not specific to ExceptionGroup, this happens for every exception, it's just that we haven't implemented pretty-printing for ExceptionGroup yet so it's more visible. But with `--tb=native` can see the same thing for Exception as well.\r\n\r\nSo what happens is, when the session fixture is first requested by the first test, it is executed, raises, and the exception is cached as the result of the fixture. When the next test requests the fixture, we see the cached exception and re-raise it.\r\n\r\nBut in python, exception objects are mutable; whenever you `raise` an exception, it appends entries to the traceback. So on every `raise` of the cached exception, the traceback gets longer and longer...\r\n\r\n<details><summary>Example</summary>\r\n<p>\r\n\r\n\r\n```py\r\nimport traceback\r\n\r\ndef bad():\r\n    1 / 0\r\n\r\ncache = None\r\ndef foo():\r\n    global cache\r\n    if cache is not None:\r\n        raise cache\r\n    try:\r\n        bad()\r\n    except Exception as exc:\r\n        cache = exc\r\n        raise\r\n\r\ntry:\r\n    foo()\r\nexcept Exception:\r\n    traceback.print_exc()\r\n\r\nprint('\\n')\r\ntry:\r\n    foo()\r\nexcept Exception:\r\n    traceback.print_exc()\r\n\r\nprint('\\n')\r\ntry:\r\n    foo()\r\nexcept Exception:\r\n    traceback.print_exc()\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/ran/src/pytest/yy.py\", line 18, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 12, in foo\r\n    bad()\r\n  File \"/home/ran/src/pytest/yy.py\", line 4, in bad\r\n    1 / 0\r\n    ~~^~~\r\nZeroDivisionError: division by zero\r\n\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/ran/src/pytest/yy.py\", line 24, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 10, in foo\r\n    raise cache\r\n  File \"/home/ran/src/pytest/yy.py\", line 18, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 12, in foo\r\n    bad()\r\n  File \"/home/ran/src/pytest/yy.py\", line 4, in bad\r\n    1 / 0\r\n    ~~^~~\r\nZeroDivisionError: division by zero\r\n\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/ran/src/pytest/yy.py\", line 30, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 10, in foo\r\n    raise cache\r\n  File \"/home/ran/src/pytest/yy.py\", line 24, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 10, in foo\r\n    raise cache\r\n  File \"/home/ran/src/pytest/yy.py\", line 18, in <module>\r\n    foo()\r\n  File \"/home/ran/src/pytest/yy.py\", line 12, in foo\r\n    bad()\r\n  File \"/home/ran/src/pytest/yy.py\", line 4, in bad\r\n    1 / 0\r\n    ~~^~~\r\nZeroDivisionError: division by zero\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\n### Solution\r\n\r\nThe solution is to keep the original traceback, and re-raise with it.\r\n\r\nTurns out, this is how it was done in pytest < 8.0, before I mindlessly broke it in #11208 / 9d0ddb462517fc6c4f6dc7e0f1e14af2e08aeed9. So I need to revert this.\r\n\r\nBTW, there is another place where we do this raising of cached exception thing, in `SetupState.setup()`. This one I also broke, but a few years earlier, in 978b315861c553618fd7ec813e21f3e3916f0d09. I will fix this as well.", "created_at": "2024-04-28T10:32:18Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12258, "instance_id": "pytest-dev__pytest-12258", "issue_numbers": ["7166"], "base_commit": "127a372928cb68e2023ae3c6f8b407c4d2f1f2f7", "patch": "diff --git a/changelog/7166.bugfix.rst b/changelog/7166.bugfix.rst\nnew file mode 100644\nindex 00000000000..98e6821f2ff\n--- /dev/null\n+++ b/changelog/7166.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed progress percentages (the ``[ 87%]`` at the edge of the screen) sometimes not aligning correctly when running with pytest-xdist ``-n``.\n", "test_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 724d5c54d2f..f4b6e9b40ec 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -432,7 +432,7 @@ def hasopt(self, char: str) -> bool:\n         char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n         return char in self.reportchars\n \n-    def write_fspath_result(self, nodeid: str, res, **markup: bool) -> None:\n+    def write_fspath_result(self, nodeid: str, res: str, **markup: bool) -> None:\n         fspath = self.config.rootpath / nodeid.split(\"::\")[0]\n         if self.currentfspath is None or fspath != self.currentfspath:\n             if self.currentfspath is not None and self._show_progress_info:\n@@ -565,10 +565,11 @@ def pytest_deselected(self, items: Sequence[Item]) -> None:\n     def pytest_runtest_logstart(\n         self, nodeid: str, location: Tuple[str, Optional[int], str]\n     ) -> None:\n+        fspath, lineno, domain = location\n         # Ensure that the path is printed before the\n         # 1st test of a module starts running.\n         if self.showlongtestinfo:\n-            line = self._locationline(nodeid, *location)\n+            line = self._locationline(nodeid, fspath, lineno, domain)\n             self.write_ensure_prefix(line, \"\")\n             self.flush()\n         elif self.showfspath:\n@@ -591,7 +592,6 @@ def pytest_runtest_logreport(self, report: TestReport) -> None:\n         if not letter and not word:\n             # Probably passed setup/teardown.\n             return\n-        running_xdist = hasattr(rep, \"node\")\n         if markup is None:\n             was_xfail = hasattr(report, \"wasxfail\")\n             if rep.passed and not was_xfail:\n@@ -604,11 +604,20 @@ def pytest_runtest_logreport(self, report: TestReport) -> None:\n                 markup = {\"yellow\": True}\n             else:\n                 markup = {}\n+        self._progress_nodeids_reported.add(rep.nodeid)\n         if self.config.get_verbosity(Config.VERBOSITY_TEST_CASES) <= 0:\n             self._tw.write(letter, **markup)\n+            # When running in xdist, the logreport and logfinish of multiple\n+            # items are interspersed, e.g. `logreport`, `logreport`,\n+            # `logfinish`, `logfinish`. To avoid the \"past edge\" calculation\n+            # from getting confused and overflowing (#7166), do the past edge\n+            # printing here and not in logfinish, except for the 100% which\n+            # should only be printed after all teardowns are finished.\n+            if self._show_progress_info and not self._is_last_item:\n+                self._write_progress_information_if_past_edge()\n         else:\n-            self._progress_nodeids_reported.add(rep.nodeid)\n             line = self._locationline(rep.nodeid, *rep.location)\n+            running_xdist = hasattr(rep, \"node\")\n             if not running_xdist:\n                 self.write_ensure_prefix(line, word, **markup)\n                 if rep.skipped or hasattr(report, \"wasxfail\"):\n@@ -648,39 +657,29 @@ def _is_last_item(self) -> bool:\n         assert self._session is not None\n         return len(self._progress_nodeids_reported) == self._session.testscollected\n \n-    def pytest_runtest_logfinish(self, nodeid: str) -> None:\n-        assert self._session\n+    @hookimpl(wrapper=True)\n+    def pytest_runtestloop(self) -> Generator[None, object, object]:\n+        result = yield\n+\n+        # Write the final/100% progress -- deferred until the loop is complete.\n         if (\n             self.config.get_verbosity(Config.VERBOSITY_TEST_CASES) <= 0\n             and self._show_progress_info\n+            and self._progress_nodeids_reported\n         ):\n-            if self._show_progress_info == \"count\":\n-                num_tests = self._session.testscollected\n-                progress_length = len(f\" [{num_tests}/{num_tests}]\")\n-            else:\n-                progress_length = len(\" [100%]\")\n-\n-            self._progress_nodeids_reported.add(nodeid)\n+            self._write_progress_information_filling_space()\n \n-            if self._is_last_item:\n-                self._write_progress_information_filling_space()\n-            else:\n-                main_color, _ = self._get_main_color()\n-                w = self._width_of_current_line\n-                past_edge = w + progress_length + 1 >= self._screen_width\n-                if past_edge:\n-                    msg = self._get_progress_information_message()\n-                    self._tw.write(msg + \"\\n\", **{main_color: True})\n+        return result\n \n     def _get_progress_information_message(self) -> str:\n         assert self._session\n         collected = self._session.testscollected\n         if self._show_progress_info == \"count\":\n             if collected:\n-                progress = self._progress_nodeids_reported\n+                progress = len(self._progress_nodeids_reported)\n                 counter_format = f\"{{:{len(str(collected))}d}}\"\n                 format_string = f\" [{counter_format}/{{}}]\"\n-                return format_string.format(len(progress), collected)\n+                return format_string.format(progress, collected)\n             return f\" [ {collected} / {collected} ]\"\n         else:\n             if collected:\n@@ -689,6 +688,20 @@ def _get_progress_information_message(self) -> str:\n                 )\n             return \" [100%]\"\n \n+    def _write_progress_information_if_past_edge(self) -> None:\n+        w = self._width_of_current_line\n+        if self._show_progress_info == \"count\":\n+            assert self._session\n+            num_tests = self._session.testscollected\n+            progress_length = len(f\" [{num_tests}/{num_tests}]\")\n+        else:\n+            progress_length = len(\" [100%]\")\n+        past_edge = w + progress_length + 1 >= self._screen_width\n+        if past_edge:\n+            main_color, _ = self._get_main_color()\n+            msg = self._get_progress_information_message()\n+            self._tw.write(msg + \"\\n\", **{main_color: True})\n+\n     def _write_progress_information_filling_space(self) -> None:\n         color, _ = self._get_main_color()\n         msg = self._get_progress_information_message()\n@@ -937,7 +950,7 @@ def mkrel(nodeid: str) -> str:\n                 line += \"[\".join(values)\n             return line\n \n-        # collect_fspath comes from testid which has a \"/\"-normalized path.\n+        # fspath comes from testid which has a \"/\"-normalized path.\n         if fspath:\n             res = mkrel(nodeid)\n             if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n", "problem_statement": "Percentages don't align correctly\nThis is a really petty issue, so please excuse it. I know it isn't overly important compared to most issues here.\r\n\r\nThe percentages for execution logging do not align when there is a large number of tests being run. This leads to the lines of `.` overflowing to the next line, which makes the graph become difficult to read.\r\n\r\nI have had a poke around in the code, but I do not feel comfortable trying to fix this without more time to understand what the code is doing, unfortunately.\r\n\r\nThanks for taking the time to look into this, greatly appreciated, we rely on Pytest heavily in our project! :+1: \r\n\r\n![image](https://user-images.githubusercontent.com/52883826/81088704-3d029d00-8ef3-11ea-9fd8-7b45cd04e639.png)\r\n\r\nThis was for the following raw output:\r\n\r\n```\r\n............................................................................................ [  3%]\r\n............................................................................................ [  6%]\r\n............................................................................................ [  9%]\r\n............................................................................................ [ 13%]\r\n............................................................................................ [ 16%]\r\n............................................................................................ [ 19%]\r\n............................................................................................ [ 23%]\r\n............................................................................................ [ 26%]\r\n............................................................................................ [ 29%]\r\n............................................................................................ [ 33%]\r\n............................................................................................ [ 36%]\r\n............................................................................................ [ 39%]\r\n............................................................................................ [ 43%]\r\n............................................................................................. [ 46%]\r\n............................................................................................. [ 49%]\r\n............................................................................................ [ 53%]\r\n............................................................................................ [ 56%]\r\n............................................................................................ [ 59%]\r\n............................................................................................ [ 63%]\r\n............................................................................................. [ 66%]\r\n............................................................................................. [ 69%]\r\n............................................................................................ [ 73%]\r\n............................................................................................. [ 76%]\r\n............................................................................................ [ 79%]\r\n............................................................................................ [ 83%]\r\n............................................................................................ [ 86%]\r\n............................................................................................ [ 89%]\r\n............................................................................................ [ 93%]\r\n............................................................................................ [ 96%]\r\n............................................................................................ [ 99%]\r\n....                                                                                         [100%]\r\nCoverage.py warning: No data was collected. (no-data-collected)\r\n```\r\n...for a total of 2,769 test cases, which leads me to think this is possibly a simple rounding issue somewhere.\r\n\r\nTypeface: Jetbrains mono, but can repro on Droid Sans Mono and Fira Code Retina as well. The raw output suggests it isn't an issue with fonts but an issue with the number of `.` being printed -- I haven't bothered counting every single one yet. Can reproduce this on multiple terminals, such as the ones embedded in VSCode and IntelliJ IDEA.\n", "hints_text": "EDIT: forgot the most important info you probably need.\r\n\r\n```\r\nThis is pytest version 5.4.1, imported from /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest/__init__.py\r\nsetuptools registered plugins:\r\n  pytest-metadata-1.8.0 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_metadata/plugin.py\r\n  pytest-asyncio-0.12.0 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_asyncio/plugin.py\r\n  pytest-html-2.1.1 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_html/plugin.py\r\n  pytest-forked-1.1.3 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_forked/__init__.py\r\n  pytest-xdist-1.32.0 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/xdist/plugin.py\r\n  pytest-xdist-1.32.0 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/xdist/looponfail.py\r\n  pytest-cov-2.8.1 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_cov/plugin.py\r\n  pytest-randomly-3.3.1 at /home/nekokatt/code/hikari/.venv/lib/python3.8/site-packages/pytest_randomly.py\r\n```\r\nCPython 3.8.2 (GCC), Manjaro Linux.\nI think I have seen this a few times as well.\r\n\r\nDoes it happen every time, or only some times?\r\n\r\nIf it happens every time, a reproduction would be helpful.\nI've seen this as well with xdist.\r\n\r\nIt seems random unfortunately, I've seen it happen, and then running the same test suite again without changing anything, for the problem to disappear.\r\n\r\nI suspect it is related to terminal character counting in `py` somehow.\n@bluetech it happens every time, but not on our CI: <https://gitlab.com/nekokatt/hikari/-/jobs/539198398>\r\n\r\nI can try and find time to put one together, but it might not be for a few days.\r\n\r\n> I suspect it is related to terminal character counting in py somehow.\r\n\r\ncould it be a thread-safety/multiprocessing-safety issue somewhere?\r\n\r\nThis just made me realise our CI runs a single xdist runner... so this supports that hypothesis as to why it seems to only occur on xdist :)\nI believe this is an xdist-specific issue, I've only seen it when using that -- should we move this issue to there?\ni suspect we may have a off by one error in case more than one test is in flight, which would be actually a core issue\nIf I had to guess why this happens, it'd be that xdist issues e.g. the following sequence:\r\n\r\n- pytest_runtest_logreport (of worker 1)\r\n- pytest_runtest_logreport (of worker 2)\r\n- pytest_runtest_logfinish (of worker 1)\r\n- pytest_runtest_logfinish (of worker 2)\r\n\r\nThe way pytest works, it prints the `.` on `pytest_runtest_logreport`, but only prints the `\\n` (if reached the edge of the terminal) on `pytest_runtest_logfinish`.\r\n\r\nI haven't verified this, maybe xdist does synchronize the runtest protocol between items and it's something else anyway.\nI wonder if this percentage feature can be completely disabled?\r\nI just run into the case where it was handy to me to see just raw output of one heavily parametrized test to see the test matrix. And the test name and percentage peretty much ruined the whole output making me to copy the output and apply some replacements on it manually so it can look little bit more alligned and understanable.\r\n\r\nThanks!\n> I wonder if this percentage feature can be completely disabled?\r\n\r\nSee the [`console_output_style` config option](https://docs.pytest.org/en/latest/reference/reference.html#confval-console_output_style)\nI confirmed that the cause is as described in my previous comment https://github.com/pytest-dev/pytest/issues/7166#issuecomment-873917140.\r\n\r\nPossible solutions I can think of:\r\n\r\nSolution 1: Change pytest-xdist to not intermix hook calls for different item's runtestprotocol hooks.\r\nI didn't assess this, seems desirable in some respects (probably there are other plugins which get confused by this), but probably has some ill effects as well, with respect to \"lying\" about the ordering and delaying.\r\n\r\nSolution 2: change pytest to not have this split printing between logreport and logfinish. So either: do everything in logfinish, but then printing the `.` is delayed waiting for teardown; or do everything in `logreport`, but then we print `100%` and then seem \"stuck\" waiting for possibly-lengthy session teardown (instead of the `100%` not showing until teardown is complete).\r\n\r\nSolution 3: *always* display the progress at the end of the line (updated on each `.`), not just when *reaching* the end of the line, then there is no question of when to show it. The `TerminalReporter`/`TerminalWriter` are currently \"append only\" and not really built for this as far as I can see, so will need some reworking.\r\n\r\nI'm thinking the 2nd solution with moving the progress reporting to `logreport` + a special case for the 100%.", "created_at": "2024-04-27T22:08:48Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12250, "instance_id": "pytest-dev__pytest-12250", "issue_numbers": ["11728"], "base_commit": "4eb8b6d525b7704432f378cfa45ab9ec02bf4e39", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex d7148acfc51..4f61c05914b 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -101,6 +101,7 @@ Cyrus Maden\n Damian Skrzypczak\n Daniel Grana\n Daniel Hahler\n+Daniel Miller\n Daniel Nuri\n Daniel S\u00e1nchez Castell\u00f3\n Daniel Valenzuela Zenteno\ndiff --git a/changelog/11728.improvement.rst b/changelog/11728.improvement.rst\nnew file mode 100644\nindex 00000000000..1e87fc5ed88\n--- /dev/null\n+++ b/changelog/11728.improvement.rst\n@@ -0,0 +1,1 @@\n+For ``unittest``-based tests, exceptions during class cleanup (as raised by functions registered with :meth:`TestCase.addClassCleanup <unittest.TestCase.addClassCleanup>`) are now reported instead of silently failing.\n", "test_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 5099904fd41..8f1791bf744 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -32,6 +32,9 @@\n import pytest\n \n \n+if sys.version_info[:2] < (3, 11):\n+    from exceptiongroup import ExceptionGroup\n+\n if TYPE_CHECKING:\n     import unittest\n \n@@ -111,6 +114,20 @@ def _register_unittest_setup_class_fixture(self, cls: type) -> None:\n             return None\n         cleanup = getattr(cls, \"doClassCleanups\", lambda: None)\n \n+        def process_teardown_exceptions() -> None:\n+            # tearDown_exceptions is a list set in the class containing exc_infos for errors during\n+            # teardown for the class.\n+            exc_infos = getattr(cls, \"tearDown_exceptions\", None)\n+            if not exc_infos:\n+                return\n+            exceptions = [exc for (_, exc, _) in exc_infos]\n+            # If a single exception, raise it directly as this provides a more readable\n+            # error (hopefully this will improve in #12255).\n+            if len(exceptions) == 1:\n+                raise exceptions[0]\n+            else:\n+                raise ExceptionGroup(\"Unittest class cleanup errors\", exceptions)\n+\n         def unittest_setup_class_fixture(\n             request: FixtureRequest,\n         ) -> Generator[None, None, None]:\n@@ -125,6 +142,7 @@ def unittest_setup_class_fixture(\n                 # follow this here.\n                 except Exception:\n                     cleanup()\n+                    process_teardown_exceptions()\n                     raise\n             yield\n             try:\n@@ -132,6 +150,7 @@ def unittest_setup_class_fixture(\n                     teardown()\n             finally:\n                 cleanup()\n+                process_teardown_exceptions()\n \n         self.session._fixturemanager._register_fixture(\n             # Use a unique name to speed up lookup.\ndiff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 9ecb548eeec..d726e74d603 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1500,6 +1500,95 @@ def test_cleanup_called_the_right_number_of_times():\n     assert passed == 1\n \n \n+class TestClassCleanupErrors:\n+    \"\"\"\n+    Make sure to show exceptions raised during class cleanup function (those registered\n+    via addClassCleanup()).\n+\n+    See #11728.\n+    \"\"\"\n+\n+    def test_class_cleanups_failure_in_setup(self, pytester: Pytester) -> None:\n+        testpath = pytester.makepyfile(\n+            \"\"\"\n+            import unittest\n+            class MyTestCase(unittest.TestCase):\n+                @classmethod\n+                def setUpClass(cls):\n+                    def cleanup(n):\n+                        raise Exception(f\"fail {n}\")\n+                    cls.addClassCleanup(cleanup, 2)\n+                    cls.addClassCleanup(cleanup, 1)\n+                    raise Exception(\"fail 0\")\n+                def test(self):\n+                    pass\n+        \"\"\"\n+        )\n+        result = pytester.runpytest(\"-s\", testpath)\n+        result.assert_outcomes(passed=0, errors=1)\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*Unittest class cleanup errors *2 sub-exceptions*\",\n+                \"*Exception: fail 1\",\n+                \"*Exception: fail 2\",\n+            ]\n+        )\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"* ERROR at setup of MyTestCase.test *\",\n+                \"E * Exception: fail 0\",\n+            ]\n+        )\n+\n+    def test_class_cleanups_failure_in_teardown(self, pytester: Pytester) -> None:\n+        testpath = pytester.makepyfile(\n+            \"\"\"\n+            import unittest\n+            class MyTestCase(unittest.TestCase):\n+                @classmethod\n+                def setUpClass(cls):\n+                    def cleanup(n):\n+                        raise Exception(f\"fail {n}\")\n+                    cls.addClassCleanup(cleanup, 2)\n+                    cls.addClassCleanup(cleanup, 1)\n+                def test(self):\n+                    pass\n+        \"\"\"\n+        )\n+        result = pytester.runpytest(\"-s\", testpath)\n+        result.assert_outcomes(passed=1, errors=1)\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*Unittest class cleanup errors *2 sub-exceptions*\",\n+                \"*Exception: fail 1\",\n+                \"*Exception: fail 2\",\n+            ]\n+        )\n+\n+    def test_class_cleanup_1_failure_in_teardown(self, pytester: Pytester) -> None:\n+        testpath = pytester.makepyfile(\n+            \"\"\"\n+            import unittest\n+            class MyTestCase(unittest.TestCase):\n+                @classmethod\n+                def setUpClass(cls):\n+                    def cleanup(n):\n+                        raise Exception(f\"fail {n}\")\n+                    cls.addClassCleanup(cleanup, 1)\n+                def test(self):\n+                    pass\n+        \"\"\"\n+        )\n+        result = pytester.runpytest(\"-s\", testpath)\n+        result.assert_outcomes(passed=1, errors=1)\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*ERROR at teardown of MyTestCase.test*\",\n+                \"*Exception: fail 1\",\n+            ]\n+        )\n+\n+\n def test_traceback_pruning(pytester: Pytester) -> None:\n     \"\"\"Regression test for #9610 - doesn't crash during traceback pruning.\"\"\"\n     pytester.makepyfile(\n", "problem_statement": "Pytest does not show addClassCleanup errors\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\nBelow in minimal example is a code that if I run with python, I get\r\n```\r\nRunning test one\r\n.E\r\n======================================================================\r\nERROR: tearDownClass (__main__.SomeTest)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"tst.py\", line 11, in clean_up_class\r\n    raise AttributeError\r\nAttributeError\r\n\r\n----------------------------------------------------------------------\r\nRan 1 test in 0.001s\r\n\r\nFAILED (errors=1)\r\n\r\n```\r\nwhich is fine, but if I run it with pytest I get:\r\n\r\n```\r\n==================================================================================== test session starts =====================================================================================\r\nplatform linux -- Python 3.8.18, pytest-7.4.3, pluggy-1.3.0\r\nrootdir: /home/vagrant\r\ncollected 1 item                                                                                                                                                                             \r\n\r\ntst.py .                                                                                                                                                                               [100%]\r\n\r\n===================================================================================== 1 passed in 0.01s ======================================================================================\r\n\r\n```\r\n\r\nWithout any sign of that an error has happend. Therefore it fail silently without anyone knowing something wrong happend.\r\n\r\nExpected: Pytest shows error as well.\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n```\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            23.3.2\r\npluggy         1.3.0\r\npytest         7.4.3\r\nsetuptools     56.0.0\r\ntomli          2.0.1\r\n\r\n```\r\n\r\n- [x] pytest and operating system versions\r\npytest 7.4.3\r\nCentos7\r\n\r\n- [x] minimal example if possible\r\n\r\n```\r\nimport unittest\r\n\r\n\r\nclass SomeTest(unittest.TestCase):\r\n    @classmethod\r\n    def setUpClass(cls):\r\n        cls.addClassCleanup(cls.clean_up_class)\r\n        \r\n    @classmethod\r\n    def clean_up_class(cls):\r\n        raise AttributeError\r\n\r\n    def test_one(self):\r\n        print(\"Running test one\")\r\n        self.assertTrue(True)\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n```\r\n\n", "hints_text": "@bluetech hi, may I ask how is this going? I think it is rather inconvenient not being able to see certain errors. \nThis workaround can be dropped in a plugin module or conftest.py\r\n```py\r\nimport pytest\r\n\r\n\r\n@pytest.hookimpl\r\ndef pytest_configure():\r\n    patch_unittest_TestCase_doClassCleanup()\r\n\r\n\r\ndef patch_unittest_TestCase_doClassCleanup():\r\n    \"\"\"Raise/print errors caught during class cleanup\r\n\r\n    pytest ignores `TestCase.tearDown_exceptions`, which causes them to\r\n    pass silently.\r\n    \"\"\"\r\n\r\n    @classmethod\r\n    def doClassCleanupAndRaiseLastError(cls):\r\n        doClassCleanups()\r\n        errors = cls.tearDown_exceptions\r\n        if errors:\r\n            if len(errors) > 1:\r\n                num = len(errors)\r\n                for n, (exc_type, exc, tb) in enumerate(errors[:-1], start=1):\r\n                    print(f\"\\nclass cleanup error ({n} of {num}):\", file=sys.stderr)\r\n                    print_exception(exc_type, exc, tb)\r\n            raise errors[-1][1]\r\n\r\n    import sys\r\n    from traceback import print_exception\r\n    from unittest.case import TestCase\r\n    doClassCleanups = TestCase.doClassCleanups\r\n    TestCase.doClassCleanups = doClassCleanupAndRaiseLastError\r\n```", "created_at": "2024-04-26T14:42:51Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12220, "instance_id": "pytest-dev__pytest-12220", "issue_numbers": ["11523"], "base_commit": "fafab1dbfd2414c2282b558f0c7af9a7ad0318ab", "patch": "diff --git a/changelog/11523.improvement.rst b/changelog/11523.improvement.rst\nnew file mode 100644\nindex 00000000000..f7d8ff89df6\n--- /dev/null\n+++ b/changelog/11523.improvement.rst\n@@ -0,0 +1,5 @@\n+:func:`pytest.importorskip` will now issue a warning if the module could be found, but raised :class:`ImportError` instead of :class:`ModuleNotFoundError`.\n+\n+The warning can be suppressed by passing ``exc_type=ImportError`` to :func:`pytest.importorskip`.\n+\n+See :ref:`import-or-skip-import-error` for details.\ndiff --git a/doc/en/deprecations.rst b/doc/en/deprecations.rst\nindex cd6d1e60aef..5ac93f15144 100644\n--- a/doc/en/deprecations.rst\n+++ b/doc/en/deprecations.rst\n@@ -19,6 +19,41 @@ Below is a complete list of all pytest features which are considered deprecated.\n :class:`~pytest.PytestWarning` or subclasses, which can be filtered using :ref:`standard warning filters <warnings>`.\n \n \n+.. _import-or-skip-import-error:\n+\n+``pytest.importorskip`` default behavior regarding :class:`ImportError`\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. deprecated:: 8.2\n+\n+Traditionally :func:`pytest.importorskip` will capture :class:`ImportError`, with the original intent being to skip\n+tests where a dependent module is not installed, for example testing with different dependencies.\n+\n+However some packages might be installed in the system, but are not importable due to\n+some other issue, for example, a compilation error or a broken installation. In those cases :func:`pytest.importorskip`\n+would still silently skip the test, but more often than not users would like to see the unexpected\n+error so the underlying issue can be fixed.\n+\n+In ``8.2`` the ``exc_type`` parameter has been added, giving users the ability of passing :class:`ModuleNotFoundError`\n+to skip tests only if the module cannot really be found, and not because of some other error.\n+\n+Catching only :class:`ModuleNotFoundError` by default (and letting other errors propagate) would be the best solution,\n+however for backward compatibility, pytest will keep the existing behavior but raise an warning if:\n+\n+1. The captured exception is of type :class:`ImportError`, and:\n+2. The user does not pass ``exc_type`` explicitly.\n+\n+If the import attempt raises :class:`ModuleNotFoundError` (the usual case), then the module is skipped and no\n+warning is emitted.\n+\n+This way, the usual cases will keep working the same way, while unexpected errors will now issue a warning, with\n+users being able to supress the warning by passing ``exc_type=ImportError`` explicitly.\n+\n+In ``9.0``, the warning will turn into an error, and in ``9.1`` :func:`pytest.importorskip` will only capture\n+:class:`ModuleNotFoundError` by default and no warnings will be issued anymore -- but users can still capture\n+:class:`ImportError` by passing it to ``exc_type``.\n+\n+\n .. _node-ctor-fspath-deprecation:\n \n ``fspath`` argument for Node constructors replaced with ``pathlib.Path``\n", "test_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex e2a816f5850..76d94accd0d 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -11,6 +11,8 @@\n from typing import Type\n from typing import TypeVar\n \n+from .warning_types import PytestDeprecationWarning\n+\n \n class OutcomeException(BaseException):\n     \"\"\"OutcomeException and its subclass instances indicate and contain info\n@@ -192,7 +194,11 @@ def xfail(reason: str = \"\") -> NoReturn:\n \n \n def importorskip(\n-    modname: str, minversion: Optional[str] = None, reason: Optional[str] = None\n+    modname: str,\n+    minversion: Optional[str] = None,\n+    reason: Optional[str] = None,\n+    *,\n+    exc_type: Optional[Type[ImportError]] = None,\n ) -> Any:\n     \"\"\"Import and return the requested module ``modname``, or skip the\n     current test if the module cannot be imported.\n@@ -205,6 +211,18 @@ def importorskip(\n     :param reason:\n         If given, this reason is shown as the message when the module cannot\n         be imported.\n+    :param exc_type:\n+        The exception that should be captured in order to skip modules.\n+        Must be :py:class:`ImportError` or a subclass.\n+\n+        If the module can be imported but raises :class:`ImportError`, pytest will\n+        issue a warning to the user, as often users expect the module not to be\n+        found (which would raise :class:`ModuleNotFoundError` instead).\n+\n+        This warning can be suppressed by passing ``exc_type=ImportError`` explicitly.\n+\n+        See :ref:`import-or-skip-import-error` for details.\n+\n \n     :returns:\n         The imported module. This should be assigned to its canonical name.\n@@ -212,23 +230,62 @@ def importorskip(\n     Example::\n \n         docutils = pytest.importorskip(\"docutils\")\n+\n+    .. versionadded:: 8.2\n+\n+        The ``exc_type`` parameter.\n     \"\"\"\n     import warnings\n \n     __tracebackhide__ = True\n     compile(modname, \"\", \"eval\")  # to catch syntaxerrors\n \n+    # Until pytest 9.1, we will warn the user if we catch ImportError (instead of ModuleNotFoundError),\n+    # as this might be hiding an installation/environment problem, which is not usually what is intended\n+    # when using importorskip() (#11523).\n+    # In 9.1, to keep the function signature compatible, we just change the code below to:\n+    # 1. Use `exc_type = ModuleNotFoundError` if `exc_type` is not given.\n+    # 2. Remove `warn_on_import` and the warning handling.\n+    if exc_type is None:\n+        exc_type = ImportError\n+        warn_on_import_error = True\n+    else:\n+        warn_on_import_error = False\n+\n+    skipped: Optional[Skipped] = None\n+    warning: Optional[Warning] = None\n+\n     with warnings.catch_warnings():\n         # Make sure to ignore ImportWarnings that might happen because\n         # of existing directories with the same name we're trying to\n         # import but without a __init__.py file.\n         warnings.simplefilter(\"ignore\")\n+\n         try:\n             __import__(modname)\n-        except ImportError as exc:\n+        except exc_type as exc:\n+            # Do not raise or issue warnings inside the catch_warnings() block.\n             if reason is None:\n                 reason = f\"could not import {modname!r}: {exc}\"\n-            raise Skipped(reason, allow_module_level=True) from None\n+            skipped = Skipped(reason, allow_module_level=True)\n+\n+            if warn_on_import_error and not isinstance(exc, ModuleNotFoundError):\n+                lines = [\n+                    \"\",\n+                    f\"Module '{modname}' was found, but when imported by pytest it raised:\",\n+                    f\"    {exc!r}\",\n+                    \"In pytest 9.1 this warning will become an error by default.\",\n+                    \"You can fix the underlying problem, or alternatively overwrite this behavior and silence this \"\n+                    \"warning by passing exc_type=ImportError explicitly.\",\n+                    \"See https://docs.pytest.org/en/stable/deprecations.html#pytest-importorskip-default-behavior-regarding-importerror\",\n+                ]\n+                warning = PytestDeprecationWarning(\"\\n\".join(lines))\n+\n+    if warning:\n+        warnings.warn(warning, stacklevel=2)\n+    if skipped:\n+        raise skipped\n+\n     mod = sys.modules[modname]\n     if minversion is None:\n         return mod\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex ffac0f2d92b..6e034e94532 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -9,6 +9,7 @@\n from typing import List\n from typing import Tuple\n from typing import Type\n+import warnings\n \n from _pytest import outcomes\n from _pytest import reports\n@@ -762,6 +763,73 @@ def test_importorskip_imports_last_module_part() -> None:\n     assert os.path == ospath\n \n \n+class TestImportOrSkipExcType:\n+    \"\"\"Tests for #11523.\"\"\"\n+\n+    def test_no_warning(self) -> None:\n+        # An attempt on a module which does not exist will raise ModuleNotFoundError, so it will\n+        # be skipped normally and no warning will be issued.\n+        with warnings.catch_warnings(record=True) as captured:\n+            warnings.simplefilter(\"always\")\n+\n+            with pytest.raises(pytest.skip.Exception):\n+                pytest.importorskip(\"TestImportOrSkipExcType_test_no_warning\")\n+\n+        assert captured == []\n+\n+    def test_import_error_with_warning(self, pytester: Pytester) -> None:\n+        # Create a module which exists and can be imported, however it raises\n+        # ImportError due to some other problem. In this case we will issue a warning\n+        # about the future behavior change.\n+        fn = pytester.makepyfile(\"raise ImportError('some specific problem')\")\n+        pytester.syspathinsert()\n+\n+        with warnings.catch_warnings(record=True) as captured:\n+            warnings.simplefilter(\"always\")\n+\n+            with pytest.raises(pytest.skip.Exception):\n+                pytest.importorskip(fn.stem)\n+\n+        [warning] = captured\n+        assert warning.category is pytest.PytestDeprecationWarning\n+\n+    def test_import_error_suppress_warning(self, pytester: Pytester) -> None:\n+        # Same as test_import_error_with_warning, but we can suppress the warning\n+        # by passing ImportError as exc_type.\n+        fn = pytester.makepyfile(\"raise ImportError('some specific problem')\")\n+        pytester.syspathinsert()\n+\n+        with warnings.catch_warnings(record=True) as captured:\n+            warnings.simplefilter(\"always\")\n+\n+            with pytest.raises(pytest.skip.Exception):\n+                pytest.importorskip(fn.stem, exc_type=ImportError)\n+\n+        assert captured == []\n+\n+    def test_warning_integration(self, pytester: Pytester) -> None:\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_foo():\n+                pytest.importorskip(\"warning_integration_module\")\n+            \"\"\"\n+        )\n+        pytester.makepyfile(\n+            warning_integration_module=\"\"\"\n+                raise ImportError(\"required library foobar not compiled properly\")\n+            \"\"\"\n+        )\n+        result = pytester.runpytest()\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*Module 'warning_integration_module' was found, but when imported by pytest it raised:\",\n+                \"*      ImportError('required library foobar not compiled properly')\",\n+                \"*1 skipped, 1 warning*\",\n+            ]\n+        )\n+\n+\n def test_importorskip_dev_module(monkeypatch) -> None:\n     try:\n         mod = types.ModuleType(\"mockmodule\")\n", "problem_statement": "importorskip variant that uses ModuleNotFoundError\n<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\nsometimes I install a package eg PyTables and it fails to compile properly and fails with an ImportError with an undefined symbol, however I don't see this in CI because I only do `pytest.importorskip(\"pytables\")`\r\n\r\n#### Describe the solution you'd like\r\na new kwarg to importorskip or a new function that catches ModuleNotFoundError instead of ImportError eg\r\n`importorskip(exc=ModuleNotFoundError)` or `findmoduleorskip(...)`\r\n\r\n#### Alternative Solutions\r\nN/A\r\n\r\n#### Additional context\r\nOriginally asked on discord\r\n\n", "hints_text": "Hey @graingert thanks for the proposal.\r\n\r\n> a new kwarg to importorskip or a new function that catches ModuleNotFoundError instead of ImportError eg\r\nimportorskip(exc=ModuleNotFoundError) or findmoduleorskip(...)\r\n\r\nI personally like `importorskip(exc=ModuleNotFoundError)` \ud83d\udc4d \ni think it would be very nice if a requirement could be passed to allow checking for versions\nThe alternative to `exc=` is to just narrow the current `except ImportError` to `except ModuleNotFoundError`. This will a breaking change, but I wonder if anyone really wants to skip on non-`ModuleNotFoundError` import errors?\nWe could also check the exception message matches the module being imported\n> This will a breaking change, but I wonder if anyone really wants to skip on non-ModuleNotFoundError import errors?\r\n\r\nThought the same, I for one would always add `exc=ModuleNotFoundError`.\r\n\r\nPerhaps it is worthwhile to go through a deprecation period, where we issue a warning in case a `importorskip` skipped a module but the message did not include the actual module name? Later we can apply the change to only catch `ModuleNotFoundError` then.\nI don't understand the rationale of doing string matching against the exception message here. Why would we need to check that if we can just check the exception type? Why would it be useful to catch an `ImportError` which is not a `ModuleNotFoundError` but just happens to include the module name, vs. one which does not?\n> Why would we need to check that if we can just check the exception type? Why would it be useful to catch an ImportError which is not a ModuleNotFoundError but just happens to include the module name, vs. one which does not?\r\n\r\nJust to issue a warning that the behavior will change in the future, where we will only catch `ModuleNotFoundError`:\r\n\r\n```python\r\nexcept ModuleNotFoundError:\r\n    skip()\r\nexcept ImportError as e:\r\n    if module_name not in str(e):\r\n        warning(f\"importorskip('{modulename}') caught an ImportError, but the message:\\n{e}\\n does not contain the module name. This behavior will change in the future to only catch ModuleNotFoundError\")\r\n   skip()\r\n```\r\n\r\nThe idea is that we remove the `except ImportError` clause in a future release, as this is a breaking change (for the better IMHO).\r\n\r\n\nI still don't follow. Why would we not want to warn if the message contains the module name?\nTo let users know that this might break their test suite in the future, suppose a user has this in their code base:\r\n\r\n```python\r\ndef test_numpy_support() -> None:\r\n    pytest.importorskip(\"numpy\")\r\n    ...\r\n```\r\n\r\nCurrently, the test is skipped, but not because `numpy` is not installed, but because it is failing to import due to something else entirely, for example due to an undefined symbol.\r\n\r\nIf we just change `importorskip` to catch `ModuleNotFoundError`, this would cause the test suite to break.\r\n\r\nWe might decide instead to introduce a warning, so users would see a warning like this currently:\r\n\r\n```\r\nPytestDeprecationWarning: importorskip caught ImportError with this message:\r\n\r\n    ImportError: undefined symbol ...\r\n\r\nSeems like the reason for the failure was not that the module was missing, but another cause.\r\npytest X will only catch `ModuleNotFoundError`, so this will fail in the future.\r\n```\r\n\r\nThen in a future release we change the code to only catch `ModuleNotFoundError`.\r\n\r\n--- \r\n\r\nBut now that I write this, perhaps does not make sense to introduce this warning at all? Seems like users would like for this to fail right away?\nBut in any case the module actually isn't present, we already will get a `ModuleNotFoundError` from Python. Why not warn on *any* `ImportError`, if anything? I don't see a reason why we should warn if, say, the undefined symbol in your example happens to be `SomeLib::bla()` but should not warn if the symbol happens to be called `NumpyCExt::bla()`.\nOh you are right, we will already be catching `ModuleNotFoundError` explicitly, so any `ImportError` would be enough to generate a warning, no need to check the message at all.\r\n\r\nSorry for the noise!\r\n\r\nWe need to decide if we want to generate a warning, or go with the \"breaking\" change directly (I'm using quotes because one might argue that this is a clear improvement).", "created_at": "2024-04-16T14:34:35Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12208, "instance_id": "pytest-dev__pytest-12208", "issue_numbers": ["12194"], "base_commit": "ad95d59d6158076768cccd0000b968cd691cb62a", "patch": "diff --git a/changelog/12194.bugfix.rst b/changelog/12194.bugfix.rst\nnew file mode 100644\nindex 00000000000..6983ba35a90\n--- /dev/null\n+++ b/changelog/12194.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed a bug with ``--importmode=importlib`` and ``--doctest-modules`` where child modules did not appear as attributes in parent modules.\n", "test_patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex 254d9d9468e..7f01c011ba6 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -620,10 +620,6 @@ def _import_module_using_spec(\n     :param insert_modules:\n         If True, will call insert_missing_modules to create empty intermediate modules\n         for made-up module names (when importing test files not reachable from sys.path).\n-        Note: we can probably drop insert_missing_modules altogether: instead of\n-        generating module names such as \"src.tests.test_foo\", which require intermediate\n-        empty modules, we might just as well generate unique module names like\n-        \"src_tests_test_foo\".\n     \"\"\"\n     # Checking with sys.meta_path first in case one of its hooks can import this module,\n     # such as our own assertion-rewrite hook.\n@@ -636,9 +632,41 @@ def _import_module_using_spec(\n \n     if spec_matches_module_path(spec, module_path):\n         assert spec is not None\n+        # Attempt to import the parent module, seems is our responsibility:\n+        # https://github.com/python/cpython/blob/73906d5c908c1e0b73c5436faeff7d93698fc074/Lib/importlib/_bootstrap.py#L1308-L1311\n+        parent_module_name, _, name = module_name.rpartition(\".\")\n+        parent_module: Optional[ModuleType] = None\n+        if parent_module_name:\n+            parent_module = sys.modules.get(parent_module_name)\n+            if parent_module is None:\n+                # Find the directory of this module's parent.\n+                parent_dir = (\n+                    module_path.parent.parent\n+                    if module_path.name == \"__init__.py\"\n+                    else module_path.parent\n+                )\n+                # Consider the parent module path as its __init__.py file, if it has one.\n+                parent_module_path = (\n+                    parent_dir / \"__init__.py\"\n+                    if (parent_dir / \"__init__.py\").is_file()\n+                    else parent_dir\n+                )\n+                parent_module = _import_module_using_spec(\n+                    parent_module_name,\n+                    parent_module_path,\n+                    parent_dir,\n+                    insert_modules=insert_modules,\n+                )\n+\n+        # Find spec and import this module.\n         mod = importlib.util.module_from_spec(spec)\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n+\n+        # Set this module as an attribute of the parent module (#12194).\n+        if parent_module is not None:\n+            setattr(parent_module, name, mod)\n+\n         if insert_modules:\n             insert_missing_modules(sys.modules, module_name)\n         return mod\ndiff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex f96151bdd44..688d13f2f05 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -1126,6 +1126,139 @@ def test_safe_exists(tmp_path: Path) -> None:\n         assert safe_exists(p) is False\n \n \n+def test_import_sets_module_as_attribute(pytester: Pytester) -> None:\n+    \"\"\"Unittest test for #12194.\"\"\"\n+    pytester.path.joinpath(\"foo/bar/baz\").mkdir(parents=True)\n+    pytester.path.joinpath(\"foo/__init__.py\").touch()\n+    pytester.path.joinpath(\"foo/bar/__init__.py\").touch()\n+    pytester.path.joinpath(\"foo/bar/baz/__init__.py\").touch()\n+    pytester.syspathinsert()\n+\n+    # Import foo.bar.baz and ensure parent modules also ended up imported.\n+    baz = import_path(\n+        pytester.path.joinpath(\"foo/bar/baz/__init__.py\"),\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    assert baz.__name__ == \"foo.bar.baz\"\n+    foo = sys.modules[\"foo\"]\n+    assert foo.__name__ == \"foo\"\n+    bar = sys.modules[\"foo.bar\"]\n+    assert bar.__name__ == \"foo.bar\"\n+\n+    # Check parent modules have an attribute pointing to their children.\n+    assert bar.baz is baz\n+    assert foo.bar is bar\n+\n+    # Ensure we returned the \"foo.bar\" module cached in sys.modules.\n+    bar_2 = import_path(\n+        pytester.path.joinpath(\"foo/bar/__init__.py\"),\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    assert bar_2 is bar\n+\n+\n+def test_import_sets_module_as_attribute_without_init_files(pytester: Pytester) -> None:\n+    \"\"\"Similar to test_import_sets_module_as_attribute, but without __init__.py files.\"\"\"\n+    pytester.path.joinpath(\"foo/bar\").mkdir(parents=True)\n+    pytester.path.joinpath(\"foo/bar/baz.py\").touch()\n+    pytester.syspathinsert()\n+\n+    # Import foo.bar.baz and ensure parent modules also ended up imported.\n+    baz = import_path(\n+        pytester.path.joinpath(\"foo/bar/baz.py\"),\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    assert baz.__name__ == \"foo.bar.baz\"\n+    foo = sys.modules[\"foo\"]\n+    assert foo.__name__ == \"foo\"\n+    bar = sys.modules[\"foo.bar\"]\n+    assert bar.__name__ == \"foo.bar\"\n+\n+    # Check parent modules have an attribute pointing to their children.\n+    assert bar.baz is baz\n+    assert foo.bar is bar\n+\n+    # Ensure we returned the \"foo.bar.baz\" module cached in sys.modules.\n+    baz_2 = import_path(\n+        pytester.path.joinpath(\"foo/bar/baz.py\"),\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    assert baz_2 is baz\n+\n+\n+def test_import_sets_module_as_attribute_regression(pytester: Pytester) -> None:\n+    \"\"\"Regression test for #12194.\"\"\"\n+    pytester.path.joinpath(\"foo/bar/baz\").mkdir(parents=True)\n+    pytester.path.joinpath(\"foo/__init__.py\").touch()\n+    pytester.path.joinpath(\"foo/bar/__init__.py\").touch()\n+    pytester.path.joinpath(\"foo/bar/baz/__init__.py\").touch()\n+    f = pytester.makepyfile(\n+        \"\"\"\n+        import foo\n+        from foo.bar import baz\n+        foo.bar.baz\n+\n+        def test_foo() -> None:\n+            pass\n+        \"\"\"\n+    )\n+\n+    pytester.syspathinsert()\n+    result = pytester.runpython(f)\n+    assert result.ret == 0\n+\n+    result = pytester.runpytest(\"--import-mode=importlib\", \"--doctest-modules\")\n+    assert result.ret == 0\n+\n+\n+def test_import_submodule_not_namespace(pytester: Pytester) -> None:\n+    \"\"\"\n+    Regression test for importing a submodule 'foo.bar' while there is a 'bar' directory\n+    reachable from sys.path -- ensuring the top-level module does not end up imported as a namespace\n+    package.\n+\n+    #12194\n+    https://github.com/pytest-dev/pytest/pull/12208#issuecomment-2056458432\n+    \"\"\"\n+    pytester.syspathinsert()\n+    # Create package 'foo' with a submodule 'bar'.\n+    pytester.path.joinpath(\"foo\").mkdir()\n+    foo_path = pytester.path.joinpath(\"foo/__init__.py\")\n+    foo_path.touch()\n+    bar_path = pytester.path.joinpath(\"foo/bar.py\")\n+    bar_path.touch()\n+    # Create top-level directory in `sys.path` with the same name as that submodule.\n+    pytester.path.joinpath(\"bar\").mkdir()\n+\n+    # Import `foo`, then `foo.bar`, and check they were imported from the correct location.\n+    foo = import_path(\n+        foo_path,\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    bar = import_path(\n+        bar_path,\n+        mode=ImportMode.importlib,\n+        root=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n+    assert foo.__name__ == \"foo\"\n+    assert bar.__name__ == \"foo.bar\"\n+    assert foo.__file__ is not None\n+    assert bar.__file__ is not None\n+    assert Path(foo.__file__) == foo_path\n+    assert Path(bar.__file__) == bar_path\n+\n+\n class TestNamespacePackages:\n     \"\"\"Test import_path support when importing from properly namespace packages.\"\"\"\n \n", "problem_statement": "AttributeError with import-mode importlib and doctest modules\nLikely related to #12112, discovered in jaraco/keyring#676, a new regression appears in pytest 8.1 relating to collection. Consider this minimal example:\r\n\r\n```\r\n draft @ cat > test_something.py\r\nimport foo\r\nfrom foo.bar import baz\r\nfoo.bar.baz\r\n draft @ mkdir -p foo/bar/baz\r\n draft @ touch foo/__init__.py\r\n draft @ touch foo/bar/__init__.py\r\n draft @ touch foo/bar/baz/__init__.py\r\n draft @ pip-run pytest -- -m pytest --import-mode importlib --doctest-modules\r\n============================================================== test session starts ===============================================================\r\nplatform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0\r\nrootdir: /Users/jaraco/draft\r\ncollected 0 items / 1 error                                                                                                                      \r\n\r\n===================================================================== ERRORS =====================================================================\r\n_______________________________________________________ ERROR collecting test_something.py _______________________________________________________\r\ntest_something.py:3: in <module>\r\n    foo.bar.baz\r\nE   AttributeError: module 'foo' has no attribute 'bar'\r\n============================================================ short test summary info =============================================================\r\nERROR test_something.py - AttributeError: module 'foo' has no attribute 'bar'\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n================================================================ 1 error in 0.03s ================================================================\r\n```\r\n\r\nIt seems that once the `foo/bar/__init__.py` has been collected for doctesting, the collection of the tests in test_something will start to fail when `foo` has no attribute `bar`. Any of the following tweaks will bypass the failure:\r\n\r\n- disable doctests\r\n- pin to pytest<8.1\r\n- use a different `import-mode`\r\n\r\nSomething about the pytest discovery and import machinery is breaking the Python convention that importing a submodule causes the submodule to be added as an attribute of the parent module.\n", "hints_text": "It occurred to me that the fix in #12169 might also address this issue, but it does not:\r\n\r\n```\r\n draft @ pip-run git+https://github.com/pytest-dev/pytest@refs/pull/12169/head -- -m pytest --import-mode importlib --doctest-modules\r\n  WARNING: Did not find branch or tag 'refs/pull/12169/head', assuming revision or ref.\r\n============================================================== test session starts ===============================================================\r\nplatform darwin -- Python 3.12.2, pytest-8.2.0.dev95+g1e22e0f70, pluggy-1.4.0\r\nrootdir: /Users/jaraco/draft\r\ncollected 0 items / 1 error                                                                                                                      \r\n\r\n===================================================================== ERRORS =====================================================================\r\n_______________________________________________________ ERROR collecting test_something.py _______________________________________________________\r\ntest_something.py:4: in <module>\r\n    foo.bar.baz\r\nE   AttributeError: module 'foo' has no attribute 'bar'\r\n============================================================ short test summary info =============================================================\r\nERROR test_something.py - AttributeError: module 'foo' has no attribute 'bar'\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n================================================================ 1 error in 0.03s ================================================================\r\n```\nThanks @jaraco, I can reproduce the issue (also verified that #12169 does not fix this).\r\n\r\nWill investigate which incantation is necessary for this to work. \r\n\r\nCurrently we import modules in `--importmode=importlib` using this snippet:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/74f05648d5ea9e69d75f27a77972756ee32f6730/src/_pytest/pathlib.py#L635-L641\r\n\r\n \nI found an issue that might be related. If not, please direct me in the right direction.\r\n\r\nMy problem so far is that I haven\u2019t figured out a minimal reproducer yet: Somehow the `_frozen_importlib_external.PathFinder` finds the a namespace module for our real life example but not in the test suite.\r\n\r\n<details>\r\n\r\n<summary>Minimal (not yet) reproducer:</summary>\r\n\r\n```console\r\n$ mkdir bar\r\n$ mkdir foo\r\n$ touch foo/bar.py\r\n$ tree \r\n+ foo/\r\n|  + bar.py\r\n+ bar/\r\n```\r\n\r\nNow running a pytest test that imports `foo.bar` leads to this traceback (simplified, oldest to newest)\r\n\r\n```py\r\nmod = import_path('foo/bar.py', mode='importlib', root='.')\r\n\u2192\r\nmod = _import_module_using_spec('foo.bar', 'foo/bar.py', '.')\r\n\u2192\r\nspec = meta_importer.find_spec('foo.bar', ['.'])\r\n```\r\n\r\nwhere `meta_importer` is a `_frozen_importlib_external.PathFinder` instance, and the module created from the spec returned by the last expression is\r\n\r\n```\r\n>>> importlib.util.module_from_spec(spec)\r\n<module 'foo.bar' (namespace) from ['./bar']>\r\n```\r\n\r\ninstead of\r\n\r\n```\r\n>>> importlib.util.module_from_spec(spec)\r\n<module 'foo.bar' from ['./foo/bar.py']>\r\n```\r\n\r\nThe documentation of [`MetaPathFinder.find_spec`](https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec) says:\r\n\r\n>  If this is a top-level import, path will be None.\r\n\r\nand since `_import_module_using_spec` says it \u201cimports a module by its canonical name\u201d, that means `path` *should* be none and you should call\r\n\r\n```py\r\nmeta_importer.find_spec('foo.bar', None)\r\n```\r\n\r\nright?\r\n\r\n</details>\nThanks for the tip. I did find that adding this patch works around the issue (at least in the repro):\r\n\r\n```diff\r\ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\r\nindex 254d9d946..bb26a433f 100644\r\n--- a/src/_pytest/pathlib.py\r\n+++ b/src/_pytest/pathlib.py\r\n@@ -638,6 +638,7 @@ def _import_module_using_spec(\r\n         assert spec is not None\r\n         mod = importlib.util.module_from_spec(spec)\r\n         sys.modules[module_name] = mod\r\n+        _set_name_in_parent(mod)\r\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\r\n         if insert_modules:\r\n             insert_missing_modules(sys.modules, module_name)\r\n@@ -646,6 +647,13 @@ def _import_module_using_spec(\r\n     return None\r\n \r\n \r\n+def _set_name_in_parent(mod):\r\n+    parent, sep, name = mod.__name__.rpartition(\".\")\r\n+    if not sep:\r\n+        return\r\n+    setattr(sys.modules[parent], name, mod)\r\n+\r\n+\r\n def spec_matches_module_path(\r\n     module_spec: Optional[ModuleSpec], module_path: Path\r\n ) -> bool:\r\n```\r\n\r\nI wonder if there's similar logic in CPython's importlib logic that should be modeled.\nHere's [where that happens in CPython](https://github.com/python/cpython/blob/73906d5c908c1e0b73c5436faeff7d93698fc074/Lib/importlib/_bootstrap.py#L1335-L1342). Doesn't seem to be particularly re-usable, but at least shows how that behavior is implemented there.\nMy issue is fixed with #12169, but I found that the change in #12207 avoids the wrong loader altogether.\r\n\r\n@jaraco does that one fix your problem?", "created_at": "2024-04-12T18:54:49Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12192, "instance_id": "pytest-dev__pytest-12192", "issue_numbers": ["11777", "11777"], "base_commit": "f75dd87eb7f31c4d14c84c18ce97353f51e801d4", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 53f7a8c2a16..cc054bfd978 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -137,6 +137,7 @@ Endre Galaczi\n Eric Hunsberger\n Eric Liu\n Eric Siegerman\n+Eric Yuan\n Erik Aronesty\n Erik Hasse\n Erik M. Bray\n@@ -432,6 +433,7 @@ Xixi Zhao\n Xuan Luong\n Xuecong Liao\n Yannick P\u00e9roux\n+Yao Xiao\n Yoav Caspi\n Yuliang Shao\n Yusuke Kadowaki\ndiff --git a/changelog/11777.improvement.rst b/changelog/11777.improvement.rst\nnew file mode 100644\nindex 00000000000..fb53c63c10a\n--- /dev/null\n+++ b/changelog/11777.improvement.rst\n@@ -0,0 +1,1 @@\n+Text is no longer truncated in the ``short test summary info`` section when ``-vv`` is given.\n", "test_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex 973168dc6ff..724d5c54d2f 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -1408,11 +1408,11 @@ def _get_line_with_reprcrash_message(\n     except AttributeError:\n         pass\n     else:\n-        if not running_on_ci():\n+        if running_on_ci() or config.option.verbose >= 2:\n+            msg = f\" - {msg}\"\n+        else:\n             available_width = tw.fullwidth - line_width\n             msg = _format_trimmed(\" - {}\", msg, available_width)\n-        else:\n-            msg = f\" - {msg}\"\n         if msg is not None:\n             line += msg\n \ndiff --git a/testing/test_terminal.py b/testing/test_terminal.py\nindex f4942510991..170f1efcf91 100644\n--- a/testing/test_terminal.py\n+++ b/testing/test_terminal.py\n@@ -2377,8 +2377,13 @@ def mock_get_pos(*args):\n \n     monkeypatch.setattr(_pytest.terminal, \"_get_node_id_with_markup\", mock_get_pos)\n \n+    class Namespace:\n+        def __init__(self, **kwargs):\n+            self.__dict__.update(kwargs)\n+\n     class config:\n-        pass\n+        def __init__(self):\n+            self.option = Namespace(verbose=0)\n \n     class rep:\n         def _get_verbose_word(self, *args):\n@@ -2399,7 +2404,7 @@ def markup(self, word: str, **markup: str):\n         if msg:\n             rep.longrepr.reprcrash.message = msg  # type: ignore\n         actual = _get_line_with_reprcrash_message(\n-            config,  # type: ignore[arg-type]\n+            config(),  # type: ignore[arg-type]\n             rep(),  # type: ignore[arg-type]\n             DummyTerminalWriter(),  # type: ignore[arg-type]\n             {},\n@@ -2443,6 +2448,43 @@ def markup(self, word: str, **markup: str):\n     check(\"\ud83c\ude50\ud83c\ude50\ud83c\ude50\ud83c\ude50\ud83c\ude50\\n2nd line\", 80, \"FAILED nodeid::\ud83c\ude50::withunicode - \ud83c\ude50\ud83c\ude50\ud83c\ude50\ud83c\ude50\ud83c\ude50\")\n \n \n+def test_short_summary_with_verbose(\n+    monkeypatch: MonkeyPatch, pytester: Pytester\n+) -> None:\n+    \"\"\"With -vv do not truncate the summary info (#11777).\"\"\"\n+    # On CI we also do not truncate the summary info, monkeypatch it to ensure we\n+    # are testing against the -vv flag on CI.\n+    monkeypatch.setattr(_pytest.terminal, \"running_on_ci\", lambda: False)\n+\n+    string_length = 200\n+    pytester.makepyfile(\n+        f\"\"\"\n+        def test():\n+            s1 = \"A\" * {string_length}\n+            s2 = \"B\" * {string_length}\n+            assert s1 == s2\n+        \"\"\"\n+    )\n+\n+    # No -vv, summary info should be truncated.\n+    result = pytester.runpytest()\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*short test summary info*\",\n+            \"* assert 'AAA...\",\n+        ],\n+    )\n+\n+    # No truncation with -vv.\n+    result = pytester.runpytest(\"-vv\")\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*short test summary info*\",\n+            f\"*{'A' * string_length}*{'B' * string_length}'\",\n+        ]\n+    )\n+\n+\n @pytest.mark.parametrize(\n     \"seconds, expected\",\n     [\n", "problem_statement": "Verbosity setting does not affect truncation of sequences when comparing their length\nIf a comparison on the length of a sequence fails, the sequence is truncated in the failure explanation regardless of the verbosity setting.\r\n\r\nExample script:\r\n\r\n```python\r\ndef test_list():\r\n    l = list(range(50))\r\n    assert l == []\r\n\r\ndef test_list_len():\r\n    l = list(range(50))\r\n    assert len(l) == 49\r\n\r\ndef test_dict():\r\n    d = dict(zip(range(50), range(50)))\r\n    assert d == {}\r\n\r\ndef test_dict_len():\r\n    d = dict(zip(range(50), range(50)))\r\n    assert len(d) == 49\r\n```\r\nOutput of `python3 -m pytest test_truncation.py`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       assert [0, 1, 2, 3, 4, 5, ...] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Use -v to get more diff\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,...\r\nE         \r\nE         ...Full output truncated (45 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - assert [0, 1, 2, 3, 4, 5, ...] == []\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nOutput of `python3 -m pytest test_truncation.py -v`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       AssertionError: assert [0, 1, 2, 3, 4, 5, ...] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Full diff:\r\nE           [\r\nE         -  ,\r\nE         +  0,\r\nE         ?  +\r\nE         +  1,...\r\nE         \r\nE         ...Full output truncated (49 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,...\r\nE         \r\nE         ...Full output truncated (98 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - AssertionError: assert [0, 1, 2, 3, 4, 5, ...] == []\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nOutput of `python3 -m pytest test_truncation.py -vv`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       assert [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Full diff:\r\nE           [\r\nE         -  ,\r\nE         +  0,\r\nE         ?  +\r\nE         +  1,\r\nE         +  2,\r\nE         +  3,\r\nE         +  4,\r\nE         +  5,\r\nE         +  6,\r\nE         +  7,\r\nE         +  8,\r\nE         +  9,\r\nE         +  10,\r\nE         +  11,\r\nE         +  12,\r\nE         +  13,\r\nE         +  14,\r\nE         +  15,\r\nE         +  16,\r\nE         +  17,\r\nE         +  18,\r\nE         +  19,\r\nE         +  20,\r\nE         +  21,\r\nE         +  22,\r\nE         +  23,\r\nE         +  24,\r\nE         +  25,\r\nE         +  26,\r\nE         +  27,\r\nE         +  28,\r\nE         +  29,\r\nE         +  30,\r\nE         +  31,\r\nE         +  32,\r\nE         +  33,\r\nE         +  34,\r\nE         +  35,\r\nE         +  36,\r\nE         +  37,\r\nE         +  38,\r\nE         +  39,\r\nE         +  40,\r\nE         +  41,\r\nE         +  42,\r\nE         +  43,\r\nE         +  44,\r\nE         +  45,\r\nE         +  46,\r\nE         +  47,\r\nE         +  48,\r\nE         +  49,\r\nE           ]\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       assert {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,\r\nE          6: 6,\r\nE          7: 7,\r\nE          8: 8,\r\nE          9: 9,\r\nE          10: 10,\r\nE          11: 11,\r\nE          12: 12,\r\nE          13: 13,\r\nE          14: 14,\r\nE          15: 15,\r\nE          16: 16,\r\nE          17: 17,\r\nE          18: 18,\r\nE          19: 19,\r\nE          20: 20,\r\nE          21: 21,\r\nE          22: 22,\r\nE          23: 23,\r\nE          24: 24,\r\nE          25: 25,\r\nE          26: 26,\r\nE          27: 27,\r\nE          28: 28,\r\nE          29: 29,\r\nE          30: 30,\r\nE          31: 31,\r\nE          32: 32,\r\nE          33: 33,\r\nE          34: 34,\r\nE          35: 35,\r\nE          36: 36,\r\nE          37: 37,\r\nE          38: 38,\r\nE          39: 39,\r\nE          40: 40,\r\nE          41: 41,\r\nE          42: 42,\r\nE          43: 43,\r\nE          44: 44,\r\nE          45: 45,\r\nE          46: 46,\r\nE          47: 47,\r\nE          48: 48,\r\nE          49: 49}\r\nE         Full diff:\r\nE           {\r\nE         -  ,\r\nE         +  0: 0,\r\nE         +  1: 1,\r\nE         +  2: 2,\r\nE         +  3: 3,\r\nE         +  4: 4,\r\nE         +  5: 5,\r\nE         +  6: 6,\r\nE         +  7: 7,\r\nE         +  8: 8,\r\nE         +  9: 9,\r\nE         +  10: 10,\r\nE         +  11: 11,\r\nE         +  12: 12,\r\nE         +  13: 13,\r\nE         +  14: 14,\r\nE         +  15: 15,\r\nE         +  16: 16,\r\nE         +  17: 17,\r\nE         +  18: 18,\r\nE         +  19: 19,\r\nE         +  20: 20,\r\nE         +  21: 21,\r\nE         +  22: 22,\r\nE         +  23: 23,\r\nE         +  24: 24,\r\nE         +  25: 25,\r\nE         +  26: 26,\r\nE         +  27: 27,\r\nE         +  28: 28,\r\nE         +  29: 29,\r\nE         +  30: 30,\r\nE         +  31: 31,\r\nE         +  32: 32,\r\nE         +  33: 33,\r\nE         +  34: 34,\r\nE         +  35: 35,\r\nE         +  36: 36,\r\nE         +  37: 37,\r\nE         +  38: 38,\r\nE         +  39: 39,\r\nE         +  40: 40,\r\nE         +  41: 41,\r\nE         +  42: 42,\r\nE         +  43: 43,\r\nE         +  44: 44,\r\nE         +  45: 45,\r\nE         +  46: 46,\r\nE         +  47: 47,\r\nE         +  48: 48,\r\nE         +  49: 49,\r\nE           }\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - assert [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,...\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - assert {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 1...\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nWhy are the sequences always truncated in the explanations of the length comparison failures, regardless of verbosity?\r\n\r\nPython 3.10.12, pytest-7.4.4, my OS is Linux Mint 21.2.\r\n\r\n`pip list` output attached:\r\n\r\n[pip_list.txt](https://github.com/pytest-dev/pytest/files/13845351/pip_list.txt)\nVerbosity setting does not affect truncation of sequences when comparing their length\nIf a comparison on the length of a sequence fails, the sequence is truncated in the failure explanation regardless of the verbosity setting.\r\n\r\nExample script:\r\n\r\n```python\r\ndef test_list():\r\n    l = list(range(50))\r\n    assert l == []\r\n\r\ndef test_list_len():\r\n    l = list(range(50))\r\n    assert len(l) == 49\r\n\r\ndef test_dict():\r\n    d = dict(zip(range(50), range(50)))\r\n    assert d == {}\r\n\r\ndef test_dict_len():\r\n    d = dict(zip(range(50), range(50)))\r\n    assert len(d) == 49\r\n```\r\nOutput of `python3 -m pytest test_truncation.py`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       assert [0, 1, 2, 3, 4, 5, ...] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Use -v to get more diff\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,...\r\nE         \r\nE         ...Full output truncated (45 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - assert [0, 1, 2, 3, 4, 5, ...] == []\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nOutput of `python3 -m pytest test_truncation.py -v`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       AssertionError: assert [0, 1, 2, 3, 4, 5, ...] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Full diff:\r\nE           [\r\nE         -  ,\r\nE         +  0,\r\nE         ?  +\r\nE         +  1,...\r\nE         \r\nE         ...Full output truncated (49 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,...\r\nE         \r\nE         ...Full output truncated (98 lines hidden), use '-vv' to show\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - AssertionError: assert [0, 1, 2, 3, 4, 5, ...] == []\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - AssertionError: assert {0: 0, 1: 1, 2: 2, 3: 3, ...} == {}\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nOutput of `python3 -m pytest test_truncation.py -vv`:\r\n\r\n```\r\n====================================================== FAILURES ======================================================\r\n_____________________________________________________ test_list ______________________________________________________\r\n\r\n    def test_list():\r\n        l = list(range(50))\r\n>       assert l == []\r\nE       assert [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] == []\r\nE         Left contains 50 more items, first extra item: 0\r\nE         Full diff:\r\nE           [\r\nE         -  ,\r\nE         +  0,\r\nE         ?  +\r\nE         +  1,\r\nE         +  2,\r\nE         +  3,\r\nE         +  4,\r\nE         +  5,\r\nE         +  6,\r\nE         +  7,\r\nE         +  8,\r\nE         +  9,\r\nE         +  10,\r\nE         +  11,\r\nE         +  12,\r\nE         +  13,\r\nE         +  14,\r\nE         +  15,\r\nE         +  16,\r\nE         +  17,\r\nE         +  18,\r\nE         +  19,\r\nE         +  20,\r\nE         +  21,\r\nE         +  22,\r\nE         +  23,\r\nE         +  24,\r\nE         +  25,\r\nE         +  26,\r\nE         +  27,\r\nE         +  28,\r\nE         +  29,\r\nE         +  30,\r\nE         +  31,\r\nE         +  32,\r\nE         +  33,\r\nE         +  34,\r\nE         +  35,\r\nE         +  36,\r\nE         +  37,\r\nE         +  38,\r\nE         +  39,\r\nE         +  40,\r\nE         +  41,\r\nE         +  42,\r\nE         +  43,\r\nE         +  44,\r\nE         +  45,\r\nE         +  46,\r\nE         +  47,\r\nE         +  48,\r\nE         +  49,\r\nE           ]\r\n\r\ntest_truncation.py:3: AssertionError\r\n___________________________________________________ test_list_len ____________________________________________________\r\n\r\n    def test_list_len():\r\n        l = list(range(50))\r\n>       assert len(l) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len([0, 1, 2, 3, 4, 5, ...])\r\n\r\ntest_truncation.py:7: AssertionError\r\n_____________________________________________________ test_dict ______________________________________________________\r\n\r\n    def test_dict():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert d == {}\r\nE       assert {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49} == {}\r\nE         Left contains 50 more items:\r\nE         {0: 0,\r\nE          1: 1,\r\nE          2: 2,\r\nE          3: 3,\r\nE          4: 4,\r\nE          5: 5,\r\nE          6: 6,\r\nE          7: 7,\r\nE          8: 8,\r\nE          9: 9,\r\nE          10: 10,\r\nE          11: 11,\r\nE          12: 12,\r\nE          13: 13,\r\nE          14: 14,\r\nE          15: 15,\r\nE          16: 16,\r\nE          17: 17,\r\nE          18: 18,\r\nE          19: 19,\r\nE          20: 20,\r\nE          21: 21,\r\nE          22: 22,\r\nE          23: 23,\r\nE          24: 24,\r\nE          25: 25,\r\nE          26: 26,\r\nE          27: 27,\r\nE          28: 28,\r\nE          29: 29,\r\nE          30: 30,\r\nE          31: 31,\r\nE          32: 32,\r\nE          33: 33,\r\nE          34: 34,\r\nE          35: 35,\r\nE          36: 36,\r\nE          37: 37,\r\nE          38: 38,\r\nE          39: 39,\r\nE          40: 40,\r\nE          41: 41,\r\nE          42: 42,\r\nE          43: 43,\r\nE          44: 44,\r\nE          45: 45,\r\nE          46: 46,\r\nE          47: 47,\r\nE          48: 48,\r\nE          49: 49}\r\nE         Full diff:\r\nE           {\r\nE         -  ,\r\nE         +  0: 0,\r\nE         +  1: 1,\r\nE         +  2: 2,\r\nE         +  3: 3,\r\nE         +  4: 4,\r\nE         +  5: 5,\r\nE         +  6: 6,\r\nE         +  7: 7,\r\nE         +  8: 8,\r\nE         +  9: 9,\r\nE         +  10: 10,\r\nE         +  11: 11,\r\nE         +  12: 12,\r\nE         +  13: 13,\r\nE         +  14: 14,\r\nE         +  15: 15,\r\nE         +  16: 16,\r\nE         +  17: 17,\r\nE         +  18: 18,\r\nE         +  19: 19,\r\nE         +  20: 20,\r\nE         +  21: 21,\r\nE         +  22: 22,\r\nE         +  23: 23,\r\nE         +  24: 24,\r\nE         +  25: 25,\r\nE         +  26: 26,\r\nE         +  27: 27,\r\nE         +  28: 28,\r\nE         +  29: 29,\r\nE         +  30: 30,\r\nE         +  31: 31,\r\nE         +  32: 32,\r\nE         +  33: 33,\r\nE         +  34: 34,\r\nE         +  35: 35,\r\nE         +  36: 36,\r\nE         +  37: 37,\r\nE         +  38: 38,\r\nE         +  39: 39,\r\nE         +  40: 40,\r\nE         +  41: 41,\r\nE         +  42: 42,\r\nE         +  43: 43,\r\nE         +  44: 44,\r\nE         +  45: 45,\r\nE         +  46: 46,\r\nE         +  47: 47,\r\nE         +  48: 48,\r\nE         +  49: 49,\r\nE           }\r\n\r\ntest_truncation.py:11: AssertionError\r\n___________________________________________________ test_dict_len ____________________________________________________\r\n\r\n    def test_dict_len():\r\n        d = dict(zip(range(50), range(50)))\r\n>       assert len(d) == 49\r\nE       assert 50 == 49\r\nE        +  where 50 = len({0: 0, 1: 1, 2: 2, 3: 3, ...})\r\n\r\ntest_truncation.py:15: AssertionError\r\n============================================== short test summary info ===============================================\r\nFAILED test_truncation.py::test_list - assert [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,...\r\nFAILED test_truncation.py::test_list_len - assert 50 == 49\r\nFAILED test_truncation.py::test_dict - assert {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 1...\r\nFAILED test_truncation.py::test_dict_len - assert 50 == 49\r\n```\r\n\r\nWhy are the sequences always truncated in the explanations of the length comparison failures, regardless of verbosity?\r\n\r\nPython 3.10.12, pytest-7.4.4, my OS is Linux Mint 21.2.\r\n\r\n`pip list` output attached:\r\n\r\n[pip_list.txt](https://github.com/pytest-dev/pytest/files/13845351/pip_list.txt)\n", "hints_text": "Hi! I can try working on this.\nHi! I can try working on this.", "created_at": "2024-04-06T22:14:56Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12190, "instance_id": "pytest-dev__pytest-12190", "issue_numbers": ["9502"], "base_commit": "f75dd87eb7f31c4d14c84c18ce97353f51e801d4", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 53f7a8c2a16..3d1ecf98604 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -118,6 +118,7 @@ Daw-Ran Liou\n Debi Mishra\n Denis Kirisov\n Denivy Braiam R\u00fcck\n+Dheeraj C K\n Dhiren Serai\n Diego Russo\n Dmitry Dygalo\ndiff --git a/changelog/9502.improvement.rst b/changelog/9502.improvement.rst\nnew file mode 100644\nindex 00000000000..2eaf6a72747\n--- /dev/null\n+++ b/changelog/9502.improvement.rst\n@@ -0,0 +1,1 @@\n+Added :envvar:`PYTEST_VERSION` environment variable which is defined at the start of the pytest session and undefined afterwards. It contains the value of ``pytest.__version__``, and among other things can be used to easily check if code is running from within a pytest run.\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 21890fbf63e..30ba4301d9d 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1117,6 +1117,11 @@ When set (regardless of value), pytest acknowledges that is running in a CI proc\n This contains a command-line (parsed by the py:mod:`shlex` module) that will be **prepended** to the command line given\n by the user, see :ref:`adding default options` for more information.\n \n+.. envvar:: PYTEST_VERSION\n+\n+This environment variable is defined at the start of the pytest session and is undefined afterwards.\n+It contains the value of ``pytest.__version__``, and among other things can be used to easily check if a code is running from within a pytest run.\n+\n .. envvar:: PYTEST_CURRENT_TEST\n \n This is not meant to be set by users, but is set by pytest internally with the name of the current test so other\n", "test_patch": "diff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex 7ff27643f10..306b14cce28 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -50,6 +50,7 @@\n from .exceptions import PrintHelp as PrintHelp\n from .exceptions import UsageError as UsageError\n from .findpaths import determine_setup\n+from _pytest import __version__\n import _pytest._code\n from _pytest._code import ExceptionInfo\n from _pytest._code import filter_traceback\n@@ -151,7 +152,9 @@ def main(\n \n     :returns: An exit code.\n     \"\"\"\n+    old_pytest_version = os.environ.get(\"PYTEST_VERSION\")\n     try:\n+        os.environ[\"PYTEST_VERSION\"] = __version__\n         try:\n             config = _prepareconfig(args, plugins)\n         except ConftestImportFailure as e:\n@@ -186,6 +189,11 @@ def main(\n         for msg in e.args:\n             tw.line(f\"ERROR: {msg}\\n\", red=True)\n         return ExitCode.USAGE_ERROR\n+    finally:\n+        if old_pytest_version is None:\n+            os.environ.pop(\"PYTEST_VERSION\", None)\n+        else:\n+            os.environ[\"PYTEST_VERSION\"] = old_pytest_version\n \n \n def console_main() -> int:\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 8cc496f7064..d3ddc5d9acb 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -1094,3 +1094,20 @@ def func() -> None:\n     with pytest.raises(TypeError) as excinfo:\n         OutcomeException(func)  # type: ignore\n     assert str(excinfo.value) == expected\n+\n+\n+def test_pytest_version_env_var(pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n+    os.environ[\"PYTEST_VERSION\"] = \"old version\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        import os\n+\n+\n+        def test():\n+            assert os.environ.get(\"PYTEST_VERSION\") == pytest.__version__\n+    \"\"\"\n+    )\n+    result = pytester.runpytest_inprocess()\n+    assert result.ret == ExitCode.OK\n+    assert os.environ[\"PYTEST_VERSION\"] == \"old version\"\n", "problem_statement": "Add a function to detect if pytest is running\n#### What's the problem this feature will solve?\r\n\r\nDjango settings modules often load environment variables from a `.env` file:\r\n\r\n```python\r\nfrom pathlib import Path\r\n\r\nimport dotenv\r\n\r\nBASE_DIR = Path(__file__).resolve().parent.parent\r\n\r\ndotenv.load_dotenv(dotenv_path=BASE_DIR / \".env\")\r\n```\r\n\r\nLoading from `.env` is not desirable during test runs. Environment variables added for local debugging may affect the test run in unexpected ways, such as making remote API calls.\r\n\r\nThe settings module should therefore only load the `.env` file if pytest isn't running:\r\n\r\n```python\r\nfrom pathlib import Path\r\n\r\nimport dotenv\r\n\r\nBASE_DIR = Path(__file__).resolve().parent.parent\r\n\r\nif ... # pytest is not running\r\n    dotenv.load_dotenv(dotenv_path=BASE_DIR / \".env\")\r\n```\r\n\r\nChanging behaviour during tests is usually undesirable, but here it's done to isolate the test run, which is a good thing.\r\n\r\npytest documents a pattern to change behaviour using fixtures here: https://docs.pytest.org/en/latest/example/simple.html#detect-if-running-from-within-a-pytest-run . Unfortunately this techinque is incompatible with this particular problem. pytest-django's fixtures load the settings module early, before fixtures from `conftest.py` fixtures run, so the pattern cannot be applied. And environment variable changes cannot be undone after the fact.\r\n\r\nTo solve this I made [pytest-is-running](https://github.com/adamchainz/pytest-is-running), which can be used like so:\r\n\r\n```python\r\nfrom pathlib import Path\r\n\r\nimport dotenv\r\nimport pytest_is_running\r\n\r\nBASE_DIR = Path(__file__).resolve().parent.parent\r\n\r\nif not pytest_is_running.is_running():\r\n    dotenv.load_dotenv(dotenv_path=BASE_DIR / \".env\")\r\n```\r\n\r\npytest-is-running works because plugin fixtures can load early, and it uses hooks with `tryfirst=True`.\r\n\r\n#### Describe the solution you'd like\r\n\r\nRather than have a documented workaround and plugin, I'd like to see a function in core pytest that provides the ability to check if pytest is running. It could simplify things for those using the both the documented pattern and the plugin.\r\n\r\nIt would also be good if the solution could somehow avoid the cost of doing `import pytest`, so that non-test pathways do not import the heap of stuff in pytest only to ignore it because pytest isn't running. The plugin is deliberately structured to avoid this.\r\n\r\n#### Alternative Solutions\r\n\r\nI wrote the plugin.\r\n\r\n#### Additional context\r\n\r\nnone\r\n\n", "hints_text": "We currently just [document how to do this](https://pytest.org/en/6.2.x/example/simple.html#detect-if-running-from-within-a-pytest-run), probably in a way similarly to what your plugin does.\r\n\r\nNote you could also just check `if \"pytest\" in sys.modules:` as long as your code under test does not import pytest.\r\n\r\nWe do have a `PYTEST_CURRENT_TEST` environment variable already. Personally I'd be fine with having a `PYTEST_VERSION` or whatever which gets set very early, I suppose `PYTEST_CURRENT_TEST` will be set too late for it to be useful at import time.\nAlso see https://github.com/pytest-dev/pytest-django/issues/333 which has some additional considerations and use-cases around this.\n> Personally I'd be fine with having a PYTEST_VERSION or whatever which gets set very early,\r\n\r\nI'm OK with this solution. It would also remove that env var from `os.environ` at the end of `pytest.main()`, I assume?\nA while ago I had an idle thought that something like this should be a *python* feature. I was thinking a builtin constant `__test__`, similar to [`__debug__`](https://docs.python.org/3/library/constants.html#debug__), that would normally be false, but that a test runner would set to true while discovering and running tests.\r\n\r\nIn the Rust language for example it is very common to interleave unit tests with the code they're testing in the same file using [an attribute](https://doc.rust-lang.org/book/ch11-03-test-organization.html). In Python this would be:\r\n\r\n```py\r\ndef fibonacci(n): ...\r\n\r\nif __test__:\r\n    import pytest\r\n\r\n    def test_fibonacci(n):\r\n        assert fibonacci(10) == 55\r\n\r\n        with pytest.raises(ValueError):\r\n            fibonacci(-1)\r\n\r\ndef factorial(n): ...\r\n\r\nif __test__:\r\n    def test_factorial(n):\r\n        assert factorial(50) == 30414093201713378043612608166064768844377641568960512000000000000\r\n```\r\n\r\nNot for everyone, but I think there are cases I would have used this.\nafter the drop of python 3.6 we can use https://docs.python.org/3/library/contextvars.html\r\n\r\ni would propose to use this for gathering whether pytest is running\r\n\r\ni woudl strictly oppose exposing sometihng like config as a contextvar however unless we had a stack for nested pytest session\n> We currently just [document how to do this](https://pytest.org/en/6.2.x/example/simple.html#detect-if-running-from-within-a-pytest-run), probably in a way similarly to what your plugin does.\r\n\r\nYes, I noted in the description why this doesn't work for the case of the django settings file \ud83d\ude0a\r\n\r\n---\r\n\r\nI like the idea of the `PYTEST_VERSION` (or whatever) environment variable. This is general and wouldn't require `import pytest` in production code. Yes it should be popped out of `os.environ` after pytest completes its run.\r\n\r\nA `__test__` builtin would be interesting, but it wouldn't be so easy to add. If it was only set by pytest, it wouldn't exist without importing pytest, unless it were actually added to Python, and placed in a backports package.\r\n\r\ncontextvars seem like they'd also require `import pytest` to use, since the var must be defined in a module\u2014unless pytest shipped a side module to contain the var?\nOne can use `sys.modules.get` in such helpers\n\nPersonally im -1 on adding easy and obvious fast paths to make it easy to keep messy global configuration around\n\nThis stems from stuff going horrendously wrong every time a project uses that and then suddenly some tests need to run with different configurations or multiple configurations \n> One can use `sys.modules.get` in such helpers\r\n\r\n\ud83e\udd14 Idk why I didn't think of that, thanks for the hint.\r\n\r\nI think for now I will try `\"pytest\" in sys.modules` instead of my plugin.\r\n\r\nAgree that it can go wrong as complexity creeps in.\nI stopped my overengineering when I arrived at:\r\n\r\n```python\r\ndef we_are_running_via_pytest() -> bool:\r\n    \"\"\"Detect if we are running via pytest.\"\"\"\r\n    # When we are running via pytest it is loaded to the sys modules dictionary.\r\n    _we_are_running_via_pytest: bool = 'pytest' in sys.modules\r\n    return _we_are_running_via_pytest\r\n```\r\n\r\nSource: <https://docs.python.org/3/library/sys.html#sys.modules>\r\n\r\nUse it like so:\r\n\r\n```python\r\ndef get_configuration() -> Configuration:\r\n    configuration: Configuration\r\n\r\n    if we_are_running_via_pytest():\r\n        print('Creating test configuration.')\r\n        configuration = _get_test_configuration()\r\n    else:\r\n        print('Creating runtime configuration.')\r\n        configuration = _get_runtime_configuration()\r\n\r\n    return configuration\r\n```\nThanks everyone!\r\n\r\nI'm closing this for now, with the recommended solution being:\r\n\r\n```python\r\nis_running_pytest = \"pytest\" in sys.modules\r\n```\r\n\r\nIf somebody wants to contribute that to the documentation, it would be great!\nBut I think \"pytest\" in sys.modules returning True if theres a pytest import makes it kinda error prone\nThis might be over engineered but I think this works better and helps to avoid one of the edge case with ` \"pytest\" in sys.modules`\r\n\r\n```\r\nimport os\r\nimport inspect\r\nimport sys\r\n\r\n# List of pytest related files\r\npytest_related_files = (\r\n    os.path.join('_pytest', 'python_path.py'),\r\n    os.path.join('_pytest', 'logging.py'),\r\n    os.path.join('_pytest', 'main.py'),\r\n    os.path.join('_pytest', 'runner.py'),\r\n    os.path.join('_pytest', 'config', '__init__.py'),\r\n    os.path.join('_pytest', 'debugging.py')\r\n)\r\n\r\n# Check if any of the pytest related files are in the current stack\r\nis_pytest_in_stack = any(frame.filename.endswith(pytest_related_files) for frame in inspect.stack())\r\n\r\n# Check if a pytest is currently running\r\nis_pytest_running = os.environ.get(\"PYTEST_CURRENT_TEST\")\r\n\r\n# Check if pytest module is imported\r\n# We probably dont need to use this as, if one of the other two condition is True, this should be True\r\nis_pytest_imported = \"pytest\" in sys.modules \r\n\r\nif is_pytest_imported and (is_pytest_in_stack or is_pytest_running):\r\n    print(True)\r\nelse:\r\n    print(False)\r\n```\r\n\r\nDo let me know if theres a case where this will not work\ntoo many magic constants\n`inspect.stack()` is also relatively slow as it makes Python build all the frame objects. Checking for `PYTEST_CURRENT_TEST` is a good idea if you want something a bit more robust than than the `sys.modules` check. But IMO the `sys.modules` check is good enough for most projects, it should be exceedingly rare to import pytest outside of the test process.\r\n\r\nI archived my [pytest-is-running](https://github.com/adamchainz/pytest-is-running) project btw.", "created_at": "2024-04-06T07:01:37Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12169, "instance_id": "pytest-dev__pytest-12169", "issue_numbers": ["12112"], "base_commit": "f75dd87eb7f31c4d14c84c18ce97353f51e801d4", "patch": "diff --git a/changelog/12112.improvement.rst b/changelog/12112.improvement.rst\nnew file mode 100644\nindex 00000000000..3f997b2af65\n--- /dev/null\n+++ b/changelog/12112.improvement.rst\n@@ -0,0 +1,1 @@\n+Improve namespace packages detection when :confval:`consider_namespace_packages` is enabled, covering more situations (like editable installs).\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 21890fbf63e..c9d7aeb552c 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1279,8 +1279,7 @@ passed multiple times. The expected format is ``name=value``. For example::\n    Controls if pytest should attempt to identify `namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages>`__\n    when collecting Python modules. Default is ``False``.\n \n-   Set to ``True`` if you are testing namespace packages installed into a virtual environment and it is important for\n-   your packages to be imported using their full namespace package name.\n+   Set to ``True`` if the package you are testing is part of a namespace package.\n \n    Only `native namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#native-namespace-packages>`__\n    are supported, with no plans to support `legacy namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#legacy-namespace-packages>`__.\n", "test_patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e39f4772326..254d9d9468e 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -8,6 +8,7 @@\n from errno import ENOTDIR\n import fnmatch\n from functools import partial\n+from importlib.machinery import ModuleSpec\n import importlib.util\n import itertools\n import os\n@@ -628,11 +629,13 @@ def _import_module_using_spec(\n     # such as our own assertion-rewrite hook.\n     for meta_importer in sys.meta_path:\n         spec = meta_importer.find_spec(module_name, [str(module_location)])\n-        if spec is not None:\n+        if spec_matches_module_path(spec, module_path):\n             break\n     else:\n         spec = importlib.util.spec_from_file_location(module_name, str(module_path))\n-    if spec is not None:\n+\n+    if spec_matches_module_path(spec, module_path):\n+        assert spec is not None\n         mod = importlib.util.module_from_spec(spec)\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n@@ -643,6 +646,16 @@ def _import_module_using_spec(\n     return None\n \n \n+def spec_matches_module_path(\n+    module_spec: Optional[ModuleSpec], module_path: Path\n+) -> bool:\n+    \"\"\"Return true if the given ModuleSpec can be used to import the given module path.\"\"\"\n+    if module_spec is None or module_spec.origin is None:\n+        return False\n+\n+    return Path(module_spec.origin) == module_path\n+\n+\n # Implement a special _is_same function on Windows which returns True if the two filenames\n # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).\n if sys.platform.startswith(\"win\"):\n@@ -762,39 +775,79 @@ def resolve_pkg_root_and_module_name(\n     Passing the full path to `models.py` will yield Path(\"src\") and \"app.core.models\".\n \n     If consider_namespace_packages is True, then we additionally check upwards in the hierarchy\n-    until we find a directory that is reachable from sys.path, which marks it as a namespace package:\n+    for namespace packages:\n \n     https://packaging.python.org/en/latest/guides/packaging-namespace-packages\n \n     Raises CouldNotResolvePathError if the given path does not belong to a package (missing any __init__.py files).\n     \"\"\"\n+    pkg_root: Optional[Path] = None\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n-        # https://packaging.python.org/en/latest/guides/packaging-namespace-packages/\n-        if consider_namespace_packages:\n-            # Go upwards in the hierarchy, if we find a parent path included\n-            # in sys.path, it means the package found by resolve_package_path()\n-            # actually belongs to a namespace package.\n-            for parent in pkg_root.parents:\n-                # If any of the parent paths has a __init__.py, it means it is not\n-                # a namespace package (see the docs linked above).\n-                if (parent / \"__init__.py\").is_file():\n-                    break\n-                if str(parent) in sys.path:\n-                    # Point the pkg_root to the root of the namespace package.\n-                    pkg_root = parent\n-                    break\n-\n-        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n-        if names[-1] == \"__init__\":\n-            names.pop()\n-        module_name = \".\".join(names)\n-        return pkg_root, module_name\n+    if consider_namespace_packages:\n+        start = pkg_root if pkg_root is not None else path.parent\n+        for candidate in (start, *start.parents):\n+            module_name = compute_module_name(candidate, path)\n+            if module_name and is_importable(module_name, path):\n+                # Point the pkg_root to the root of the namespace package.\n+                pkg_root = candidate\n+                break\n+\n+    if pkg_root is not None:\n+        module_name = compute_module_name(pkg_root, path)\n+        if module_name:\n+            return pkg_root, module_name\n \n     raise CouldNotResolvePathError(f\"Could not resolve for {path}\")\n \n \n+def is_importable(module_name: str, module_path: Path) -> bool:\n+    \"\"\"\n+    Return if the given module path could be imported normally by Python, akin to the user\n+    entering the REPL and importing the corresponding module name directly, and corresponds\n+    to the module_path specified.\n+\n+    :param module_name:\n+        Full module name that we want to check if is importable.\n+        For example, \"app.models\".\n+\n+    :param module_path:\n+        Full path to the python module/package we want to check if is importable.\n+        For example, \"/projects/src/app/models.py\".\n+    \"\"\"\n+    try:\n+        # Note this is different from what we do in ``_import_module_using_spec``, where we explicitly search through\n+        # sys.meta_path to be able to pass the path of the module that we want to import (``meta_importer.find_spec``).\n+        # Using importlib.util.find_spec() is different, it gives the same results as trying to import\n+        # the module normally in the REPL.\n+        spec = importlib.util.find_spec(module_name)\n+    except (ImportError, ValueError, ImportWarning):\n+        return False\n+    else:\n+        return spec_matches_module_path(spec, module_path)\n+\n+\n+def compute_module_name(root: Path, module_path: Path) -> Optional[str]:\n+    \"\"\"Compute a module name based on a path and a root anchor.\"\"\"\n+    try:\n+        path_without_suffix = module_path.with_suffix(\"\")\n+    except ValueError:\n+        # Empty paths (such as Path.cwd()) might break meta_path hooks (like our own assertion rewriter).\n+        return None\n+\n+    try:\n+        relative = path_without_suffix.relative_to(root)\n+    except ValueError:  # pragma: no cover\n+        return None\n+    names = list(relative.parts)\n+    if not names:\n+        return None\n+    if names[-1] == \"__init__\":\n+        names.pop()\n+    return \".\".join(names)\n+\n+\n class CouldNotResolvePathError(Exception):\n     \"\"\"Custom exception raised by resolve_pkg_root_and_module_name.\"\"\"\n \ndiff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 7f740a0607b..f96151bdd44 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -1,5 +1,7 @@\n # mypy: allow-untyped-defs\n import errno\n+import importlib.abc\n+import importlib.machinery\n import os.path\n from pathlib import Path\n import pickle\n@@ -10,12 +12,15 @@\n from typing import Any\n from typing import Generator\n from typing import Iterator\n+from typing import Optional\n+from typing import Sequence\n from typing import Tuple\n import unittest.mock\n \n from _pytest.monkeypatch import MonkeyPatch\n from _pytest.pathlib import bestrelpath\n from _pytest.pathlib import commonpath\n+from _pytest.pathlib import compute_module_name\n from _pytest.pathlib import CouldNotResolvePathError\n from _pytest.pathlib import ensure_deletable\n from _pytest.pathlib import fnmatch_ex\n@@ -25,6 +30,7 @@\n from _pytest.pathlib import ImportMode\n from _pytest.pathlib import ImportPathMismatchError\n from _pytest.pathlib import insert_missing_modules\n+from _pytest.pathlib import is_importable\n from _pytest.pathlib import maybe_delete_a_numbered_dir\n from _pytest.pathlib import module_name_from_path\n from _pytest.pathlib import resolve_package_path\n@@ -33,6 +39,7 @@\n from _pytest.pathlib import symlink_or_skip\n from _pytest.pathlib import visit\n from _pytest.pytester import Pytester\n+from _pytest.pytester import RunResult\n from _pytest.tmpdir import TempPathFactory\n import pytest\n \n@@ -717,12 +724,13 @@ def test_module_name_from_path(self, tmp_path: Path) -> None:\n         assert result == \"_env_310.tests.test_foo\"\n \n     def test_resolve_pkg_root_and_module_name(\n-        self, tmp_path: Path, monkeypatch: MonkeyPatch\n+        self, tmp_path: Path, monkeypatch: MonkeyPatch, pytester: Pytester\n     ) -> None:\n         # Create a directory structure first without __init__.py files.\n         (tmp_path / \"src/app/core\").mkdir(parents=True)\n         models_py = tmp_path / \"src/app/core/models.py\"\n         models_py.touch()\n+\n         with pytest.raises(CouldNotResolvePathError):\n             _ = resolve_pkg_root_and_module_name(models_py)\n \n@@ -738,6 +746,8 @@ def test_resolve_pkg_root_and_module_name(\n \n         # If we add tmp_path to sys.path, src becomes a namespace package.\n         monkeypatch.syspath_prepend(tmp_path)\n+        validate_namespace_package(pytester, [tmp_path], [\"src.app.core.models\"])\n+\n         assert resolve_pkg_root_and_module_name(\n             models_py, consider_namespace_packages=True\n         ) == (\n@@ -1119,39 +1129,56 @@ def test_safe_exists(tmp_path: Path) -> None:\n class TestNamespacePackages:\n     \"\"\"Test import_path support when importing from properly namespace packages.\"\"\"\n \n+    @pytest.fixture(autouse=True)\n+    def setup_imports_tracking(self, monkeypatch: MonkeyPatch) -> None:\n+        monkeypatch.setattr(sys, \"pytest_namespace_packages_test\", [], raising=False)\n+\n     def setup_directories(\n-        self, tmp_path: Path, monkeypatch: MonkeyPatch, pytester: Pytester\n+        self, tmp_path: Path, monkeypatch: Optional[MonkeyPatch], pytester: Pytester\n     ) -> Tuple[Path, Path]:\n+        # Use a code to guard against modules being imported more than once.\n+        # This is a safeguard in case future changes break this invariant.\n+        code = dedent(\n+            \"\"\"\n+            import sys\n+            imported = getattr(sys, \"pytest_namespace_packages_test\", [])\n+            assert __name__ not in imported, f\"{__name__} already imported\"\n+            imported.append(__name__)\n+            sys.pytest_namespace_packages_test = imported\n+            \"\"\"\n+        )\n+\n         # Set up a namespace package \"com.company\", containing\n         # two subpackages, \"app\" and \"calc\".\n         (tmp_path / \"src/dist1/com/company/app/core\").mkdir(parents=True)\n-        (tmp_path / \"src/dist1/com/company/app/__init__.py\").touch()\n-        (tmp_path / \"src/dist1/com/company/app/core/__init__.py\").touch()\n+        (tmp_path / \"src/dist1/com/company/app/__init__.py\").write_text(\n+            code, encoding=\"UTF-8\"\n+        )\n+        (tmp_path / \"src/dist1/com/company/app/core/__init__.py\").write_text(\n+            code, encoding=\"UTF-8\"\n+        )\n         models_py = tmp_path / \"src/dist1/com/company/app/core/models.py\"\n         models_py.touch()\n \n         (tmp_path / \"src/dist2/com/company/calc/algo\").mkdir(parents=True)\n-        (tmp_path / \"src/dist2/com/company/calc/__init__.py\").touch()\n-        (tmp_path / \"src/dist2/com/company/calc/algo/__init__.py\").touch()\n+        (tmp_path / \"src/dist2/com/company/calc/__init__.py\").write_text(\n+            code, encoding=\"UTF-8\"\n+        )\n+        (tmp_path / \"src/dist2/com/company/calc/algo/__init__.py\").write_text(\n+            code, encoding=\"UTF-8\"\n+        )\n         algorithms_py = tmp_path / \"src/dist2/com/company/calc/algo/algorithms.py\"\n-        algorithms_py.touch()\n+        algorithms_py.write_text(code, encoding=\"UTF-8\")\n \n-        # Validate the namespace package by importing it in a Python subprocess.\n-        r = pytester.runpython_c(\n-            dedent(\n-                f\"\"\"\n-                import sys\n-                sys.path.append(r{str(tmp_path / \"src/dist1\")!r})\n-                sys.path.append(r{str(tmp_path / \"src/dist2\")!r})\n-                import com.company.app.core.models\n-                import com.company.calc.algo.algorithms\n-                \"\"\"\n-            )\n+        r = validate_namespace_package(\n+            pytester,\n+            [tmp_path / \"src/dist1\", tmp_path / \"src/dist2\"],\n+            [\"com.company.app.core.models\", \"com.company.calc.algo.algorithms\"],\n         )\n         assert r.ret == 0\n-\n-        monkeypatch.syspath_prepend(tmp_path / \"src/dist1\")\n-        monkeypatch.syspath_prepend(tmp_path / \"src/dist2\")\n+        if monkeypatch is not None:\n+            monkeypatch.syspath_prepend(tmp_path / \"src/dist1\")\n+            monkeypatch.syspath_prepend(tmp_path / \"src/dist2\")\n         return models_py, algorithms_py\n \n     @pytest.mark.parametrize(\"import_mode\", [\"prepend\", \"append\", \"importlib\"])\n@@ -1223,11 +1250,76 @@ def test_incorrect_namespace_package(\n         models_py, algorithms_py = self.setup_directories(\n             tmp_path, monkeypatch, pytester\n         )\n-        # Namespace packages must not have an __init__.py at any of its\n-        # directories; if it does, we then fall back to importing just the\n-        # part of the package containing the __init__.py files.\n+        # Namespace packages must not have an __init__.py at its top-level\n+        # directory; if it does, it is no longer a namespace package, and we fall back\n+        # to importing just the part of the package containing the __init__.py files.\n         (tmp_path / \"src/dist1/com/__init__.py\").touch()\n \n+        # Because of the __init__ file, 'com' is no longer a namespace package:\n+        # 'com.company.app' is importable as a normal module.\n+        # 'com.company.calc' is no longer importable because 'com' is not a namespace package anymore.\n+        r = validate_namespace_package(\n+            pytester,\n+            [tmp_path / \"src/dist1\", tmp_path / \"src/dist2\"],\n+            [\"com.company.app.core.models\", \"com.company.calc.algo.algorithms\"],\n+        )\n+        assert r.ret == 1\n+        r.stderr.fnmatch_lines(\"*No module named 'com.company.calc*\")\n+\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist1\",\n+            \"com.company.app.core.models\",\n+        )\n+\n+        # dist2/com/company will contain a normal Python package.\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            algorithms_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist2/com/company\",\n+            \"calc.algo.algorithms\",\n+        )\n+\n+    def test_detect_meta_path(\n+        self,\n+        tmp_path: Path,\n+        monkeypatch: MonkeyPatch,\n+        pytester: Pytester,\n+    ) -> None:\n+        \"\"\"\n+        resolve_pkg_root_and_module_name() considers sys.meta_path when importing namespace packages.\n+\n+        Regression test for #12112.\n+        \"\"\"\n+\n+        class CustomImporter(importlib.abc.MetaPathFinder):\n+            \"\"\"\n+            Imports the module name \"com\" as a namespace package.\n+\n+            This ensures our namespace detection considers sys.meta_path, which is important\n+            to support all possible ways a module can be imported (for example editable installs).\n+            \"\"\"\n+\n+            def find_spec(\n+                self, name: str, path: Any = None, target: Any = None\n+            ) -> Optional[importlib.machinery.ModuleSpec]:\n+                if name == \"com\":\n+                    spec = importlib.machinery.ModuleSpec(\"com\", loader=None)\n+                    spec.submodule_search_locations = [str(com_root_2), str(com_root_1)]\n+                    return spec\n+                return None\n+\n+        # Setup directories without configuring sys.path.\n+        models_py, algorithms_py = self.setup_directories(\n+            tmp_path, monkeypatch=None, pytester=pytester\n+        )\n+        com_root_1 = tmp_path / \"src/dist1/com\"\n+        com_root_2 = tmp_path / \"src/dist2/com\"\n+\n+        # Because the namespace package is not setup correctly, we cannot resolve it as a namespace package.\n         pkg_root, module_name = resolve_pkg_root_and_module_name(\n             models_py, consider_namespace_packages=True\n         )\n@@ -1235,3 +1327,107 @@ def test_incorrect_namespace_package(\n             tmp_path / \"src/dist1/com/company\",\n             \"app.core.models\",\n         )\n+\n+        # Insert our custom importer, which will recognize the \"com\" directory as a namespace package.\n+        new_meta_path = [CustomImporter(), *sys.meta_path]\n+        monkeypatch.setattr(sys, \"meta_path\", new_meta_path)\n+\n+        # Now we should be able to resolve the path as namespace package.\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist1\",\n+            \"com.company.app.core.models\",\n+        )\n+\n+    @pytest.mark.parametrize(\"insert\", [True, False])\n+    def test_full_ns_packages_without_init_files(\n+        self, pytester: Pytester, tmp_path: Path, monkeypatch: MonkeyPatch, insert: bool\n+    ) -> None:\n+        (tmp_path / \"src/dist1/ns/b/app/bar/test\").mkdir(parents=True)\n+        (tmp_path / \"src/dist1/ns/b/app/bar/m.py\").touch()\n+\n+        if insert:\n+            # The presence of this __init__.py is not a problem, ns.b.app is still part of the namespace package.\n+            (tmp_path / \"src/dist1/ns/b/app/__init__.py\").touch()\n+\n+        (tmp_path / \"src/dist2/ns/a/core/foo/test\").mkdir(parents=True)\n+        (tmp_path / \"src/dist2/ns/a/core/foo/m.py\").touch()\n+\n+        # Validate the namespace package by importing it in a Python subprocess.\n+        r = validate_namespace_package(\n+            pytester,\n+            [tmp_path / \"src/dist1\", tmp_path / \"src/dist2\"],\n+            [\"ns.b.app.bar.m\", \"ns.a.core.foo.m\"],\n+        )\n+        assert r.ret == 0\n+        monkeypatch.syspath_prepend(tmp_path / \"src/dist1\")\n+        monkeypatch.syspath_prepend(tmp_path / \"src/dist2\")\n+\n+        assert resolve_pkg_root_and_module_name(\n+            tmp_path / \"src/dist1/ns/b/app/bar/m.py\", consider_namespace_packages=True\n+        ) == (tmp_path / \"src/dist1\", \"ns.b.app.bar.m\")\n+        assert resolve_pkg_root_and_module_name(\n+            tmp_path / \"src/dist2/ns/a/core/foo/m.py\", consider_namespace_packages=True\n+        ) == (tmp_path / \"src/dist2\", \"ns.a.core.foo.m\")\n+\n+\n+def test_is_importable(pytester: Pytester) -> None:\n+    pytester.syspathinsert()\n+\n+    path = pytester.path / \"bar/foo.py\"\n+    path.parent.mkdir()\n+    path.touch()\n+    assert is_importable(\"bar.foo\", path) is True\n+\n+    # Ensure that the module that can be imported points to the path we expect.\n+    path = pytester.path / \"some/other/path/bar/foo.py\"\n+    path.mkdir(parents=True, exist_ok=True)\n+    assert is_importable(\"bar.foo\", path) is False\n+\n+    # Paths containing \".\" cannot be imported.\n+    path = pytester.path / \"bar.x/__init__.py\"\n+    path.parent.mkdir()\n+    path.touch()\n+    assert is_importable(\"bar.x\", path) is False\n+\n+    # Pass starting with \".\" denote relative imports and cannot be checked using is_importable.\n+    path = pytester.path / \".bar.x/__init__.py\"\n+    path.parent.mkdir()\n+    path.touch()\n+    assert is_importable(\".bar.x\", path) is False\n+\n+\n+def test_compute_module_name(tmp_path: Path) -> None:\n+    assert compute_module_name(tmp_path, tmp_path) is None\n+    assert compute_module_name(Path(), Path()) is None\n+\n+    assert compute_module_name(tmp_path, tmp_path / \"mod.py\") == \"mod\"\n+    assert compute_module_name(tmp_path, tmp_path / \"src/app/bar\") == \"src.app.bar\"\n+    assert compute_module_name(tmp_path, tmp_path / \"src/app/bar.py\") == \"src.app.bar\"\n+    assert (\n+        compute_module_name(tmp_path, tmp_path / \"src/app/bar/__init__.py\")\n+        == \"src.app.bar\"\n+    )\n+\n+\n+def validate_namespace_package(\n+    pytester: Pytester, paths: Sequence[Path], modules: Sequence[str]\n+) -> RunResult:\n+    \"\"\"\n+    Validate that a Python namespace package is set up correctly.\n+\n+    In a sub interpreter, add 'paths' to sys.path and attempt to import the given modules.\n+\n+    In this module many tests configure a set of files as a namespace package, this function\n+    is used as sanity check that our files are configured correctly from the point of view of Python.\n+    \"\"\"\n+    lines = [\n+        \"import sys\",\n+        # Configure sys.path.\n+        *[f\"sys.path.append(r{str(x)!r})\" for x in paths],\n+        # Imports.\n+        *[f\"import {x}\" for x in modules],\n+    ]\n+    return pytester.runpython_c(\"\\n\".join(lines))\n", "problem_statement": "`pytest==8.1.1` Import regression in some namespace package layouts\nAs first noted in #12074, below is an example project structure with two packages under the `ns` namespace that now fail to import after the changes introduced in `8.1.x`:\r\n\r\n```\r\nns\r\n\u2514\u2500\u2500 python\r\n    \u251c\u2500\u2500 bar\r\n    \u2502   \u251c\u2500\u2500 ns\r\n    \u2502   \u2502   \u251c\u2500\u2500 bar\r\n    \u2502   \u2502   \u2514\u2500\u2500 test\r\n    \u2502   \u2502       \u251c\u2500\u2500 __init__.py\r\n    \u2502   \u2502       \u251c\u2500\u2500 bar.py\r\n    \u2502   \u2502       \u2514\u2500\u2500 test_bar.py\r\n    \u2502   \u2514\u2500\u2500 pyproject.toml\r\n    \u2514\u2500\u2500 foo\r\n        \u251c\u2500\u2500 ns\r\n        \u2502   \u251c\u2500\u2500 foo\r\n        \u2502   \u2514\u2500\u2500 test\r\n        \u2502       \u251c\u2500\u2500 __init__.py\r\n        \u2502       \u251c\u2500\u2500 foo.py\r\n        \u2502       \u2514\u2500\u2500 test_foo.py\r\n        \u2514\u2500\u2500 pyproject.toml\r\n```\r\n\r\nBelow are the contents of `test_foo.py` and `foo.py`. `test_bar.py` and `bar.py` look nearly identical.\r\n\r\n```\r\n# python/foo/ns/test/test_foo.py\r\nfrom .foo import value\r\n\r\ndef test_foo():\r\n    assert value == \"foo\"\r\n```\r\n\r\n```\r\n# python/foo/ns/test/foo.py\r\nvalue = \"foo\"\r\n```\r\n\r\nIn `pytest==8.0.2`, `python -m pytest --import-mode=importlib` correctly discovers and runs the tests from the top level `ns` directory. In `pytest==8.1.1`, `python -m pytest --import-mode=importlib -o \"consider_namespace_packages=true\"`, results in the following error during collection:\r\n\r\n```\r\n========================== test session starts ===========================\r\nplatform darwin -- Python 3.9.16, pytest-8.1.1, pluggy-1.4.0\r\nrootdir: /home/user/pytest-12074\r\ncollected 0 items / 2 errors\r\n\r\n================================= ERRORS =================================\r\n____________ ERROR collecting python/bar/ns/test/test_bar.py _____________\r\nImportError while importing test module '/home/user/pytest-12074/python/bar/ns/test/test_bar.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\npython/bar/ns/test/test_bar.py:1: in <module>\r\n    from .bar import value\r\nE   ModuleNotFoundError: No module named 'test.bar'\r\n____________ ERROR collecting python/foo/ns/test/test_foo.py _____________\r\nImportError while importing test module '/home/user/pytest-12074/python/foo/ns/test/test_foo.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\npython/foo/ns/test/test_foo.py:1: in <module>\r\n    from .foo import value\r\nE   ModuleNotFoundError: No module named 'test.foo'\r\n======================== short test summary info =========================\r\nERROR python/bar/ns/test/test_bar.py\r\nERROR python/foo/ns/test/test_foo.py\r\n!!!!!!!!!!!!!!!! Interrupted: 2 errors during collection !!!!!!!!!!!!!!!!!\r\n=========================== 2 errors in 0.04s ============================\r\n```\r\n\r\n\r\nTo reproduce the issue clone https://github.com/aaraney/pytest-12074, pip install `ns.foo` and `ns.bar`, pip install the different versions of `pytest` and run with the aforementioned commands.\r\n\n", "hints_text": "Thanks @aaraney for the report, I will take a look ASAP. :+1: \n@aaraney,\r\n\r\nHow are you setting up your `PYTHONPATH`? I managed to get your example to work by putting `ns/python/bar` and `ns/python/foo` in the `PYTHONPATH`, which seems to be [the recommendation for using namespace packages](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#native-namespace-packages).\r\n\r\n```\r\n\u03bb python -m pytest .tmp\\ns\\python --import-mode=importlib -o consider_namespace_packages=true --no-header\r\n======================== test session starts ========================\r\ncollected 2 items\r\n\r\n.tmp\\ns\\python\\bar\\ns\\bar\\test\\test_bar.py .                   [ 50%]\r\n.tmp\\ns\\python\\foo\\ns\\foo\\test\\test_foo.py .                   [100%]\r\n\r\n========================= 2 passed in 0.05s =========================\r\n\r\n\u03bb echo %PYTHONPATH%\r\ne:\\projects\\pytest\\.tmp\\ns\\python\\bar;e:\\projects\\pytest\\.tmp\\ns\\python\\foo\r\n\r\n\u03bb cd\r\ne:\\projects\\pytest\r\n```\r\n\r\nOne thing you can use to check if your namespace package is working is to import it inside Python directly:\r\n\r\n```\r\n\u03bb python\r\nPython 3.12.2 (tags/v3.12.2:6abddd9, Feb  6 2024, 21:26:36) [MSC v.1937 64 bit (AMD64)] on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import ns.bar.test.test_bar\r\n>>> import ns.foo.test.test_foo\r\n>>> ns\r\n<module 'ns' (namespace) from ['e:\\\\projects\\\\pytest\\\\.tmp\\\\ns\\\\python\\\\bar\\\\ns', 'e:\\\\projects\\\\pytest\\\\.tmp\\\\ns\\\\python\\\\foo\\\\ns']>\r\n```\r\n\r\nCan you try the above and show what you get?\r\n\r\n\nI am seeing something similar - I think it is because there is effectively a collision between `ns.test` in each subpackage.\r\nI deleted the `__init__.py` and following that it ran successfully using:\r\n```\r\n$ pytest --import-mode=importlib -o \"consider_namespace_packages=true\"\r\n```\r\n\r\nWithout `consider_namespace_packages`  if still failed, though.\r\n\r\nBTW, @aaraney, there's a typo in the original command above - a missing `g` (`consider_namespace_packaes`), which may help :)\nAlso, and this may be a different bug, but if I run `python -m pytest ...` instead of the `pytest ...` command directly then I don't need to delete the `__init__.py` in the test directories, though either way I _do_ require the `consider_namespace_packages` option.\r\n\r\nWith `pytest==8.0.2` it works fine either way (with/without running via `python -m pytest`) but it fails without the `__init__.py` for a different reason (relative imports within the test directory don't work).\nI suggest to also test using the Python REPL to import the namespace packages, taking pytest out of the picture, to ensure your configuration is correct.\n@nicoddemus, thanks again for looking into this! The example I provided was incomplete. When I adding `__init__.py` files to `python/ns/bar/ns/bar/__init__.py` and `python/ns/foo/ns/foo/__init__.py`, so python / setuptools would recognize them as actual submodules (as you alluded to) `pytest` ran successfully! \r\n\r\nIn the project I thought I discovered this bug in, it turns out there was an erroneous `__init__.py` file at the same level as a submodule's `pyproject.toml` / `setup.py` / `setup.cfg` (e.g. `python/ns/bar/__init__.py`). For some reason `pytest==8.0.2` did not balk at this and collected correctly, however with `pytest==8.1.1`, I received `ImportError: attempted relative import beyond top-level package` and `ModuleNotFoundError: No module named 'some-module'` errors. I think that is the correct behavior per PEP 420.\r\n\r\n@joshbode, great catch! Just fixed it!\n@aaraney thanks for the clarification!\r\n\r\n\n@nicoddemus, I think this can be closed unless you feel the need for it to stay open. It seems that it was a false alarm on my part. Thanks again for looking into this!\nIf somebody sees this and is not working as expected, please try importing your modules using the Python REPL first, to ensure the configuration is correct. \ud83d\udc4d \r\n\r\nI'm closing this for now then, with \"working as intended\".\r\n\r\nThanks everyone!\nThe REPL tip is a good one - it helped me figure out that my imports were being masked and that it wasn't being treated correctly as a namespace package, even before it hit `pytest`\nI have encountered a related issue.\r\n\r\nIn [this job](https://github.com/jaraco/jaraco.test/actions/runs/8356901314), the tests are failing with:\r\n\r\n```\r\nModuleNotFoundError: No module named 'test.support'\r\n```\r\n\r\nThe module `test.support` is part of the standard library, so should be importable. [Pinning to pytest < 8.1](https://github.com/jaraco/jaraco.test/commit/25312b563024be66a533a98d548237db4f1c5a05) works around the issue.\r\n\r\nThe problem is that the namespace package `jaraco` is being missed in the doctest discovery, so `jaraco.test` is being imported as `test`:\r\n\r\n```\r\npy: commands[0]> pytest --pdb\r\n============================================================== test session starts ===============================================================\r\nplatform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0\r\ncachedir: .tox/py/.pytest_cache\r\nrootdir: /Users/jaraco/code/jaraco/jaraco.test\r\nconfigfile: pytest.ini\r\nplugins: jaraco.test-5.3.1.dev79+g23d6c10, enabler-3.0.0, checkdocs-2.10.1, ruff-0.3.1, mypy-0.10.3, cov-4.1.0\r\ncollected 23 items                                                                                                                               \r\n\r\ndocs/conf.py ....                                                                                                                          [ 17%]\r\njaraco/test/__init__.py ....                                                                                                               [ 34%]\r\njaraco/test/cpython.py ...F\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> traceback >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n001 \r\n002 Compatibility shims for getting stuff from test.support across\r\n003 Python versions (for compatibility with Python 3.9 and earlier).\r\n004 \r\n005 >>> os_helper = try_import('os_helper') or from_test_support('temp_dir')\r\nUNEXPECTED EXCEPTION: ModuleNotFoundError(\"No module named 'test.support'\")\r\nTraceback (most recent call last):\r\n  File \"/opt/homebrew/Cellar/python@3.12/3.12.2_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/doctest.py\", line 1361, in __run\r\n    exec(compile(example.source, filename, \"single\",\r\n  File \"<doctest test.cpython[0]>\", line 1, in <module>\r\n  File \"/Users/jaraco/code/jaraco/jaraco.test/jaraco/test/cpython.py\", line 25, in from_test_support\r\n    import test.support\r\nModuleNotFoundError: No module named 'test.support'\r\n/Users/jaraco/code/jaraco/jaraco.test/jaraco/test/cpython.py:5: UnexpectedException\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> entering PDB >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PDB post_mortem (IO-capturing turned off) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n> /Users/jaraco/code/jaraco/jaraco.test/jaraco/test/cpython.py(25)from_test_support()\r\n-> import test.support\r\n(Pdb) import test\r\n(Pdb) test.__file__\r\n'/Users/jaraco/code/jaraco/jaraco.test/jaraco/test/__init__.py'\r\n```\r\n\r\nEssentially, #3396 re-emerges with pytest 8.1.\nYou can repro the issue by cloning jaraco/jaraco.test@23d6c10 and running tox. Let me know if you need a more minimal reproducer.\r\n\r\nI'm not doing any path manipulation, but merely running the tests with the package under test installed.\nThanks @jaraco,\r\n\r\nI investigated this a bit and got it to work: https://github.com/nicoddemus/jaraco.test/tree/ns-pytest, but I till need to investigate more in order to understand why your original layout does not work (it is late and I'm out of time to continue on this). I will take another look ASAP. ", "created_at": "2024-03-30T14:17:58Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12168, "instance_id": "pytest-dev__pytest-12168", "issue_numbers": ["12167"], "base_commit": "cc588d1a1ae549f5e9cf52df2fe132229fcc57cd", "patch": "diff --git a/changelog/12167.trivial.rst b/changelog/12167.trivial.rst\nnew file mode 100644\nindex 00000000000..da9363420e6\n--- /dev/null\n+++ b/changelog/12167.trivial.rst\n@@ -0,0 +1,1 @@\n+cache: create cache directory supporting files (``CACHEDIR.TAG``, ``.gitignore``, etc.) in a temporary directory to provide atomic semantics.\n", "test_patch": "diff --git a/src/_pytest/cacheprovider.py b/src/_pytest/cacheprovider.py\nindex 81703ddac44..e9f66f1f44f 100755\n--- a/src/_pytest/cacheprovider.py\n+++ b/src/_pytest/cacheprovider.py\n@@ -7,6 +7,7 @@\n import json\n import os\n from pathlib import Path\n+import tempfile\n from typing import Dict\n from typing import final\n from typing import Generator\n@@ -123,6 +124,10 @@ def warn(self, fmt: str, *, _ispytest: bool = False, **args: object) -> None:\n             stacklevel=3,\n         )\n \n+    def _mkdir(self, path: Path) -> None:\n+        self._ensure_cache_dir_and_supporting_files()\n+        path.mkdir(exist_ok=True, parents=True)\n+\n     def mkdir(self, name: str) -> Path:\n         \"\"\"Return a directory path object with the given name.\n \n@@ -141,7 +146,7 @@ def mkdir(self, name: str) -> Path:\n         if len(path.parts) > 1:\n             raise ValueError(\"name is not allowed to contain path separators\")\n         res = self._cachedir.joinpath(self._CACHE_PREFIX_DIRS, path)\n-        res.mkdir(exist_ok=True, parents=True)\n+        self._mkdir(res)\n         return res\n \n     def _getvaluepath(self, key: str) -> Path:\n@@ -178,19 +183,13 @@ def set(self, key: str, value: object) -> None:\n         \"\"\"\n         path = self._getvaluepath(key)\n         try:\n-            if path.parent.is_dir():\n-                cache_dir_exists_already = True\n-            else:\n-                cache_dir_exists_already = self._cachedir.exists()\n-                path.parent.mkdir(exist_ok=True, parents=True)\n+            self._mkdir(path.parent)\n         except OSError as exc:\n             self.warn(\n                 f\"could not create cache path {path}: {exc}\",\n                 _ispytest=True,\n             )\n             return\n-        if not cache_dir_exists_already:\n-            self._ensure_supporting_files()\n         data = json.dumps(value, ensure_ascii=False, indent=2)\n         try:\n             f = path.open(\"w\", encoding=\"UTF-8\")\n@@ -203,17 +202,32 @@ def set(self, key: str, value: object) -> None:\n             with f:\n                 f.write(data)\n \n-    def _ensure_supporting_files(self) -> None:\n-        \"\"\"Create supporting files in the cache dir that are not really part of the cache.\"\"\"\n-        readme_path = self._cachedir / \"README.md\"\n-        readme_path.write_text(README_CONTENT, encoding=\"UTF-8\")\n-\n-        gitignore_path = self._cachedir.joinpath(\".gitignore\")\n-        msg = \"# Created by pytest automatically.\\n*\\n\"\n-        gitignore_path.write_text(msg, encoding=\"UTF-8\")\n+    def _ensure_cache_dir_and_supporting_files(self) -> None:\n+        \"\"\"Create the cache dir and its supporting files.\"\"\"\n+        if self._cachedir.is_dir():\n+            return\n \n-        cachedir_tag_path = self._cachedir.joinpath(\"CACHEDIR.TAG\")\n-        cachedir_tag_path.write_bytes(CACHEDIR_TAG_CONTENT)\n+        self._cachedir.parent.mkdir(parents=True, exist_ok=True)\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"pytest-cache-files-\",\n+            dir=self._cachedir.parent,\n+        ) as newpath:\n+            path = Path(newpath)\n+            with open(path.joinpath(\"README.md\"), \"xt\", encoding=\"UTF-8\") as f:\n+                f.write(README_CONTENT)\n+            with open(path.joinpath(\".gitignore\"), \"xt\", encoding=\"UTF-8\") as f:\n+                f.write(\"# Created by pytest automatically.\\n*\\n\")\n+            with open(path.joinpath(\"CACHEDIR.TAG\"), \"xb\") as f:\n+                f.write(CACHEDIR_TAG_CONTENT)\n+\n+            path.rename(self._cachedir)\n+            # Create a directory in place of the one we just moved so that `TemporaryDirectory`'s\n+            # cleanup doesn't complain.\n+            #\n+            # TODO: pass ignore_cleanup_errors=True when we no longer support python < 3.10. See\n+            # https://github.com/python/cpython/issues/74168. Note that passing delete=False would\n+            # do the wrong thing in case of errors and isn't supported until python 3.12.\n+            path.mkdir()\n \n \n class LFPluginCollWrapper:\ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex e676d562cf4..7acc8cdf1d9 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1731,8 +1731,8 @@ def test_cwd_changed(self, pytester: Pytester, monkeypatch) -> None:\n                     import os\n                     import tempfile\n \n-                    with tempfile.TemporaryDirectory() as d:\n-                        os.chdir(d)\n+                    with tempfile.TemporaryDirectory() as newpath:\n+                        os.chdir(newpath)\n                 \"\"\",\n                 \"test_test.py\": \"\"\"\\\n                     def test():\n", "problem_statement": "race condition between creation of `.pytest_cache` and `.pytest_cache/.gitignore`\nThe solution implemented in https://github.com/pytest-dev/pytest/pull/3982 is not robust - in case test execution is interrupted while a cache element is being written, the `.pytest_cache` directory will exist and be non-empty, but will not contain `.gitignore`.\r\n\r\nBecause of [this check](https://github.com/pytest-dev/pytest/blob/12e061e2e838fb2c17d54df40a4a11aeb8723c6b/src/_pytest/cacheprovider.py#L192-L193) `.gitignore` ends up never being created.\n", "hints_text": "", "created_at": "2024-03-29T15:54:08Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12136, "instance_id": "pytest-dev__pytest-12136", "issue_numbers": ["12135"], "base_commit": "12e061e2e838fb2c17d54df40a4a11aeb8723c6b", "patch": "diff --git a/changelog/12135.bugfix.rst b/changelog/12135.bugfix.rst\nnew file mode 100644\nindex 00000000000..734733b100d\n--- /dev/null\n+++ b/changelog/12135.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix fixtures adding their finalizer multiple times to fixtures they request, causing unreliable and non-intuitive teardown ordering in some instances.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex a8fed047e7f..265ed601d9f 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -1035,14 +1035,25 @@ def finish(self, request: SubRequest) -> None:\n             raise BaseExceptionGroup(msg, exceptions[::-1])\n \n     def execute(self, request: SubRequest) -> FixtureValue:\n-        finalizer = functools.partial(self.finish, request=request)\n-        # Get required arguments and register our own finish()\n-        # with their finalization.\n+        \"\"\"Return the value of this fixture, executing it if not cached.\"\"\"\n+        # Ensure that the dependent fixtures requested by this fixture are loaded.\n+        # This needs to be done before checking if we have a cached value, since\n+        # if a dependent fixture has their cache invalidated, e.g. due to\n+        # parametrization, they finalize themselves and fixtures depending on it\n+        # (which will likely include this fixture) setting `self.cached_result = None`.\n+        # See #4871\n+        requested_fixtures_that_should_finalize_us = []\n         for argname in self.argnames:\n             fixturedef = request._get_active_fixturedef(argname)\n+            # Saves requested fixtures in a list so we later can add our finalizer\n+            # to them, ensuring that if a requested fixture gets torn down we get torn\n+            # down first. This is generally handled by SetupState, but still currently\n+            # needed when this fixture is not parametrized but depends on a parametrized\n+            # fixture.\n             if not isinstance(fixturedef, PseudoFixtureDef):\n-                fixturedef.addfinalizer(finalizer)\n+                requested_fixtures_that_should_finalize_us.append(fixturedef)\n \n+        # Check for (and return) cached value/exception.\n         my_cache_key = self.cache_key(request)\n         if self.cached_result is not None:\n             cache_key = self.cached_result[1]\n@@ -1060,6 +1071,13 @@ def execute(self, request: SubRequest) -> FixtureValue:\n             self.finish(request)\n             assert self.cached_result is None\n \n+        # Add finalizer to requested fixtures we saved previously.\n+        # We make sure to do this after checking for cached value to avoid\n+        # adding our finalizer multiple times. (#12135)\n+        finalizer = functools.partial(self.finish, request=request)\n+        for parent_fixture in requested_fixtures_that_should_finalize_us:\n+            parent_fixture.addfinalizer(finalizer)\n+\n         ihook = request.node.ihook\n         try:\n             # Setup the fixture, run the code in it, and cache the value\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 1e22270e51b..12ca6e92630 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -4751,3 +4751,55 @@ def test_2(fixture_1: None) -> None:\n     )\n     result = pytester.runpytest()\n     assert result.ret == 0\n+\n+\n+def test_subfixture_teardown_order(pytester: Pytester) -> None:\n+    \"\"\"\n+    Make sure fixtures don't re-register their finalization in parent fixtures multiple\n+    times, causing ordering failure in their teardowns.\n+\n+    Regression test for #12135\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        execution_order = []\n+\n+        @pytest.fixture(scope=\"class\")\n+        def fixture_1():\n+            ...\n+\n+        @pytest.fixture(scope=\"class\")\n+        def fixture_2(fixture_1):\n+            execution_order.append(\"setup 2\")\n+            yield\n+            execution_order.append(\"teardown 2\")\n+\n+        @pytest.fixture(scope=\"class\")\n+        def fixture_3(fixture_1):\n+            execution_order.append(\"setup 3\")\n+            yield\n+            execution_order.append(\"teardown 3\")\n+\n+        class TestFoo:\n+            def test_initialize_fixtures(self, fixture_2, fixture_3):\n+                ...\n+\n+            # This would previously reschedule fixture_2's finalizer in the parent fixture,\n+            # causing it to be torn down before fixture 3.\n+            def test_reschedule_fixture_2(self, fixture_2):\n+                ...\n+\n+            # Force finalization directly on fixture_1\n+            # Otherwise the cleanup would sequence 3&2 before 1 as normal.\n+            @pytest.mark.parametrize(\"fixture_1\", [None], indirect=[\"fixture_1\"])\n+            def test_finalize_fixture_1(self, fixture_1):\n+                ...\n+\n+        def test_result():\n+            assert execution_order == [\"setup 2\", \"setup 3\", \"teardown 3\", \"teardown 2\"]\n+        \"\"\"\n+    )\n+    result = pytester.runpytest()\n+    assert result.ret == 0\n", "problem_statement": "Finalizer re-registered in parent fixture even when the value of the fixture is cached\nWhen getting the value of a fixture, it will always add its finalizer to parent fixtures, regardless of if it's cached or not. When we have several subfixtures, this leads to unpredictable ordering between them on when they're torn down (if triggered by the parent fixture being torn down). It is also an obvious inefficiency, where a long-lived parent fixture could rack up tons of irrelevant fixtures.\r\n\r\nAs found in discussion of #11833, which resolved a similar issue. Also related to #4871\r\n\r\n### repro\r\n```python\r\nimport pytest\r\n\r\n\r\n@pytest.fixture(scope=\"module\")\r\ndef fixture_1(request):\r\n    ...\r\n\r\n@pytest.fixture(scope=\"module\")\r\ndef fixture_2(fixture_1):\r\n    print(\"setup 2\")\r\n    yield\r\n    print(\"teardown 2\")\r\n\r\n@pytest.fixture(scope=\"module\")\r\ndef fixture_3(fixture_1):\r\n    print(\"setup 3\")\r\n    yield\r\n    print(\"teardown 3\")\r\n\r\ndef test_1(fixture_2):\r\n    ...\r\ndef test_2(fixture_3):\r\n    ...\r\n\r\n# This will add a second copy of fixture_2's finalizer in the parent fixture, causing it to\r\n# be torn down before fixture 3.\r\ndef test_3(fixture_2):\r\n    ...\r\n\r\n\r\n# Trigger finalization of fixture_1, otherwise the cleanup would sequence 3&2 before 1 as normal.\r\n@pytest.mark.parametrize(\"fixture_1\", [None], indirect=[\"fixture_1\"])\r\ndef test_4(fixture_1):\r\n    ...\r\n```\r\n### output\r\n```\r\nsetup 2\r\nsetup 3\r\nteardown 2\r\nteardown 3\r\n```\r\nbut if we remove `test_3` we get 2-3-3-2.\r\n\r\n\r\n\r\n### suggested fix\r\nHere's the relevant method:\r\nhttps://github.com/pytest-dev/pytest/blob/2607fe8b4706fa701925db50f7892ddff6ed2928/src/_pytest/fixtures.py#L1037-L1079\r\n\r\nI thought this would be a trivial fix, merely moving the code that adds finalizers to parent fixtures (L1041 to L1044) to after the check on whether the value is cached (L1062). But this broke tests in very weird ways... and I think that's the same problem as noted in https://github.com/pytest-dev/pytest/issues/4871#issuecomment-2002622725 - see \"Possible solution - make the cache key not match\". Current behaviour requires that the call to `request._get_active_fixturedef(argname)` happens before checking if the value is cached, to let the parent fixture check if it has been differently parametrized -> if so tear itself down -> tear us down -> invalidate our cache.\r\n\r\nOnce I figured out that the finalize-adding code had dual purposes, it was fairly easy to split it and achieve the wanted behavior without breaking anything:\r\n\r\n```python\r\n    def execute(self, request: SubRequest) -> FixtureValue:\r\n        # Ensure arguments (parent fixtures) are loaded. If their cache has been\r\n        # invalidated they will also finalize us and invalidate our cache.\r\n        # If/when parent fixture parametrization is included in our cache key\r\n        # this can be moved after checking our cache key.\r\n        parent_fixtures_to_add_finalizer = []\r\n        for argname in self.argnames:\r\n            fixturedef = request._get_active_fixturedef(argname)\r\n            if not isinstance(fixturedef, PseudoFixtureDef):\r\n                # save fixture as one to add our finalizer to, if we're not cached\r\n                # resolves #12135\r\n                parent_fixtures_to_add_finalizer.append(fixturedef)\r\n\r\n        my_cache_key = self.cache_key(request)\r\n        if self.cached_result is not None:\r\n            ...\r\n\r\n        finalizer = functools.partial(self.finish, request=request)\r\n        # add finalizer to parent fixtures\r\n        for parent_fixture in parent_fixtures_to_add_finalizer:\r\n            parent_fixture.addfinalizer(finalizer)\r\n```\r\n\r\n### possible bad outcomes\r\n... I have a very hard time coming up with any downside of implementing this. Will write a PR once I've rewritten the repro as a proper regression test.\n", "hints_text": "", "created_at": "2024-03-18T14:18:30Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12096, "instance_id": "pytest-dev__pytest-12096", "issue_numbers": ["12065"], "base_commit": "437eb86eddd04383eda0e085b889b2a705ee26d4", "patch": "diff --git a/changelog/12065.bugfix.rst b/changelog/12065.bugfix.rst\nnew file mode 100644\nindex 00000000000..ca55b327e13\n--- /dev/null\n+++ b/changelog/12065.bugfix.rst\n@@ -0,0 +1,4 @@\n+Fixed a regression in pytest 8.0.0 where test classes containing ``setup_method`` and tests using ``@staticmethod`` or ``@classmethod`` would crash with ``AttributeError: 'NoneType' object has no attribute 'setup_method'``.\n+\n+Now the :attr:`request.instance <pytest.FixtureRequest.instance>` attribute of tests using ``@staticmethod`` and ``@classmethod`` is no longer ``None``, but a fresh instance of the class, like in non-static methods.\n+Previously it was ``None``, and all fixtures of such tests would share a single ``self``.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 4b7c107521b..daf3145aaac 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -470,8 +470,9 @@ def cls(self):\n     @property\n     def instance(self):\n         \"\"\"Instance (can be None) on which test function was collected.\"\"\"\n-        function = getattr(self, \"function\", None)\n-        return getattr(function, \"__self__\", None)\n+        if self.scope != \"function\":\n+            return None\n+        return getattr(self._pyfuncitem, \"instance\", None)\n \n     @property\n     def module(self):\n@@ -1096,22 +1097,23 @@ def resolve_fixture_function(\n     fixturedef: FixtureDef[FixtureValue], request: FixtureRequest\n ) -> \"_FixtureFunc[FixtureValue]\":\n     \"\"\"Get the actual callable that can be called to obtain the fixture\n-    value, dealing with unittest-specific instances and bound methods.\"\"\"\n+    value.\"\"\"\n     fixturefunc = fixturedef.func\n     # The fixture function needs to be bound to the actual\n     # request.instance so that code working with \"fixturedef\" behaves\n     # as expected.\n-    if request.instance is not None:\n+    instance = request.instance\n+    if instance is not None:\n         # Handle the case where fixture is defined not in a test class, but some other class\n         # (for example a plugin class with a fixture), see #2270.\n         if hasattr(fixturefunc, \"__self__\") and not isinstance(\n-            request.instance,\n+            instance,\n             fixturefunc.__self__.__class__,  # type: ignore[union-attr]\n         ):\n             return fixturefunc\n         fixturefunc = getimfunc(fixturedef.func)\n         if fixturefunc != fixturedef.func:\n-            fixturefunc = fixturefunc.__get__(request.instance)  # type: ignore[union-attr]\n+            fixturefunc = fixturefunc.__get__(instance)  # type: ignore[union-attr]\n     return fixturefunc\n \n \ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex fce2078cde3..7b0683b6ec5 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -302,10 +302,10 @@ def instance(self):\n         \"\"\"Python instance object the function is bound to.\n \n         Returns None if not a test method, e.g. for a standalone test function,\n-        a staticmethod, a class or a module.\n+        a class or a module.\n         \"\"\"\n-        node = self.getparent(Function)\n-        return getattr(node.obj, \"__self__\", None) if node is not None else None\n+        # Overridden by Function.\n+        return None\n \n     @property\n     def obj(self):\n@@ -1702,7 +1702,8 @@ def __init__(\n         super().__init__(name, parent, config=config, session=session)\n \n         if callobj is not NOTSET:\n-            self.obj = callobj\n+            self._obj = callobj\n+            self._instance = getattr(callobj, \"__self__\", None)\n \n         #: Original function name, without any decorations (for example\n         #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n@@ -1752,12 +1753,31 @@ def function(self):\n         \"\"\"Underlying python 'function' object.\"\"\"\n         return getimfunc(self.obj)\n \n-    def _getobj(self):\n-        assert self.parent is not None\n+    @property\n+    def instance(self):\n+        try:\n+            return self._instance\n+        except AttributeError:\n+            if isinstance(self.parent, Class):\n+                # Each Function gets a fresh class instance.\n+                self._instance = self._getinstance()\n+            else:\n+                self._instance = None\n+        return self._instance\n+\n+    def _getinstance(self):\n         if isinstance(self.parent, Class):\n             # Each Function gets a fresh class instance.\n-            parent_obj = self.parent.newinstance()\n+            return self.parent.newinstance()\n+        else:\n+            return None\n+\n+    def _getobj(self):\n+        instance = self.instance\n+        if instance is not None:\n+            parent_obj = instance\n         else:\n+            assert self.parent is not None\n             parent_obj = self.parent.obj  # type: ignore[attr-defined]\n         return getattr(parent_obj, self.originalname)\n \ndiff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex b0ec02e7d36..32eb361c6fd 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -177,16 +177,15 @@ class TestCaseFunction(Function):\n     nofuncargs = True\n     _excinfo: Optional[List[_pytest._code.ExceptionInfo[BaseException]]] = None\n \n-    def _getobj(self):\n+    def _getinstance(self):\n         assert isinstance(self.parent, UnitTestCase)\n-        testcase = self.parent.obj(self.name)\n-        return getattr(testcase, self.name)\n+        return self.parent.obj(self.name)\n \n     # Backward compat for pytest-django; can be removed after pytest-django\n     # updates + some slack.\n     @property\n     def _testcase(self):\n-        return self._obj.__self__\n+        return self.instance\n \n     def setup(self) -> None:\n         # A bound method to be called during teardown() if set (see 'runtest()').\n@@ -296,7 +295,8 @@ def addDuration(self, testcase: \"unittest.TestCase\", elapsed: float) -> None:\n     def runtest(self) -> None:\n         from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n \n-        testcase = self.obj.__self__\n+        testcase = self.instance\n+        assert testcase is not None\n \n         maybe_wrap_pytest_function_for_tracing(self)\n \ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 8d59b36d319..2e277626cde 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -4577,3 +4577,48 @@ def test_deduplicate_names() -> None:\n     assert items == (\"a\", \"b\", \"c\", \"d\")\n     items = deduplicate_names((*items, \"g\", \"f\", \"g\", \"e\", \"b\"))\n     assert items == (\"a\", \"b\", \"c\", \"d\", \"g\", \"f\", \"e\")\n+\n+\n+def test_staticmethod_classmethod_fixture_instance(pytester: Pytester) -> None:\n+    \"\"\"Ensure that static and class methods get and have access to a fresh\n+    instance.\n+\n+    This also ensures `setup_method` works well with static and class methods.\n+\n+    Regression test for #12065.\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        class Test:\n+            ran_setup_method = False\n+            ran_fixture = False\n+\n+            def setup_method(self):\n+                assert not self.ran_setup_method\n+                self.ran_setup_method = True\n+\n+            @pytest.fixture(autouse=True)\n+            def fixture(self):\n+                assert not self.ran_fixture\n+                self.ran_fixture = True\n+\n+            def test_method(self):\n+                assert self.ran_setup_method\n+                assert self.ran_fixture\n+\n+            @staticmethod\n+            def test_1(request):\n+                assert request.instance.ran_setup_method\n+                assert request.instance.ran_fixture\n+\n+            @classmethod\n+            def test_2(cls, request):\n+                assert request.instance.ran_setup_method\n+                assert request.instance.ran_fixture\n+        \"\"\"\n+    )\n+    result = pytester.runpytest()\n+    assert result.ret == ExitCode.OK\n+    result.assert_outcomes(passed=3)\ndiff --git a/testing/python/integration.py b/testing/python/integration.py\nindex a6c14ece407..219ebf9cec8 100644\n--- a/testing/python/integration.py\n+++ b/testing/python/integration.py\n@@ -410,22 +410,37 @@ def test_function_instance(pytester: Pytester) -> None:\n     items = pytester.getitems(\n         \"\"\"\n         def test_func(): pass\n+\n         class TestIt:\n             def test_method(self): pass\n+\n             @classmethod\n             def test_class(cls): pass\n+\n             @staticmethod\n             def test_static(): pass\n         \"\"\"\n     )\n     assert len(items) == 4\n+\n     assert isinstance(items[0], Function)\n     assert items[0].name == \"test_func\"\n     assert items[0].instance is None\n+\n     assert isinstance(items[1], Function)\n     assert items[1].name == \"test_method\"\n     assert items[1].instance is not None\n     assert items[1].instance.__class__.__name__ == \"TestIt\"\n+\n+    # Even class and static methods get an instance!\n+    # This is the instance used for bound fixture methods, which\n+    # class/staticmethod tests are perfectly able to request.\n+    assert isinstance(items[2], Function)\n+    assert items[2].name == \"test_class\"\n+    assert items[2].instance is not None\n+\n     assert isinstance(items[3], Function)\n     assert items[3].name == \"test_static\"\n-    assert items[3].instance is None\n+    assert items[3].instance is not None\n+\n+    assert items[1].instance is not items[2].instance is not items[3].instance\n", "problem_statement": "Pytest 8.1.0 AttributeError: 'NoneType' object has no attribute 'setup_method' with staticmethod test\nHi, the code that was working fine with pytest==8.0.2 started giving the error below for pytest==8.1.0.\r\n\r\nLogs with pytest 8.0.2: https://github.com/BlueBrain/BlueCelluLab/actions/runs/8114860416/job/22181464420\r\nLogs with pytest 8.1.0: https://github.com/BlueBrain/BlueCelluLab/actions/runs/8138274377/job/22239015810?pr=142\r\n\r\n```\r\n  request = <SubRequest '_xunit_setup_method_fixture_TestSonataSimulationAccess' for <Function test_init_file_not_found>>\r\n  \r\n      def xunit_setup_method_fixture(request) -> Generator[None, None, None]:\r\n          instance = request.instance\r\n          method = request.function\r\n          if setup_method is not None:\r\n  >           func = getattr(instance, setup_name)\r\n  E           AttributeError: 'NoneType' object has no attribute 'setup_method'\r\n  \r\n  lib/python3.11/site-packages/_pytest/python.py:844: AttributeError\r\n```\r\nAll of the installed dependencies and the system versions are available in the CI logs.\n", "hints_text": "I see the failing test is a staticmethod:\r\n\r\nhttps://github.com/BlueBrain/BlueCelluLab/blob/b8330e24c65219f48f0689cdc2d31b579586fb12/tests/test_circuit/test_simulation_access.py#L49-L50\r\n\r\nI'm not sure if that's supposed to work (will check later), but curious if there's a particular reason you made it staticmethod?\nOh, thanks. No, in fact that does not have to be a staticmethod. Let me remove that and test again.\nThere exists another CI workflow (named \"Examples\") that is also passing on 8.0.2 and failing with 8.1.0. That does not use staticmethod.\r\n\r\n8.0.2 Examples CI: https://github.com/BlueBrain/BlueCelluLab/actions/runs/8114860416/job/22181463086\r\n8.1.0 Examples CI: https://github.com/BlueBrain/BlueCelluLab/actions/runs/8138274377/job/22239014458\n@anilbey This is a different issue, the `nbmake` plugin will need to update its `pytest_collect_file` hookimpl to be compatible with pytest 8.1.\nUpdate: removing 'staticmethod' worked.\r\n\r\nGreat, thanks a lot @bluetech for your quick reply in clarifying the issues.\nBisected to c8792bd0800b8ffc536a6ce251f9eb3075b5f5fa (pr #11780).\r\n\r\nWe're talking about this reproduction:\r\n\r\n```py\r\nclass TestIt:\r\n    def setup_method(self): pass\r\n\r\n    @staticmethod\r\n    def test_1(): pass\r\n```\r\n\r\nThis brings up the question, what is `self` in the `setup_method` of a `staticmethod` (or `classmethod`)?\r\n\r\nThe expectation, as happens with e.g. unittest and regular methods, is that it's a fresh instance.\r\n\r\nHowever, pytest<=8.0 has a subtle bug: all of the static/classmethods use a shared instance. The two prints here are the same:\r\n\r\n```py\r\nclass TestIt:\r\n    def setup_method(self): print('\\nSETUP!', self)\r\n\r\n    @staticmethod\r\n    def test_1(): pass\r\n\r\n    @classmethod\r\n    def test_2(cls): pass\r\n```\r\n\r\nI think that fixing this preexisting bug will also fix the 8.1.0 crash, so I will look into it, though it probably won't be a simple fix, so I might instead restore the previous (problematic) behavior.", "created_at": "2024-03-09T17:38:16Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12087, "instance_id": "pytest-dev__pytest-12087", "issue_numbers": ["12069"], "base_commit": "86945f9a1f7cae10a9ac9ccf4b41ce9ddfabe14c", "patch": "diff --git a/changelog/12069.trivial.rst b/changelog/12069.trivial.rst\nnew file mode 100644\nindex 00000000000..25c0db1c115\n--- /dev/null\n+++ b/changelog/12069.trivial.rst\n@@ -0,0 +1,8 @@\n+Delayed the deprecation of the following features to ``9.0.0``:\n+\n+* :ref:`node-ctor-fspath-deprecation`.\n+* :ref:`legacy-path-hooks-deprecated`.\n+\n+It was discovered after ``8.1.0`` was released that the warnings about the impeding removal were not being displayed, so the team decided to revert the removal.\n+\n+This was the reason for ``8.1.0`` being yanked.\ndiff --git a/doc/en/conf.py b/doc/en/conf.py\nindex cf889eb7a86..8059c359fc1 100644\n--- a/doc/en/conf.py\n+++ b/doc/en/conf.py\n@@ -200,6 +200,7 @@\n     (\"py:class\", \"_tracing.TagTracerSub\"),\n     (\"py:class\", \"warnings.WarningMessage\"),\n     # Undocumented type aliases\n+    (\"py:class\", \"LEGACY_PATH\"),\n     (\"py:class\", \"_PluggyPlugin\"),\n     # TypeVars\n     (\"py:class\", \"_pytest._code.code.E\"),\ndiff --git a/doc/en/deprecations.rst b/doc/en/deprecations.rst\nindex b9a59d7910f..cd6d1e60aef 100644\n--- a/doc/en/deprecations.rst\n+++ b/doc/en/deprecations.rst\n@@ -19,7 +19,45 @@ Below is a complete list of all pytest features which are considered deprecated.\n :class:`~pytest.PytestWarning` or subclasses, which can be filtered using :ref:`standard warning filters <warnings>`.\n \n \n-.. _legacy-path-hooks-deprecated:\n+.. _node-ctor-fspath-deprecation:\n+\n+``fspath`` argument for Node constructors replaced with ``pathlib.Path``\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. deprecated:: 7.0\n+\n+In order to support the transition from ``py.path.local`` to :mod:`pathlib`,\n+the ``fspath`` argument to :class:`~_pytest.nodes.Node` constructors like\n+:func:`pytest.Function.from_parent()` and :func:`pytest.Class.from_parent()`\n+is now deprecated.\n+\n+Plugins which construct nodes should pass the ``path`` argument, of type\n+:class:`pathlib.Path`, instead of the ``fspath`` argument.\n+\n+Plugins which implement custom items and collectors are encouraged to replace\n+``fspath`` parameters (``py.path.local``) with ``path`` parameters\n+(``pathlib.Path``), and drop any other usage of the ``py`` library if possible.\n+\n+If possible, plugins with custom items should use :ref:`cooperative\n+constructors <uncooperative-constructors-deprecated>` to avoid hardcoding\n+arguments they only pass on to the superclass.\n+\n+.. note::\n+    The name of the :class:`~_pytest.nodes.Node` arguments and attributes (the\n+    new attribute being ``path``) is **the opposite** of the situation for\n+    hooks, :ref:`outlined below <legacy-path-hooks-deprecated>` (the old\n+    argument being ``path``).\n+\n+    This is an unfortunate artifact due to historical reasons, which should be\n+    resolved in future versions as we slowly get rid of the :pypi:`py`\n+    dependency (see :issue:`9283` for a longer discussion).\n+\n+Due to the ongoing migration of methods like :meth:`~pytest.Item.reportinfo`\n+which still is expected to return a ``py.path.local`` object, nodes still have\n+both ``fspath`` (``py.path.local``) and ``path`` (``pathlib.Path``) attributes,\n+no matter what argument was used in the constructor. We expect to deprecate the\n+``fspath`` attribute in a future release.\n+\n \n Configuring hook specs/impls using markers\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -62,6 +100,33 @@ Changed ``hookwrapper`` attributes:\n * ``historic``\n \n \n+.. _legacy-path-hooks-deprecated:\n+\n+``py.path.local`` arguments for hooks replaced with ``pathlib.Path``\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. deprecated:: 7.0\n+\n+In order to support the transition from ``py.path.local`` to :mod:`pathlib`, the following hooks now receive additional arguments:\n+\n+*  :hook:`pytest_ignore_collect(collection_path: pathlib.Path) <pytest_ignore_collect>` as equivalent to ``path``\n+*  :hook:`pytest_collect_file(file_path: pathlib.Path) <pytest_collect_file>` as equivalent to ``path``\n+*  :hook:`pytest_pycollect_makemodule(module_path: pathlib.Path) <pytest_pycollect_makemodule>` as equivalent to ``path``\n+*  :hook:`pytest_report_header(start_path: pathlib.Path) <pytest_report_header>` as equivalent to ``startdir``\n+*  :hook:`pytest_report_collectionfinish(start_path: pathlib.Path) <pytest_report_collectionfinish>` as equivalent to ``startdir``\n+\n+The accompanying ``py.path.local`` based paths have been deprecated: plugins which manually invoke those hooks should only pass the new ``pathlib.Path`` arguments, and users should change their hook implementations to use the new ``pathlib.Path`` arguments.\n+\n+.. note::\n+    The name of the :class:`~_pytest.nodes.Node` arguments and attributes,\n+    :ref:`outlined above <node-ctor-fspath-deprecation>` (the new attribute\n+    being ``path``) is **the opposite** of the situation for hooks (the old\n+    argument being ``path``).\n+\n+    This is an unfortunate artifact due to historical reasons, which should be\n+    resolved in future versions as we slowly get rid of the :pypi:`py`\n+    dependency (see :issue:`9283` for a longer discussion).\n+\n Directly constructing internal classes\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -208,73 +273,6 @@ an appropriate period of deprecation has passed.\n \n Some breaking changes which could not be deprecated are also listed.\n \n-.. _node-ctor-fspath-deprecation:\n-\n-``fspath`` argument for Node constructors replaced with ``pathlib.Path``\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-.. deprecated:: 7.0\n-\n-In order to support the transition from ``py.path.local`` to :mod:`pathlib`,\n-the ``fspath`` argument to :class:`~_pytest.nodes.Node` constructors like\n-:func:`pytest.Function.from_parent()` and :func:`pytest.Class.from_parent()`\n-is now deprecated.\n-\n-Plugins which construct nodes should pass the ``path`` argument, of type\n-:class:`pathlib.Path`, instead of the ``fspath`` argument.\n-\n-Plugins which implement custom items and collectors are encouraged to replace\n-``fspath`` parameters (``py.path.local``) with ``path`` parameters\n-(``pathlib.Path``), and drop any other usage of the ``py`` library if possible.\n-\n-If possible, plugins with custom items should use :ref:`cooperative\n-constructors <uncooperative-constructors-deprecated>` to avoid hardcoding\n-arguments they only pass on to the superclass.\n-\n-.. note::\n-    The name of the :class:`~_pytest.nodes.Node` arguments and attributes (the\n-    new attribute being ``path``) is **the opposite** of the situation for\n-    hooks, :ref:`outlined below <legacy-path-hooks-deprecated>` (the old\n-    argument being ``path``).\n-\n-    This is an unfortunate artifact due to historical reasons, which should be\n-    resolved in future versions as we slowly get rid of the :pypi:`py`\n-    dependency (see :issue:`9283` for a longer discussion).\n-\n-Due to the ongoing migration of methods like :meth:`~pytest.Item.reportinfo`\n-which still is expected to return a ``py.path.local`` object, nodes still have\n-both ``fspath`` (``py.path.local``) and ``path`` (``pathlib.Path``) attributes,\n-no matter what argument was used in the constructor. We expect to deprecate the\n-``fspath`` attribute in a future release.\n-\n-\n-``py.path.local`` arguments for hooks replaced with ``pathlib.Path``\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-.. deprecated:: 7.0\n-.. versionremoved:: 8.0\n-\n-In order to support the transition from ``py.path.local`` to :mod:`pathlib`, the following hooks now receive additional arguments:\n-\n-*  :hook:`pytest_ignore_collect(collection_path: pathlib.Path) <pytest_ignore_collect>` as equivalent to ``path``\n-*  :hook:`pytest_collect_file(file_path: pathlib.Path) <pytest_collect_file>` as equivalent to ``path``\n-*  :hook:`pytest_pycollect_makemodule(module_path: pathlib.Path) <pytest_pycollect_makemodule>` as equivalent to ``path``\n-*  :hook:`pytest_report_header(start_path: pathlib.Path) <pytest_report_header>` as equivalent to ``startdir``\n-*  :hook:`pytest_report_collectionfinish(start_path: pathlib.Path) <pytest_report_collectionfinish>` as equivalent to ``startdir``\n-\n-The accompanying ``py.path.local`` based paths have been deprecated: plugins which manually invoke those hooks should only pass the new ``pathlib.Path`` arguments, and users should change their hook implementations to use the new ``pathlib.Path`` arguments.\n-\n-.. note::\n-    The name of the :class:`~_pytest.nodes.Node` arguments and attributes,\n-    :ref:`outlined above <node-ctor-fspath-deprecation>` (the new attribute\n-    being ``path``) is **the opposite** of the situation for hooks (the old\n-    argument being ``path``).\n-\n-    This is an unfortunate artifact due to historical reasons, which should be\n-    resolved in future versions as we slowly get rid of the :pypi:`py`\n-    dependency (see :issue:`9283` for a longer discussion).\n-\n-\n .. _nose-deprecation:\n \n Support for tests written for nose\n", "test_patch": "diff --git a/src/_pytest/compat.py b/src/_pytest/compat.py\nindex fa387f6db12..121b1f9f64f 100644\n--- a/src/_pytest/compat.py\n+++ b/src/_pytest/compat.py\n@@ -1,5 +1,6 @@\n # mypy: allow-untyped-defs\n \"\"\"Python version compatibility code.\"\"\"\n+\n from __future__ import annotations\n \n import dataclasses\n@@ -16,6 +17,22 @@\n from typing import Final\n from typing import NoReturn\n \n+import py\n+\n+\n+#: constant to prepare valuing pylib path replacements/lazy proxies later on\n+#  intended for removal in pytest 8.0 or 9.0\n+\n+# fmt: off\n+# intentional space to create a fake difference for the verification\n+LEGACY_PATH = py.path. local\n+# fmt: on\n+\n+\n+def legacy_path(path: str | os.PathLike[str]) -> LEGACY_PATH:\n+    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"\n+    return LEGACY_PATH(path)\n+\n \n # fmt: off\n # Singleton type for NOTSET, as described in:\ndiff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex 7ed79483c4e..bf2cfc3996d 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -38,12 +38,14 @@\n from typing import Union\n import warnings\n \n+import pluggy\n from pluggy import HookimplMarker\n from pluggy import HookimplOpts\n from pluggy import HookspecMarker\n from pluggy import HookspecOpts\n from pluggy import PluginManager\n \n+from .compat import PathAwareHookProxy\n from .exceptions import PrintHelp as PrintHelp\n from .exceptions import UsageError as UsageError\n from .findpaths import determine_setup\n@@ -1068,7 +1070,7 @@ def __init__(\n         self._store = self.stash\n \n         self.trace = self.pluginmanager.trace.root.get(\"config\")\n-        self.hook = self.pluginmanager.hook  # type: ignore[assignment]\n+        self.hook: pluggy.HookRelay = PathAwareHookProxy(self.pluginmanager.hook)  # type: ignore[assignment]\n         self._inicache: Dict[str, Any] = {}\n         self._override_ini: Sequence[str] = ()\n         self._opt2dest: Dict[str, str] = {}\ndiff --git a/src/_pytest/config/compat.py b/src/_pytest/config/compat.py\nnew file mode 100644\nindex 00000000000..2856d85d195\n--- /dev/null\n+++ b/src/_pytest/config/compat.py\n@@ -0,0 +1,85 @@\n+from __future__ import annotations\n+\n+import functools\n+from pathlib import Path\n+from typing import Any\n+from typing import Mapping\n+import warnings\n+\n+import pluggy\n+\n+from ..compat import LEGACY_PATH\n+from ..compat import legacy_path\n+from ..deprecated import HOOK_LEGACY_PATH_ARG\n+\n+\n+# hookname: (Path, LEGACY_PATH)\n+imply_paths_hooks: Mapping[str, tuple[str, str]] = {\n+    \"pytest_ignore_collect\": (\"collection_path\", \"path\"),\n+    \"pytest_collect_file\": (\"file_path\", \"path\"),\n+    \"pytest_pycollect_makemodule\": (\"module_path\", \"path\"),\n+    \"pytest_report_header\": (\"start_path\", \"startdir\"),\n+    \"pytest_report_collectionfinish\": (\"start_path\", \"startdir\"),\n+}\n+\n+\n+def _check_path(path: Path, fspath: LEGACY_PATH) -> None:\n+    if Path(fspath) != path:\n+        raise ValueError(\n+            f\"Path({fspath!r}) != {path!r}\\n\"\n+            \"if both path and fspath are given they need to be equal\"\n+        )\n+\n+\n+class PathAwareHookProxy:\n+    \"\"\"\n+    this helper wraps around hook callers\n+    until pluggy supports fixingcalls, this one will do\n+\n+    it currently doesn't return full hook caller proxies for fixed hooks,\n+    this may have to be changed later depending on bugs\n+    \"\"\"\n+\n+    def __init__(self, hook_relay: pluggy.HookRelay) -> None:\n+        self._hook_relay = hook_relay\n+\n+    def __dir__(self) -> list[str]:\n+        return dir(self._hook_relay)\n+\n+    def __getattr__(self, key: str) -> pluggy.HookCaller:\n+        hook: pluggy.HookCaller = getattr(self._hook_relay, key)\n+        if key not in imply_paths_hooks:\n+            self.__dict__[key] = hook\n+            return hook\n+        else:\n+            path_var, fspath_var = imply_paths_hooks[key]\n+\n+            @functools.wraps(hook)\n+            def fixed_hook(**kw: Any) -> Any:\n+                path_value: Path | None = kw.pop(path_var, None)\n+                fspath_value: LEGACY_PATH | None = kw.pop(fspath_var, None)\n+                if fspath_value is not None:\n+                    warnings.warn(\n+                        HOOK_LEGACY_PATH_ARG.format(\n+                            pylib_path_arg=fspath_var, pathlib_path_arg=path_var\n+                        ),\n+                        stacklevel=2,\n+                    )\n+                if path_value is not None:\n+                    if fspath_value is not None:\n+                        _check_path(path_value, fspath_value)\n+                    else:\n+                        fspath_value = legacy_path(path_value)\n+                else:\n+                    assert fspath_value is not None\n+                    path_value = Path(fspath_value)\n+\n+                kw[path_var] = path_value\n+                kw[fspath_var] = fspath_value\n+                return hook(**kw)\n+\n+            fixed_hook.name = hook.name  # type: ignore[attr-defined]\n+            fixed_hook.spec = hook.spec  # type: ignore[attr-defined]\n+            fixed_hook.__name__ = key\n+            self.__dict__[key] = fixed_hook\n+            return fixed_hook  # type: ignore[return-value]\ndiff --git a/src/_pytest/deprecated.py b/src/_pytest/deprecated.py\nindex 56271c9578e..10811d158aa 100644\n--- a/src/_pytest/deprecated.py\n+++ b/src/_pytest/deprecated.py\n@@ -36,6 +36,21 @@\n PRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\n \n \n+HOOK_LEGACY_PATH_ARG = UnformattedWarning(\n+    PytestRemovedIn9Warning,\n+    \"The ({pylib_path_arg}: py.path.local) argument is deprecated, please use ({pathlib_path_arg}: pathlib.Path)\\n\"\n+    \"see https://docs.pytest.org/en/latest/deprecations.html\"\n+    \"#py-path-local-arguments-for-hooks-replaced-with-pathlib-path\",\n+)\n+\n+NODE_CTOR_FSPATH_ARG = UnformattedWarning(\n+    PytestRemovedIn9Warning,\n+    \"The (fspath: py.path.local) argument to {node_type_name} is deprecated. \"\n+    \"Please use the (path: pathlib.Path) argument instead.\\n\"\n+    \"See https://docs.pytest.org/en/latest/deprecations.html\"\n+    \"#fspath-argument-for-node-constructors-replaced-with-pathlib-path\",\n+)\n+\n HOOK_LEGACY_MARKING = UnformattedWarning(\n     PytestDeprecationWarning,\n     \"The hook{type} {fullname} uses old-style configuration options (marks or attributes).\\n\"\ndiff --git a/src/_pytest/hookspec.py b/src/_pytest/hookspec.py\nindex 58f4986ec7e..4bee76f1e39 100644\n--- a/src/_pytest/hookspec.py\n+++ b/src/_pytest/hookspec.py\n@@ -22,6 +22,7 @@\n \n     from _pytest._code.code import ExceptionInfo\n     from _pytest._code.code import ExceptionRepr\n+    from _pytest.compat import LEGACY_PATH\n     from _pytest.config import _PluggyPlugin\n     from _pytest.config import Config\n     from _pytest.config import ExitCode\n@@ -296,7 +297,9 @@ def pytest_collection_finish(session: \"Session\") -> None:\n \n \n @hookspec(firstresult=True)\n-def pytest_ignore_collect(collection_path: Path, config: \"Config\") -> Optional[bool]:\n+def pytest_ignore_collect(\n+    collection_path: Path, path: \"LEGACY_PATH\", config: \"Config\"\n+) -> Optional[bool]:\n     \"\"\"Return True to prevent considering this path for collection.\n \n     This hook is consulted for all files and directories prior to calling\n@@ -310,10 +313,8 @@ def pytest_ignore_collect(collection_path: Path, config: \"Config\") -> Optional[b\n \n     .. versionchanged:: 7.0.0\n         The ``collection_path`` parameter was added as a :class:`pathlib.Path`\n-        equivalent of the ``path`` parameter.\n-\n-    .. versionchanged:: 8.0.0\n-        The ``path`` parameter has been removed.\n+        equivalent of the ``path`` parameter. The ``path`` parameter\n+        has been deprecated.\n \n     Use in conftest plugins\n     =======================\n@@ -354,7 +355,9 @@ def pytest_collect_directory(path: Path, parent: \"Collector\") -> \"Optional[Colle\n     \"\"\"\n \n \n-def pytest_collect_file(file_path: Path, parent: \"Collector\") -> \"Optional[Collector]\":\n+def pytest_collect_file(\n+    file_path: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n+) -> \"Optional[Collector]\":\n     \"\"\"Create a :class:`~pytest.Collector` for the given path, or None if not relevant.\n \n     For best results, the returned collector should be a subclass of\n@@ -367,10 +370,8 @@ def pytest_collect_file(file_path: Path, parent: \"Collector\") -> \"Optional[Colle\n \n     .. versionchanged:: 7.0.0\n         The ``file_path`` parameter was added as a :class:`pathlib.Path`\n-        equivalent of the ``path`` parameter.\n-\n-    .. versionchanged:: 8.0.0\n-        The ``path`` parameter was removed.\n+        equivalent of the ``path`` parameter. The ``path`` parameter\n+        has been deprecated.\n \n     Use in conftest plugins\n     =======================\n@@ -467,7 +468,9 @@ def pytest_make_collect_report(collector: \"Collector\") -> \"Optional[CollectRepor\n \n \n @hookspec(firstresult=True)\n-def pytest_pycollect_makemodule(module_path: Path, parent) -> Optional[\"Module\"]:\n+def pytest_pycollect_makemodule(\n+    module_path: Path, path: \"LEGACY_PATH\", parent\n+) -> Optional[\"Module\"]:\n     \"\"\"Return a :class:`pytest.Module` collector or None for the given path.\n \n     This hook will be called for each matching test module path.\n@@ -483,8 +486,7 @@ def pytest_pycollect_makemodule(module_path: Path, parent) -> Optional[\"Module\"]\n         The ``module_path`` parameter was added as a :class:`pathlib.Path`\n         equivalent of the ``path`` parameter.\n \n-    .. versionchanged:: 8.0.0\n-        The ``path`` parameter has been removed in favor of ``module_path``.\n+        The ``path`` parameter has been deprecated in favor of ``fspath``.\n \n     Use in conftest plugins\n     =======================\n@@ -992,7 +994,7 @@ def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> No\n \n \n def pytest_report_header(  # type:ignore[empty-body]\n-    config: \"Config\", start_path: Path\n+    config: \"Config\", start_path: Path, startdir: \"LEGACY_PATH\"\n ) -> Union[str, List[str]]:\n     \"\"\"Return a string or list of strings to be displayed as header info for terminal reporting.\n \n@@ -1009,10 +1011,8 @@ def pytest_report_header(  # type:ignore[empty-body]\n \n     .. versionchanged:: 7.0.0\n         The ``start_path`` parameter was added as a :class:`pathlib.Path`\n-        equivalent of the ``startdir`` parameter.\n-\n-    .. versionchanged:: 8.0.0\n-        The ``startdir`` parameter has been removed.\n+        equivalent of the ``startdir`` parameter. The ``startdir`` parameter\n+        has been deprecated.\n \n     Use in conftest plugins\n     =======================\n@@ -1024,6 +1024,7 @@ def pytest_report_header(  # type:ignore[empty-body]\n def pytest_report_collectionfinish(  # type:ignore[empty-body]\n     config: \"Config\",\n     start_path: Path,\n+    startdir: \"LEGACY_PATH\",\n     items: Sequence[\"Item\"],\n ) -> Union[str, List[str]]:\n     \"\"\"Return a string or list of strings to be displayed after collection\n@@ -1047,10 +1048,8 @@ def pytest_report_collectionfinish(  # type:ignore[empty-body]\n \n     .. versionchanged:: 7.0.0\n         The ``start_path`` parameter was added as a :class:`pathlib.Path`\n-        equivalent of the ``startdir`` parameter.\n-\n-    .. versionchanged:: 8.0.0\n-        The ``startdir`` parameter has been removed.\n+        equivalent of the ``startdir`` parameter. The ``startdir`` parameter\n+        has been deprecated.\n \n     Use in conftest plugins\n     =======================\ndiff --git a/src/_pytest/legacypath.py b/src/_pytest/legacypath.py\nindex b56f3a6fb63..b28c89767fe 100644\n--- a/src/_pytest/legacypath.py\n+++ b/src/_pytest/legacypath.py\n@@ -1,7 +1,7 @@\n # mypy: allow-untyped-defs\n \"\"\"Add backward compatibility support for the legacy py path type.\"\"\"\n+\n import dataclasses\n-import os\n from pathlib import Path\n import shlex\n import subprocess\n@@ -14,9 +14,9 @@\n \n from iniconfig import SectionWrapper\n \n-import py\n-\n from _pytest.cacheprovider import Cache\n+from _pytest.compat import LEGACY_PATH\n+from _pytest.compat import legacy_path\n from _pytest.config import Config\n from _pytest.config import hookimpl\n from _pytest.config import PytestPluginManager\n@@ -39,20 +39,6 @@\n     import pexpect\n \n \n-#: constant to prepare valuing pylib path replacements/lazy proxies later on\n-#  intended for removal in pytest 8.0 or 9.0\n-\n-# fmt: off\n-# intentional space to create a fake difference for the verification\n-LEGACY_PATH = py.path. local\n-# fmt: on\n-\n-\n-def legacy_path(path: Union[str, \"os.PathLike[str]\"]) -> LEGACY_PATH:\n-    \"\"\"Internal wrapper to prepare lazy proxies for legacy_path instances\"\"\"\n-    return LEGACY_PATH(path)\n-\n-\n @final\n class Testdir:\n     \"\"\"\ndiff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 1de86be868c..3b9ac93cf3f 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -37,6 +37,7 @@\n from _pytest.config import PytestPluginManager\n from _pytest.config import UsageError\n from _pytest.config.argparsing import Parser\n+from _pytest.config.compat import PathAwareHookProxy\n from _pytest.fixtures import FixtureManager\n from _pytest.outcomes import exit\n from _pytest.pathlib import absolutepath\n@@ -557,6 +558,7 @@ def __init__(self, config: Config) -> None:\n         super().__init__(\n             name=\"\",\n             path=config.rootpath,\n+            fspath=None,\n             parent=None,\n             config=config,\n             session=self,\n@@ -694,7 +696,7 @@ def gethookproxy(self, fspath: \"os.PathLike[str]\") -> pluggy.HookRelay:\n         proxy: pluggy.HookRelay\n         if remove_mods:\n             # One or more conftests are not in use at this path.\n-            proxy = FSHookProxy(pm, remove_mods)  # type: ignore[arg-type,assignment]\n+            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))  # type: ignore[arg-type,assignment]\n         else:\n             # All plugins are active for this fspath.\n             proxy = self.config.hook\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 2381b65eaf9..cff15001c93 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -3,6 +3,7 @@\n from functools import cached_property\n from inspect import signature\n import os\n+import pathlib\n from pathlib import Path\n from typing import Any\n from typing import Callable\n@@ -29,8 +30,11 @@\n from _pytest._code.code import ExceptionInfo\n from _pytest._code.code import TerminalRepr\n from _pytest._code.code import Traceback\n+from _pytest.compat import LEGACY_PATH\n from _pytest.config import Config\n from _pytest.config import ConftestImportFailure\n+from _pytest.config.compat import _check_path\n+from _pytest.deprecated import NODE_CTOR_FSPATH_ARG\n from _pytest.mark.structures import Mark\n from _pytest.mark.structures import MarkDecorator\n from _pytest.mark.structures import NodeKeywords\n@@ -55,6 +59,29 @@\n \n \n _T = TypeVar(\"_T\")\n+\n+\n+def _imply_path(\n+    node_type: Type[\"Node\"],\n+    path: Optional[Path],\n+    fspath: Optional[LEGACY_PATH],\n+) -> Path:\n+    if fspath is not None:\n+        warnings.warn(\n+            NODE_CTOR_FSPATH_ARG.format(\n+                node_type_name=node_type.__name__,\n+            ),\n+            stacklevel=6,\n+        )\n+    if path is not None:\n+        if fspath is not None:\n+            _check_path(path, fspath)\n+        return path\n+    else:\n+        assert fspath is not None\n+        return Path(fspath)\n+\n+\n _NodeType = TypeVar(\"_NodeType\", bound=\"Node\")\n \n \n@@ -110,6 +137,13 @@ class Node(abc.ABC, metaclass=NodeMeta):\n     leaf nodes.\n     \"\"\"\n \n+    # Implemented in the legacypath plugin.\n+    #: A ``LEGACY_PATH`` copy of the :attr:`path` attribute. Intended for usage\n+    #: for methods not migrated to ``pathlib.Path`` yet, such as\n+    #: :meth:`Item.reportinfo <pytest.Item.reportinfo>`. Will be deprecated in\n+    #: a future release, prefer using :attr:`path` instead.\n+    fspath: LEGACY_PATH\n+\n     # Use __slots__ to make attribute access faster.\n     # Note that __dict__ is still available.\n     __slots__ = (\n@@ -129,6 +163,7 @@ def __init__(\n         parent: \"Optional[Node]\" = None,\n         config: Optional[Config] = None,\n         session: \"Optional[Session]\" = None,\n+        fspath: Optional[LEGACY_PATH] = None,\n         path: Optional[Path] = None,\n         nodeid: Optional[str] = None,\n     ) -> None:\n@@ -154,11 +189,10 @@ def __init__(\n                 raise TypeError(\"session or parent must be provided\")\n             self.session = parent.session\n \n-        if path is None:\n+        if path is None and fspath is None:\n             path = getattr(parent, \"path\", None)\n-        assert path is not None\n         #: Filesystem path where this node was collected from (can be None).\n-        self.path = path\n+        self.path: pathlib.Path = _imply_path(type(self), path, fspath=fspath)\n \n         # The explicit annotation is to avoid publicly exposing NodeKeywords.\n         #: Keywords/markers collected from all scopes.\n@@ -529,6 +563,7 @@ class FSCollector(Collector, abc.ABC):\n \n     def __init__(\n         self,\n+        fspath: Optional[LEGACY_PATH] = None,\n         path_or_parent: Optional[Union[Path, Node]] = None,\n         path: Optional[Path] = None,\n         name: Optional[str] = None,\n@@ -544,8 +579,8 @@ def __init__(\n             elif isinstance(path_or_parent, Path):\n                 assert path is None\n                 path = path_or_parent\n-        assert path is not None\n \n+        path = _imply_path(type(self), path, fspath=fspath)\n         if name is None:\n             name = path.name\n             if parent is not None and parent.path != path:\n@@ -585,11 +620,12 @@ def from_parent(\n         cls,\n         parent,\n         *,\n+        fspath: Optional[LEGACY_PATH] = None,\n         path: Optional[Path] = None,\n         **kw,\n     ) -> \"Self\":\n         \"\"\"The public constructor.\"\"\"\n-        return super().from_parent(parent=parent, path=path, **kw)\n+        return super().from_parent(parent=parent, fspath=fspath, path=path, **kw)\n \n \n class File(FSCollector, abc.ABC):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex e1730b1a7e0..1bbe9600492 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -48,6 +48,7 @@\n from _pytest.compat import getlocation\n from _pytest.compat import is_async_function\n from _pytest.compat import is_generator\n+from _pytest.compat import LEGACY_PATH\n from _pytest.compat import NOTSET\n from _pytest.compat import safe_getattr\n from _pytest.compat import safe_isclass\n@@ -665,6 +666,7 @@ class Package(nodes.Directory):\n \n     def __init__(\n         self,\n+        fspath: Optional[LEGACY_PATH],\n         parent: nodes.Collector,\n         # NOTE: following args are unused:\n         config=None,\n@@ -676,6 +678,7 @@ def __init__(\n         # super().__init__(self, fspath, parent=parent)\n         session = parent.session\n         super().__init__(\n+            fspath=fspath,\n             path=path,\n             parent=parent,\n             config=config,\ndiff --git a/testing/deprecated_test.py b/testing/deprecated_test.py\nindex a5f51306358..2be4d6dfc47 100644\n--- a/testing/deprecated_test.py\n+++ b/testing/deprecated_test.py\n@@ -1,5 +1,10 @@\n # mypy: allow-untyped-defs\n+from pathlib import Path\n+import re\n+import sys\n+\n from _pytest import deprecated\n+from _pytest.compat import legacy_path\n from _pytest.pytester import Pytester\n import pytest\n from pytest import PytestDeprecationWarning\n@@ -85,6 +90,56 @@ def __init__(self, foo: int, *, _ispytest: bool = False) -> None:\n     PrivateInit(10, _ispytest=True)\n \n \n+@pytest.mark.parametrize(\"hooktype\", [\"hook\", \"ihook\"])\n+def test_hookproxy_warnings_for_pathlib(tmp_path, hooktype, request):\n+    path = legacy_path(tmp_path)\n+\n+    PATH_WARN_MATCH = r\".*path: py\\.path\\.local\\) argument is deprecated, please use \\(collection_path: pathlib\\.Path.*\"\n+    if hooktype == \"ihook\":\n+        hooks = request.node.ihook\n+    else:\n+        hooks = request.config.hook\n+\n+    with pytest.warns(PytestDeprecationWarning, match=PATH_WARN_MATCH) as r:\n+        l1 = sys._getframe().f_lineno\n+        hooks.pytest_ignore_collect(\n+            config=request.config, path=path, collection_path=tmp_path\n+        )\n+        l2 = sys._getframe().f_lineno\n+\n+    (record,) = r\n+    assert record.filename == __file__\n+    assert l1 < record.lineno < l2\n+\n+    hooks.pytest_ignore_collect(config=request.config, collection_path=tmp_path)\n+\n+    # Passing entirely *different* paths is an outright error.\n+    with pytest.raises(ValueError, match=r\"path.*fspath.*need to be equal\"):\n+        with pytest.warns(PytestDeprecationWarning, match=PATH_WARN_MATCH) as r:\n+            hooks.pytest_ignore_collect(\n+                config=request.config, path=path, collection_path=Path(\"/bla/bla\")\n+            )\n+\n+\n+def test_node_ctor_fspath_argument_is_deprecated(pytester: Pytester) -> None:\n+    mod = pytester.getmodulecol(\"\")\n+\n+    class MyFile(pytest.File):\n+        def collect(self):\n+            raise NotImplementedError()\n+\n+    with pytest.warns(\n+        pytest.PytestDeprecationWarning,\n+        match=re.escape(\n+            \"The (fspath: py.path.local) argument to MyFile is deprecated.\"\n+        ),\n+    ):\n+        MyFile.from_parent(\n+            parent=mod.parent,\n+            fspath=legacy_path(\"bla\"),\n+        )\n+\n+\n def test_fixture_disallow_on_marked_functions():\n     \"\"\"Test that applying @pytest.fixture to a marked function warns (#3364).\"\"\"\n     with pytest.warns(\ndiff --git a/testing/test_legacypath.py b/testing/test_legacypath.py\nindex 850f14c58a0..49e620c1138 100644\n--- a/testing/test_legacypath.py\n+++ b/testing/test_legacypath.py\n@@ -1,8 +1,8 @@\n # mypy: allow-untyped-defs\n from pathlib import Path\n \n+from _pytest.compat import LEGACY_PATH\n from _pytest.fixtures import TopRequest\n-from _pytest.legacypath import LEGACY_PATH\n from _pytest.legacypath import TempdirFactory\n from _pytest.legacypath import Testdir\n import pytest\n@@ -16,7 +16,7 @@ def test_item_fspath(pytester: pytest.Pytester) -> None:\n     items2, hookrec = pytester.inline_genitems(item.nodeid)\n     (item2,) = items2\n     assert item2.name == item.name\n-    assert item2.fspath == item.fspath  # type: ignore[attr-defined]\n+    assert item2.fspath == item.fspath\n     assert item2.path == item.path\n \n \ndiff --git a/testing/test_nodes.py b/testing/test_nodes.py\nindex e019f163c2b..a3caf471f70 100644\n--- a/testing/test_nodes.py\n+++ b/testing/test_nodes.py\n@@ -6,6 +6,7 @@\n import warnings\n \n from _pytest import nodes\n+from _pytest.compat import legacy_path\n from _pytest.outcomes import OutcomeException\n from _pytest.pytester import Pytester\n from _pytest.warning_types import PytestWarning\n@@ -44,9 +45,9 @@ def test_subclassing_both_item_and_collector_deprecated(\n         warnings.simplefilter(\"error\")\n \n         class SoWrong(nodes.Item, nodes.File):\n-            def __init__(self, path, parent):\n+            def __init__(self, fspath, parent):\n                 \"\"\"Legacy ctor with legacy call # don't wana see\"\"\"\n-                super().__init__(parent, path)\n+                super().__init__(fspath, parent)\n \n             def collect(self):\n                 raise NotImplementedError()\n@@ -55,7 +56,9 @@ def runtest(self):\n                 raise NotImplementedError()\n \n     with pytest.warns(PytestWarning) as rec:\n-        SoWrong.from_parent(request.session, path=tmp_path / \"broken.txt\", wrong=10)\n+        SoWrong.from_parent(\n+            request.session, fspath=legacy_path(tmp_path / \"broken.txt\")\n+        )\n     messages = [str(x.message) for x in rec]\n     assert any(\n         re.search(\".*SoWrong.* not using a cooperative constructor.*\", x)\n", "problem_statement": "[YANKED] pytest 8.1.0 removes many deprecations, but not mentioned in changelog\nhttps://github.com/pytest-dev/pytest/pull/11757 is not mentioned as a breaking change for the Pytest 8.1.0 Release in https://docs.pytest.org/en/stable/changelog.html ; it breaks plugins who were still supporting the older signature.\r\n\r\nI'm opening this issue as a hint to others; is it possible to update the changelog after a release?\n", "hints_text": "this is a duplicate of #12068 \r\n\r\nthe removal process itself is as intended, the oversight was that warnings of certain hooks where not displayed as expected\r\n\r\nleaving this open for now to help people\r\nthe fact that it wasn't failing on 8.0 is the actual bug\r\n\n@RonnyPfannschmidt @nicoddemus since we botched the deprecation, perhaps we should revert the removal until we can have at least one release with proper deprecation?\nshould we yank 8.1 for the deprecation issues?\nlets defer the return of code a bit as i'd like to know first how to trigger the errors\nI think it is fair to postpone the removals if we did not issue the proper warnings, as we vouch to do before any removals took place.\r\n\r\nThose removals would then have to be postponed to 9.0/9.1 then.\r\n\r\nNot sure if you folks would like to yank 8.1? Seems reasonable.\nReverting + releasing 8.1.1 should not be a problem, but if @RonnyPfannschmidt wants to avoid a revert, let's yank as it seems to be causing a lot of failures.\nlets yank and revert then\r\n\nI'm yanking it.\n![image](https://github.com/pytest-dev/pytest/assets/1085180/c83eaeb3-95a5-42df-92fb-96e0868cea2e)\r\n\nThanks @nicoddemus!\r\n\r\n@RonnyPfannschmidt do you want me to revert the removal, or do you want to?\nOpening PR to update the CHANGELOG.\nDear maintainers and devs, thank you for all that you do and the quick response! \ud83d\udc96\n> @RonnyPfannschmidt do you want me to revert the removal, or do you want to?\r\n\r\nJust to make sure we are all on the same page, is anybody working on the revert?\nApologies, I was hoping to get to it, but I won't be able to Touch it this week \nPlease note that yanking the release now broke all pipelines, workflows, lock files for everyone else too even for these where v8.1.0 worked fined. It would have been nicer to revert the changes and release a new fixed version (e.g. 8.1.1).\n@jgraichen how did it break?\n@bluetech All users that bumped `pytest` to `8.1` in the last days can no longer resolve or install the correct pytest version. Bumping is easy nowadays, thanks to dependabot or renovatebot (e.g. https://github.com/jgraichen/salt-tower/pull/83).\r\n\r\nAfter yanking, [no compatible version can be resolved anymore](https://github.com/jgraichen/salt-tower/actions/runs/8165237388/job/22322041607?pr=85).\r\n\r\nIt might affect package managers with a lock file too, if pytest was bumped to 8.1.0 already, but not sure here due to https://pypi.org/help/#yanked.\nAs per specification,it ought to be ignored unless it's strictly pinned\n\nI fail to see how this creates failure outside of something deliberately counter acting the tooling\n\nAre you aware of a concrete case?\n@RonnyPfannschmidt Every project that bumps constraint ranges e.g. to `~=8.1.0`. See https://github.com/jgraichen/salt-tower/pull/83 as one public example.\n> Please note that yanking the release now broke all pipelines, workflows, lock files for everyone else too even for these where v8.1.0 worked fined. It would have been nicer to revert the changes and release a new fixed version (e.g. 8.1.1).\r\n\r\nI was under the impression that yanking was safe, meant exactly to not break those pinning the project... But I understand this would break users if somebody updated their manifests to `>=8.1.0`.\nfwiw all my (poetry) packages that dependabot bumped to 8.1.0 in the lock file have no problem installing that version\nIt is common practice in dependency update managers to  bump the lower bound, so yanking is not a good idea imo. \r\n\r\nIt's probably better to leave the release up - if it breaks things, people will notice in their pipelines anyway.\nIt seems the common practice is broken\n\nOpportunistic bump of lower bounds is fatal\n\nLower bound should bump on feature needs\n\n\nI'm a bit surprise by this practice of updating lower bounds automatically too.\r\n\r\nRegardless, we will not revert the yank at this point -- it would only cause even more confusion.\r\n\r\nWe hope to get a new 8.1.1 soon, I will try to reserve some time later today to revert the removal of the deprecated features.\nBut in retrospect we probably should not have yanked the release. \r\n\r\nYanking should be used only in situations where the released package is broken/unusable, when (almost) every installation of the package will break the environment and/or runtime. In this case we only broke some plugins, but users not using those plugins were unaffected.\r\n\r\nLive and learn I guess.", "created_at": "2024-03-07T22:40:48Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12085, "instance_id": "pytest-dev__pytest-12085", "issue_numbers": ["11871"], "base_commit": "4a8bd5f2e2c365a42b8022c41c532eb2fbe802f6", "patch": "diff --git a/.gitignore b/.gitignore\nindex 3cac2474a59..9fccf93f7c3 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -51,6 +51,7 @@ coverage.xml\n .settings\n .vscode\n __pycache__/\n+.python-version\n \n # generated by pip\n pip-wheel-metadata/\ndiff --git a/AUTHORS b/AUTHORS\nindex 4c4d68df147..53f7a8c2a16 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -235,6 +235,7 @@ Kyle Altendorf\n Lawrence Mitchell\n Lee Kamentsky\n Lev Maximov\n+Levon Saldamli\n Lewis Cowles\n Llandy Riveron Del Risco\n Loic Esteve\ndiff --git a/changelog/11871.feature.rst b/changelog/11871.feature.rst\nnew file mode 100644\nindex 00000000000..530db8c3c6f\n--- /dev/null\n+++ b/changelog/11871.feature.rst\n@@ -0,0 +1,1 @@\n+Added support for reading command line arguments from a file using the prefix character ``@``, like e.g.: ``pytest @tests.txt``. The file must have one argument per line.\ndiff --git a/doc/en/how-to/usage.rst b/doc/en/how-to/usage.rst\nindex 65f9debd852..fe46fad2db5 100644\n--- a/doc/en/how-to/usage.rst\n+++ b/doc/en/how-to/usage.rst\n@@ -17,7 +17,8 @@ in the current directory and its subdirectories. More generally, pytest follows\n Specifying which tests to run\n ------------------------------\n \n-Pytest supports several ways to run and select tests from the command-line.\n+Pytest supports several ways to run and select tests from the command-line or from a file\n+(see below for :ref:`reading arguments from file <args-from-file>`).\n \n **Run tests in a module**\n \n@@ -91,6 +92,28 @@ For more information see :ref:`marks <mark>`.\n \n This will import ``pkg.testing`` and use its filesystem location to find and run tests from.\n \n+.. _args-from-file:\n+\n+**Read arguments from file**\n+\n+.. versionadded:: 8.2\n+\n+All of the above can be read from a file using the ``@`` prefix:\n+\n+.. code-block:: bash\n+\n+    pytest @tests_to_run.txt\n+\n+where ``tests_to_run.txt`` contains an entry per line, e.g.:\n+\n+.. code-block:: text\n+\n+    tests/test_file.py\n+    tests/test_mod.py::test_func[x1,y2]\n+    tests/test_mod.py::TestClass\n+    -m slow\n+\n+This file can also be generated using ``pytest --collect-only -q`` and modified as needed.\n \n Getting help on version, option names, environment variables\n --------------------------------------------------------------\n", "test_patch": "diff --git a/src/_pytest/config/argparsing.py b/src/_pytest/config/argparsing.py\nindex d98f1ae9a12..441d79e902c 100644\n--- a/src/_pytest/config/argparsing.py\n+++ b/src/_pytest/config/argparsing.py\n@@ -415,6 +415,7 @@ def __init__(\n             add_help=False,\n             formatter_class=DropShorterLongHelpFormatter,\n             allow_abbrev=False,\n+            fromfile_prefix_chars=\"@\",\n         )\n         # extra_info is a dict of (param -> value) to display if there's\n         # an usage error to provide more contextual information to the user.\ndiff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\nindex e41d7a81fd9..8f001bc2401 100644\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -2,6 +2,7 @@\n import dataclasses\n import importlib.metadata\n import os\n+from pathlib import Path\n import subprocess\n import sys\n import types\n@@ -541,6 +542,32 @@ def test_foo(data):\n         res = pytester.runpytest(p)\n         res.assert_outcomes(passed=3)\n \n+    # Warning ignore because of:\n+    # https://github.com/python/cpython/issues/85308\n+    # Can be removed once Python<3.12 support is dropped.\n+    @pytest.mark.filterwarnings(\"ignore:'encoding' argument not specified\")\n+    def test_command_line_args_from_file(\n+        self, pytester: Pytester, tmp_path: Path\n+    ) -> None:\n+        pytester.makepyfile(\n+            test_file=\"\"\"\n+            import pytest\n+\n+            class TestClass:\n+                @pytest.mark.parametrize(\"a\", [\"x\",\"y\"])\n+                def test_func(self, a):\n+                    pass\n+            \"\"\"\n+        )\n+        tests = [\n+            \"test_file.py::TestClass::test_func[x]\",\n+            \"test_file.py::TestClass::test_func[y]\",\n+            \"-q\",\n+        ]\n+        args_file = pytester.maketxtfile(tests=\"\\n\".join(tests))\n+        result = pytester.runpytest(f\"@{args_file}\")\n+        result.assert_outcomes(failed=0, passed=2)\n+\n \n class TestInvocationVariants:\n     def test_earlyinit(self, pytester: Pytester) -> None:\ndiff --git a/testing/test_parseopt.py b/testing/test_parseopt.py\nindex 4678d8bdba7..e959dfd631b 100644\n--- a/testing/test_parseopt.py\n+++ b/testing/test_parseopt.py\n@@ -125,6 +125,17 @@ def test_parse2(self, parser: parseopt.Parser) -> None:\n         args = parser.parse([Path(\".\")])\n         assert getattr(args, parseopt.FILE_OR_DIR)[0] == \".\"\n \n+    # Warning ignore because of:\n+    # https://github.com/python/cpython/issues/85308\n+    # Can be removed once Python<3.12 support is dropped.\n+    @pytest.mark.filterwarnings(\"ignore:'encoding' argument not specified\")\n+    def test_parse_from_file(self, parser: parseopt.Parser, tmp_path: Path) -> None:\n+        tests = [\".\", \"some.py::Test::test_method[param0]\", \"other/test_file.py\"]\n+        args_file = tmp_path / \"tests.txt\"\n+        args_file.write_text(\"\\n\".join(tests), encoding=\"utf-8\")\n+        args = parser.parse([f\"@{args_file.absolute()}\"])\n+        assert getattr(args, parseopt.FILE_OR_DIR) == tests\n+\n     def test_parse_known_args(self, parser: parseopt.Parser) -> None:\n         parser.parse_known_args([Path(\".\")])\n         parser.addoption(\"--hello\", action=\"store_true\")\n", "problem_statement": "Proposing a new flag, `--list-of-files-or-dirs`, to compliment the positional `file_or_dir` argument\n#### What's the problem this feature will solve?\r\nPassing a long list of test files/dirs into the pytest CLI can make reading the pytest command confusing.\r\n\r\n#### Describe the solution you'd like\r\nA new flag, `--list-of-files-or-dirs`, to compliment the positional `file_or_dir` argument.\r\n\r\nThe new flag will accept a single text file, with each line in the file representing a positional argument to pytest.\r\n\r\nSo, instead of calling pytest like this:\r\n`pytest test_file1.py test_file2.py test_file3.py ...`\r\nOne would call:\r\n`pytest --list-of-files-or-dirs list_file.txt`\r\nWith `list_file.txt` containing:\r\n\r\n```\r\ntest_file1.py\r\ntest_file2.py\r\ntest_file3.py\r\n...\r\n```\r\n\r\n#### Alternative Solutions\r\nYou can currently just call pytest with a list of all the files/dirs you want to test, but a long list passed through the CLI isn't such a clean interface.\r\n\r\n#### Additional context\r\nHappy to work take a stab at working on this if there's consensus that such a PR would be accepted.\n", "hints_text": "Can you talk a bit more about your use-case? Why are you passing such a long list of files in the first place?\nWe're looking into dynamically choosing which tests to run for a given PR as part of our CI run.\r\n\r\nThe output of this test selection would be a list of tests from our test suite to run. The list is 0...N, and although this is discouraged, N theoretically could be hundreds of tests long if the PR is big / touches many files and functions.\ni would recommend using a collect_ignore hook\r\n\r\nthen instead of needing a new pytest feature and new pytest release, you can simply ignore/remove unwanted tests from collection either before collecting a file, or after collection completed\n`collect_ignore` lives inside `conftest.py`, which we already have populated in our repo. We'd ideally want to avoid changing any of our existing files for this feature.\r\n\r\nThe new file I'm proposing is a standalone, brand new file generated for the sake of CI alone, and so would not have any effect on existing code.\r\n\r\nMoreover, If we do go with this approach, we would need to first collect all our existing tests, and then deduct the list of tests we want to run, push that to `collect_ignore`, and then have pytest collect tests yet again. I can only imagine the amount of time this would add to our test suite, time that we're trying to shave here.\n@jbkkd Your use case makes sense, but I'm not clear why you need a file for this instead of passing the arguments on the command line as usual. That is, instead of `pytest --list-of-files-or-dirs list_file.txt` do `pytest $(cat list_file.txt)`.\r\n\r\n---\r\n\r\nThere is a convention of using `@file` for this, e.g. [gcc](https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html):\r\n\r\n> Read command-line options from file. The options read are inserted in place of the original `@file` option. If file does not exist, or cannot be read, then the option will be treated literally, and not removed.\r\n>\r\n> Options in file are separated by whitespace. A whitespace character may be included in an option by surrounding the entire option in either single or double quotes. Any character (including a backslash) may be included by prefixing the character to be included with a backslash. The file may itself contain additional `@file` options; any such options will be processed recursively.\r\n\r\nThe use case I'm familiar with is command line max length issues on Windows.\nI would like to add that the `cat` trick is shell specific, and you have to resort to other solutions when writing multi-platform \"scripts\" (for example the script part of a GitHub action).\r\n\r\nI think there are legitimate uses for this feature (in some form or another), plus it is simple to implement, we should consider adding it to pytest.\nhttps://docs.python.org/3/library/argparse.html#fromfile-prefix-chars\n\nIt's possible that it constitutes a breaking change, just very unlikely \nI think using `fromfile_prefix_chars='@'` would be nice, PR welcome.\nJust want to point out that it would be nice if the contents of the file could be the output of `pytest --collect-only -q`, e.g. one line of the input file could be\u00a0e.g. `file_path.py::TestClass::test_name[param_set0]`.\nthats how the `fromfile_prefix_chars` feature of argparse works", "created_at": "2024-03-06T23:17:47Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12050, "instance_id": "pytest-dev__pytest-12050", "issue_numbers": ["12039"], "base_commit": "6ed005161d329cc079e6439a17e7ac935c7c02e0", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex f78c4b3f94b..4c4d68df147 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -283,6 +283,7 @@ Mike Hoyle (hoylemd)\n Mike Lundy\n Milan Lesnek\n Miro Hron\u010dok\n+mrbean-bremen\n Nathaniel Compton\n Nathaniel Waisbrot\n Ned Batchelder\ndiff --git a/changelog/12039.bugfix.rst b/changelog/12039.bugfix.rst\nnew file mode 100644\nindex 00000000000..267eae6b8b2\n--- /dev/null\n+++ b/changelog/12039.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed a regression in ``8.0.2`` where tests created using :fixture:`tmp_path` have been collected multiple times in CI under Windows.\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex b7ed72ddc3b..d8cd023cc6e 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -924,7 +924,14 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n                         if sys.platform == \"win32\" and not is_match:\n                             # In case the file paths do not match, fallback to samefile() to\n                             # account for short-paths on Windows (#11895).\n-                            is_match = os.path.samefile(node.path, matchparts[0])\n+                            same_file = os.path.samefile(node.path, matchparts[0])\n+                            # We don't want to match links to the current node,\n+                            # otherwise we would match the same file more than once (#12039).\n+                            is_match = same_file and (\n+                                os.path.islink(node.path)\n+                                == os.path.islink(matchparts[0])\n+                            )\n+\n                     # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.\n                     else:\n                         # TODO: Remove parametrized workaround once collection structure contains\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex fbc8543e9c4..1491ec85990 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1765,7 +1765,7 @@ def test_foo(): assert True\n \n @pytest.mark.skipif(not sys.platform.startswith(\"win\"), reason=\"Windows only\")\n def test_collect_short_file_windows(pytester: Pytester) -> None:\n-    \"\"\"Reproducer for #11895: short paths not colleced on Windows.\"\"\"\n+    \"\"\"Reproducer for #11895: short paths not collected on Windows.\"\"\"\n     short_path = tempfile.mkdtemp()\n     if \"~\" not in short_path:  # pragma: no cover\n         if running_on_ci():\n@@ -1832,3 +1832,28 @@ def test_pyargs_collection_tree(pytester: Pytester, monkeypatch: MonkeyPatch) ->\n         ],\n         consecutive=True,\n     )\n+\n+\n+def test_do_not_collect_symlink_siblings(\n+    pytester: Pytester, tmp_path: Path, request: pytest.FixtureRequest\n+) -> None:\n+    \"\"\"\n+    Regression test for #12039: Do not collect from directories that are symlinks to other directories in the same path.\n+\n+    The check for short paths under Windows via os.path.samefile, introduced in #11936, also finds the symlinked\n+    directory created by tmp_path/tmpdir.\n+    \"\"\"\n+    # Use tmp_path because it creates a symlink with the name \"current\" next to the directory it creates.\n+    symlink_path = tmp_path.parent / (tmp_path.name[:-1] + \"current\")\n+    assert symlink_path.is_symlink() is True\n+\n+    # Create test file.\n+    tmp_path.joinpath(\"test_foo.py\").write_text(\"def test(): pass\", encoding=\"UTF-8\")\n+\n+    # Ensure we collect it only once if we pass the tmp_path.\n+    result = pytester.runpytest(tmp_path, \"-sv\")\n+    result.assert_outcomes(passed=1)\n+\n+    # Ensure we collect it only once if we pass the symlinked directory.\n+    result = pytester.runpytest(symlink_path, \"-sv\")\n+    result.assert_outcomes(passed=1)\n", "problem_statement": "Pytest 8.0.2 may collect tests multiple times under Windows\nI'm not quite sure if this is a bug, or a problem with the test or GitHub Actions, but since version 8.0.2 a test in `pytest-order` fails in the CI under Windows, which worked fine in 8.0.1 and previous versions. Linux and macOS tests are not affected.\r\n\r\nPytest run environment in the CI:\r\n```\r\nplatform win32 -- Python 3.11.8, pytest-8.0.2, pluggy-1.4.0 -- D:\\a\\pytest-order\\pytest-order\\.tox\\py311-pytest80\\Scripts\\python.EXE\r\ncachedir: .tox\\py311-pytest80\\.pytest_cache\r\nrootdir: D:\\a\\pytest-order\\pytest-order\r\nplugins: cov-2.9.0, dependency-0.6.0, mock-3.12.0, xdist-3.5.0\r\n```\r\nThe same happens for Python 3.8 - 3.12.\r\n\r\nThe [actual test](https://github.com/pytest-dev/pytest-order/blob/main/tests/test_xdist_handling.py) should collect 6 items (3 tests per test module, in 2 modules) that are created in the directory provided by the `tempdir` fixture, \r\nbut collects 24 tests in the CI instead. Locally, it works as expected.\r\n\r\nChecking the failed tests revealed that the tests have been collected from different locations. The tempdir had been at:\r\n`C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-runneradmin\\\\pytest-9\\\\test_xdist_ordering0` \r\n(for a specific run), but the same tests have been discovered with a test ID with just the qualified test name, and additionally with the test IDs:\r\n`::::Users::runneradmin::AppData::Local::Temp::pytest-of-runneradmin::pytest-9:::xxx` and \r\n`::::Documents and Settings::runneradmin::AppData::Local::Temp::pytest-of-runneradmin::pytest-9::xxx`,\r\nwhich are most likely aliases.\r\n\r\nI haven't dug into this yet, but I suspect it may have something to do with the fix for [the problem with short paths](https://github.com/pytest-dev/pytest/issues/11895).\r\n\n", "hints_text": "Hi @mrbean-bremen, thanks for the report! \r\n\r\nProbably it is related to the fix for short paths... perhaps it is collecting the soft-links that `tmpdir` creates? \ud83e\udd14 \r\n\r\nhttps://github.com/pytest-dev/pytest/blob/98b008ff6ca663723767f807cb730cc6833c9034/src/_pytest/pathlib.py#L206-L225", "created_at": "2024-03-03T07:42:16Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12048, "instance_id": "pytest-dev__pytest-12048", "issue_numbers": ["12047"], "base_commit": "6ed005161d329cc079e6439a17e7ac935c7c02e0", "patch": "diff --git a/changelog/12047.improvement.rst b/changelog/12047.improvement.rst\nnew file mode 100644\nindex 00000000000..e9ad5eddcab\n--- /dev/null\n+++ b/changelog/12047.improvement.rst\n@@ -0,0 +1,2 @@\n+When multiple finalizers of a fixture raise an exception, now all exceptions are reported as an exception group.\n+Previously, only the first exception was reported.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 0a505d65ad0..b619dc358e1 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -7,6 +7,7 @@\n import inspect\n import os\n from pathlib import Path\n+import sys\n from typing import AbstractSet\n from typing import Any\n from typing import Callable\n@@ -67,6 +68,10 @@\n from _pytest.scope import Scope\n \n \n+if sys.version_info[:2] < (3, 11):\n+    from exceptiongroup import BaseExceptionGroup\n+\n+\n if TYPE_CHECKING:\n     from typing import Deque\n \n@@ -1017,27 +1022,25 @@ def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n         self._finalizers.append(finalizer)\n \n     def finish(self, request: SubRequest) -> None:\n-        exc = None\n-        try:\n-            while self._finalizers:\n-                try:\n-                    func = self._finalizers.pop()\n-                    func()\n-                except BaseException as e:\n-                    # XXX Only first exception will be seen by user,\n-                    #     ideally all should be reported.\n-                    if exc is None:\n-                        exc = e\n-            if exc:\n-                raise exc\n-        finally:\n-            ihook = request.node.ihook\n-            ihook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n-            # Even if finalization fails, we invalidate the cached fixture\n-            # value and remove all finalizers because they may be bound methods\n-            # which will keep instances alive.\n-            self.cached_result = None\n-            self._finalizers.clear()\n+        exceptions: List[BaseException] = []\n+        while self._finalizers:\n+            fin = self._finalizers.pop()\n+            try:\n+                fin()\n+            except BaseException as e:\n+                exceptions.append(e)\n+        node = request.node\n+        node.ihook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n+        # Even if finalization fails, we invalidate the cached fixture\n+        # value and remove all finalizers because they may be bound methods\n+        # which will keep instances alive.\n+        self.cached_result = None\n+        self._finalizers.clear()\n+        if len(exceptions) == 1:\n+            raise exceptions[0]\n+        elif len(exceptions) > 1:\n+            msg = f'errors while tearing down fixture \"{self.argname}\" of {node}'\n+            raise BaseExceptionGroup(msg, exceptions[::-1])\n \n     def execute(self, request: SubRequest) -> FixtureValue:\n         # Get required arguments and register our own finish()\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 299e411a695..6edff6ecd43 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -932,8 +932,9 @@ def test_request_subrequest_addfinalizer_exceptions(\n         self, pytester: Pytester\n     ) -> None:\n         \"\"\"\n-        Ensure exceptions raised during teardown by a finalizer are suppressed\n-        until all finalizers are called, re-raising the first exception (#2440)\n+        Ensure exceptions raised during teardown by finalizers are suppressed\n+        until all finalizers are called, then re-reaised together in an\n+        exception group (#2440)\n         \"\"\"\n         pytester.makepyfile(\n             \"\"\"\n@@ -960,8 +961,16 @@ def test_second():\n         \"\"\"\n         )\n         result = pytester.runpytest()\n+        result.assert_outcomes(passed=2, errors=1)\n         result.stdout.fnmatch_lines(\n-            [\"*Exception: Error in excepts fixture\", \"* 2 passed, 1 error in *\"]\n+            [\n+                '  | *ExceptionGroup: errors while tearing down fixture \"subrequest\" of <Function test_first> (2 sub-exceptions)',  # noqa: E501\n+                \"  +-+---------------- 1 ----------------\",\n+                \"    | Exception: Error in something fixture\",\n+                \"    +---------------- 2 ----------------\",\n+                \"    | Exception: Error in excepts fixture\",\n+                \"    +------------------------------------\",\n+            ],\n         )\n \n     def test_request_getmodulepath(self, pytester: Pytester) -> None:\n", "problem_statement": "When multiple fixture finalizers raise, only first exception is reported\nAs mentioned in the XXX comment here:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/6ed005161d329cc079e6439a17e7ac935c7c02e0/src/_pytest/fixtures.py#L1019-L1032\r\n\r\nThis means information on the extra errors that occurred is not reported, which should never happen ideally.\r\n\r\nWe should instead raise an exception group in this case, like we do for nodes since pytest 7.3 (#10226).\n", "hints_text": "", "created_at": "2024-03-02T21:24:38Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12043, "instance_id": "pytest-dev__pytest-12043", "issue_numbers": ["11904", "11904"], "base_commit": "b6bf58abe8f02f9c0d30763fcb8ed346b5621e0b", "patch": "diff --git a/changelog/11904.bugfix.rst b/changelog/11904.bugfix.rst\nnew file mode 100644\nindex 00000000000..2aed9bcb059\n--- /dev/null\n+++ b/changelog/11904.bugfix.rst\n@@ -0,0 +1,3 @@\n+Fixed a regression in pytest 8.0.0 that would cause test collection to fail due to permission errors when using ``--pyargs``.\n+\n+This change improves the collection tree for tests specified using ``--pyargs``, see :pull:`12043` for a comparison with pytest 8.0 and <8.\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 639bf26c1cc..b7ed72ddc3b 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -5,6 +5,7 @@\n import fnmatch\n import functools\n import importlib\n+import importlib.util\n import os\n from pathlib import Path\n import sys\n@@ -563,7 +564,7 @@ def __init__(self, config: Config) -> None:\n         self._initialpaths: FrozenSet[Path] = frozenset()\n         self._initialpaths_with_parents: FrozenSet[Path] = frozenset()\n         self._notfound: List[Tuple[str, Sequence[nodes.Collector]]] = []\n-        self._initial_parts: List[Tuple[Path, List[str]]] = []\n+        self._initial_parts: List[CollectionArgument] = []\n         self._collection_cache: Dict[nodes.Collector, CollectReport] = {}\n         self.items: List[nodes.Item] = []\n \n@@ -769,15 +770,15 @@ def perform_collect(\n             initialpaths: List[Path] = []\n             initialpaths_with_parents: List[Path] = []\n             for arg in args:\n-                fspath, parts = resolve_collection_argument(\n+                collection_argument = resolve_collection_argument(\n                     self.config.invocation_params.dir,\n                     arg,\n                     as_pypath=self.config.option.pyargs,\n                 )\n-                self._initial_parts.append((fspath, parts))\n-                initialpaths.append(fspath)\n-                initialpaths_with_parents.append(fspath)\n-                initialpaths_with_parents.extend(fspath.parents)\n+                self._initial_parts.append(collection_argument)\n+                initialpaths.append(collection_argument.path)\n+                initialpaths_with_parents.append(collection_argument.path)\n+                initialpaths_with_parents.extend(collection_argument.path.parents)\n             self._initialpaths = frozenset(initialpaths)\n             self._initialpaths_with_parents = frozenset(initialpaths_with_parents)\n \n@@ -839,21 +840,35 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n \n         pm = self.config.pluginmanager\n \n-        for argpath, names in self._initial_parts:\n-            self.trace(\"processing argument\", (argpath, names))\n+        for collection_argument in self._initial_parts:\n+            self.trace(\"processing argument\", collection_argument)\n             self.trace.root.indent += 1\n \n+            argpath = collection_argument.path\n+            names = collection_argument.parts\n+            module_name = collection_argument.module_name\n+\n             # resolve_collection_argument() ensures this.\n             if argpath.is_dir():\n                 assert not names, f\"invalid arg {(argpath, names)!r}\"\n \n-            # Match the argpath from the root, e.g.\n+            paths = [argpath]\n+            # Add relevant parents of the path, from the root, e.g.\n             #   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]\n-            paths = [*reversed(argpath.parents), argpath]\n-            # Paths outside of the confcutdir should not be considered, unless\n-            # it's the argpath itself.\n-            while len(paths) > 1 and not pm._is_in_confcutdir(paths[0]):\n-                paths = paths[1:]\n+            if module_name is None:\n+                # Paths outside of the confcutdir should not be considered.\n+                for path in argpath.parents:\n+                    if not pm._is_in_confcutdir(path):\n+                        break\n+                    paths.insert(0, path)\n+            else:\n+                # For --pyargs arguments, only consider paths matching the module\n+                # name. Paths beyond the package hierarchy are not included.\n+                module_name_parts = module_name.split(\".\")\n+                for i, path in enumerate(argpath.parents, 2):\n+                    if i > len(module_name_parts) or path.stem != module_name_parts[-i]:\n+                        break\n+                    paths.insert(0, path)\n \n             # Start going over the parts from the root, collecting each level\n             # and discarding all nodes which don't match the level's part.\n@@ -861,7 +876,7 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n             notfound_collectors = []\n             work: List[\n                 Tuple[Union[nodes.Collector, nodes.Item], List[Union[Path, str]]]\n-            ] = [(self, paths + names)]\n+            ] = [(self, [*paths, *names])]\n             while work:\n                 matchnode, matchparts = work.pop()\n \n@@ -953,26 +968,36 @@ def genitems(\n                 node.ihook.pytest_collectreport(report=rep)\n \n \n-def search_pypath(module_name: str) -> str:\n-    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n+def search_pypath(module_name: str) -> Optional[str]:\n+    \"\"\"Search sys.path for the given a dotted module name, and return its file\n+    system path if found.\"\"\"\n     try:\n         spec = importlib.util.find_spec(module_name)\n     # AttributeError: looks like package module, but actually filename\n     # ImportError: module does not exist\n     # ValueError: not a module name\n     except (AttributeError, ImportError, ValueError):\n-        return module_name\n+        return None\n     if spec is None or spec.origin is None or spec.origin == \"namespace\":\n-        return module_name\n+        return None\n     elif spec.submodule_search_locations:\n         return os.path.dirname(spec.origin)\n     else:\n         return spec.origin\n \n \n+@dataclasses.dataclass(frozen=True)\n+class CollectionArgument:\n+    \"\"\"A resolved collection argument.\"\"\"\n+\n+    path: Path\n+    parts: Sequence[str]\n+    module_name: Optional[str]\n+\n+\n def resolve_collection_argument(\n     invocation_path: Path, arg: str, *, as_pypath: bool = False\n-) -> Tuple[Path, List[str]]:\n+) -> CollectionArgument:\n     \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n \n     Command-line arguments can point to files and/or directories, and optionally contain\n@@ -980,9 +1005,13 @@ def resolve_collection_argument(\n \n         \"pkg/tests/test_foo.py::TestClass::test_foo\"\n \n-    This function ensures the path exists, and returns a tuple:\n+    This function ensures the path exists, and returns a resolved `CollectionArgument`:\n \n-        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n+        CollectionArgument(\n+            path=Path(\"/full/path/to/pkg/tests/test_foo.py\"),\n+            parts=[\"TestClass\", \"test_foo\"],\n+            module_name=None,\n+        )\n \n     When as_pypath is True, expects that the command-line argument actually contains\n     module paths instead of file-system paths:\n@@ -990,7 +1019,13 @@ def resolve_collection_argument(\n         \"pkg.tests.test_foo::TestClass::test_foo\"\n \n     In which case we search sys.path for a matching module, and then return the *path* to the\n-    found module.\n+    found module, which may look like this:\n+\n+        CollectionArgument(\n+            path=Path(\"/home/u/myvenv/lib/site-packages/pkg/tests/test_foo.py\"),\n+            parts=[\"TestClass\", \"test_foo\"],\n+            module_name=\"pkg.tests.test_foo\",\n+        )\n \n     If the path doesn't exist, raise UsageError.\n     If the path is a directory and selection parts are present, raise UsageError.\n@@ -999,8 +1034,12 @@ def resolve_collection_argument(\n     strpath, *parts = base.split(\"::\")\n     if parts:\n         parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n+    module_name = None\n     if as_pypath:\n-        strpath = search_pypath(strpath)\n+        pyarg_strpath = search_pypath(strpath)\n+        if pyarg_strpath is not None:\n+            module_name = strpath\n+            strpath = pyarg_strpath\n     fspath = invocation_path / strpath\n     fspath = absolutepath(fspath)\n     if not safe_exists(fspath):\n@@ -1017,4 +1056,8 @@ def resolve_collection_argument(\n             else \"directory argument cannot contain :: selection parts: {arg}\"\n         )\n         raise UsageError(msg.format(arg=arg))\n-    return fspath, parts\n+    return CollectionArgument(\n+        path=fspath,\n+        parts=parts,\n+        module_name=module_name,\n+    )\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex 0507400455c..fbc8543e9c4 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1787,3 +1787,48 @@ def test_collect_short_file_windows(pytester: Pytester) -> None:\n     test_file.write_text(\"def test(): pass\", encoding=\"UTF-8\")\n     result = pytester.runpytest(short_path)\n     assert result.parseoutcomes() == {\"passed\": 1}\n+\n+\n+def test_pyargs_collection_tree(pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n+    \"\"\"When using `--pyargs`, the collection tree of a pyargs collection\n+    argument should only include parents in the import path, not up to confcutdir.\n+\n+    Regression test for #11904.\n+    \"\"\"\n+    site_packages = pytester.path / \"venv/lib/site-packages\"\n+    site_packages.mkdir(parents=True)\n+    monkeypatch.syspath_prepend(site_packages)\n+    pytester.makepyfile(\n+        **{\n+            \"venv/lib/site-packages/pkg/__init__.py\": \"\",\n+            \"venv/lib/site-packages/pkg/sub/__init__.py\": \"\",\n+            \"venv/lib/site-packages/pkg/sub/test_it.py\": \"def test(): pass\",\n+        }\n+    )\n+\n+    result = pytester.runpytest(\"--pyargs\", \"--collect-only\", \"pkg.sub.test_it\")\n+    assert result.ret == ExitCode.OK\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"<Package venv/lib/site-packages/pkg>\",\n+            \"  <Package sub>\",\n+            \"    <Module test_it.py>\",\n+            \"      <Function test>\",\n+        ],\n+        consecutive=True,\n+    )\n+\n+    # Now with an unrelated rootdir with unrelated files.\n+    monkeypatch.chdir(tempfile.gettempdir())\n+\n+    result = pytester.runpytest(\"--pyargs\", \"--collect-only\", \"pkg.sub.test_it\")\n+    assert result.ret == ExitCode.OK\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"<Package *pkg>\",\n+            \"  <Package sub>\",\n+            \"    <Module test_it.py>\",\n+            \"      <Function test>\",\n+        ],\n+        consecutive=True,\n+    )\ndiff --git a/testing/test_main.py b/testing/test_main.py\nindex d92fa21d365..345aa1e62cf 100644\n--- a/testing/test_main.py\n+++ b/testing/test_main.py\n@@ -8,6 +8,7 @@\n \n from _pytest.config import ExitCode\n from _pytest.config import UsageError\n+from _pytest.main import CollectionArgument\n from _pytest.main import resolve_collection_argument\n from _pytest.main import validate_basetemp\n from _pytest.pytester import Pytester\n@@ -133,26 +134,43 @@ def invocation_path(self, pytester: Pytester) -> Path:\n \n     def test_file(self, invocation_path: Path) -> None:\n         \"\"\"File and parts.\"\"\"\n-        assert resolve_collection_argument(invocation_path, \"src/pkg/test.py\") == (\n-            invocation_path / \"src/pkg/test.py\",\n-            [],\n+        assert resolve_collection_argument(\n+            invocation_path, \"src/pkg/test.py\"\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[],\n+            module_name=None,\n         )\n-        assert resolve_collection_argument(invocation_path, \"src/pkg/test.py::\") == (\n-            invocation_path / \"src/pkg/test.py\",\n-            [\"\"],\n+        assert resolve_collection_argument(\n+            invocation_path, \"src/pkg/test.py::\"\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[\"\"],\n+            module_name=None,\n         )\n         assert resolve_collection_argument(\n             invocation_path, \"src/pkg/test.py::foo::bar\"\n-        ) == (invocation_path / \"src/pkg/test.py\", [\"foo\", \"bar\"])\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[\"foo\", \"bar\"],\n+            module_name=None,\n+        )\n         assert resolve_collection_argument(\n             invocation_path, \"src/pkg/test.py::foo::bar::\"\n-        ) == (invocation_path / \"src/pkg/test.py\", [\"foo\", \"bar\", \"\"])\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[\"foo\", \"bar\", \"\"],\n+            module_name=None,\n+        )\n \n     def test_dir(self, invocation_path: Path) -> None:\n         \"\"\"Directory and parts.\"\"\"\n-        assert resolve_collection_argument(invocation_path, \"src/pkg\") == (\n-            invocation_path / \"src/pkg\",\n-            [],\n+        assert resolve_collection_argument(\n+            invocation_path, \"src/pkg\"\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg\",\n+            parts=[],\n+            module_name=None,\n         )\n \n         with pytest.raises(\n@@ -169,13 +187,24 @@ def test_pypath(self, invocation_path: Path) -> None:\n         \"\"\"Dotted name and parts.\"\"\"\n         assert resolve_collection_argument(\n             invocation_path, \"pkg.test\", as_pypath=True\n-        ) == (invocation_path / \"src/pkg/test.py\", [])\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[],\n+            module_name=\"pkg.test\",\n+        )\n         assert resolve_collection_argument(\n             invocation_path, \"pkg.test::foo::bar\", as_pypath=True\n-        ) == (invocation_path / \"src/pkg/test.py\", [\"foo\", \"bar\"])\n-        assert resolve_collection_argument(invocation_path, \"pkg\", as_pypath=True) == (\n-            invocation_path / \"src/pkg\",\n-            [],\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[\"foo\", \"bar\"],\n+            module_name=\"pkg.test\",\n+        )\n+        assert resolve_collection_argument(\n+            invocation_path, \"pkg\", as_pypath=True\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg\",\n+            parts=[],\n+            module_name=\"pkg\",\n         )\n \n         with pytest.raises(\n@@ -186,10 +215,13 @@ def test_pypath(self, invocation_path: Path) -> None:\n             )\n \n     def test_parametrized_name_with_colons(self, invocation_path: Path) -> None:\n-        ret = resolve_collection_argument(\n+        assert resolve_collection_argument(\n             invocation_path, \"src/pkg/test.py::test[a::b]\"\n+        ) == CollectionArgument(\n+            path=invocation_path / \"src/pkg/test.py\",\n+            parts=[\"test[a::b]\"],\n+            module_name=None,\n         )\n-        assert ret == (invocation_path / \"src/pkg/test.py\", [\"test[a::b]\"])\n \n     def test_does_not_exist(self, invocation_path: Path) -> None:\n         \"\"\"Given a file/module that does not exist raises UsageError.\"\"\"\n@@ -209,9 +241,12 @@ def test_does_not_exist(self, invocation_path: Path) -> None:\n     def test_absolute_paths_are_resolved_correctly(self, invocation_path: Path) -> None:\n         \"\"\"Absolute paths resolve back to absolute paths.\"\"\"\n         full_path = str(invocation_path / \"src\")\n-        assert resolve_collection_argument(invocation_path, full_path) == (\n-            Path(os.path.abspath(\"src\")),\n-            [],\n+        assert resolve_collection_argument(\n+            invocation_path, full_path\n+        ) == CollectionArgument(\n+            path=Path(os.path.abspath(\"src\")),\n+            parts=[],\n+            module_name=None,\n         )\n \n         # ensure full paths given in the command-line without the drive letter resolve\n@@ -219,7 +254,11 @@ def test_absolute_paths_are_resolved_correctly(self, invocation_path: Path) -> N\n         drive, full_path_without_drive = os.path.splitdrive(full_path)\n         assert resolve_collection_argument(\n             invocation_path, full_path_without_drive\n-        ) == (Path(os.path.abspath(\"src\")), [])\n+        ) == CollectionArgument(\n+            path=Path(os.path.abspath(\"src\")),\n+            parts=[],\n+            module_name=None,\n+        )\n \n \n def test_module_full_path_without_drive(pytester: Pytester) -> None:\n", "problem_statement": "8.0.0 + pyargs + permissions causes failures\nExample of a successful test-install build on 7.4.4:\r\n\r\nhttps://github.com/pulkin/pyteleport/actions/runs/7603885071/job/20706143053\r\n\r\nOn 8.0.0 it starts looking into inaccessible folders and fails right away:\r\n\r\nhttps://github.com/pulkin/pyteleport/actions/runs/7733355863/job/21085241736\n8.0.0 + pyargs + permissions causes failures\nExample of a successful test-install build on 7.4.4:\r\n\r\nhttps://github.com/pulkin/pyteleport/actions/runs/7603885071/job/20706143053\r\n\r\nOn 8.0.0 it starts looking into inaccessible folders and fails right away:\r\n\r\nhttps://github.com/pulkin/pyteleport/actions/runs/7733355863/job/21085241736\n", "hints_text": "This has been reported a few times already. The previous cases were legitimately bad ideas, running tests from `/tmp`. But since it seems like a common issue, we probably should make it work.\r\n\r\nThe easiest thing is to simply ignore files/dirs which raise a permission error, however I don't like this because it may silently skip over files which are meant to be included and really have wrong perms.\r\n\r\nAnother easy option is to warn and ignore, but the people who report this probably don't want the noise.\r\n\r\nThe problem started happening in pytest 8 because of the `Session` collection changes. Previously `Session` would collect the initial files itself, and thus could filter out non-matching files early. Now `Session` only collects the initial `Directory`s and then does a \"matchnodes\" pass after the fact, which means some files now get `stat`'ed when they previously weren't.\r\n\r\nWith some effort we could probably go back to avoiding `stat`s on files that are going to get discarded anyway. However it is probably too big a change for 8.0.x so will only be fixed in a feature release.\nI am all ears if you come up with a solution to test an installed package in my case. I used `cd /` to distance from my `src` folder as far as it is possible before running `pytest`.\nI do recommend cd'ing into some empty directory your user owns, or at least `/var/empty` if you need something ready made.\nTo whomever interested, I did this\r\n\r\nhttps://github.com/pulkin/pyteleport/commit/8a5e87c3956114f26a417bbe48bd28910bd46e7c\r\n\r\nCreating an empty subfolder in the repo folder did not work because `pytest` can still find `setup.py` and use repo files. So you have to create an empty folder side-by-side and test from there.\nI too am experiencing similar issues, am curious about a way forward. Given my use case, I do not have the option of creating a directory and cd'ing into it given my working environment.\nThis is an issue for my org.\r\nWe deploy applications fully isolated, so they all ship with their own python deps, similar to venv.\r\nWe have a generic test tool that allows running pytest via `--pyargs`, however the collector now doesn't stay within the confines of the package and starts adding dirs starting from root which contains tons of files and folders that it isn't permissioned to look at.\r\n\r\nThe typical invocation would look something like:\r\n\r\n```\r\n/root/packages/libexec/mypackage/bin/python -m pytest --pyargs myorg.myteam.mypackage\r\n```\r\n\r\nWith v8, looking at pytest debug file, this starts traversing /root first, encountering all sorts of things. Instead, what we expect is that it will stay within the confines of where the module is installed, i.e.\r\n```\r\n/root/packages/libexec/mypackage/python/lib/python3.11/site-packages/myorg/myteam/mypackage\r\n```\r\n\r\nAs a workaround, I can simply run pytest on the folder `...myorg/myteam/mypackage` but this is far less elegant than `--pyargs` that should just resolve this.\nAnother possible workaround is specifying `--confcutdir` to the directory you want pytest to start to and below.\r\n\r\nBut I agree the current situation is not optimal.\nThis has been reported a few times already. The previous cases were legitimately bad ideas, running tests from `/tmp`. But since it seems like a common issue, we probably should make it work.\r\n\r\nThe easiest thing is to simply ignore files/dirs which raise a permission error, however I don't like this because it may silently skip over files which are meant to be included and really have wrong perms.\r\n\r\nAnother easy option is to warn and ignore, but the people who report this probably don't want the noise.\r\n\r\nThe problem started happening in pytest 8 because of the `Session` collection changes. Previously `Session` would collect the initial files itself, and thus could filter out non-matching files early. Now `Session` only collects the initial `Directory`s and then does a \"matchnodes\" pass after the fact, which means some files now get `stat`'ed when they previously weren't.\r\n\r\nWith some effort we could probably go back to avoiding `stat`s on files that are going to get discarded anyway. However it is probably too big a change for 8.0.x so will only be fixed in a feature release.\nI am all ears if you come up with a solution to test an installed package in my case. I used `cd /` to distance from my `src` folder as far as it is possible before running `pytest`.\nI do recommend cd'ing into some empty directory your user owns, or at least `/var/empty` if you need something ready made.\nTo whomever interested, I did this\r\n\r\nhttps://github.com/pulkin/pyteleport/commit/8a5e87c3956114f26a417bbe48bd28910bd46e7c\r\n\r\nCreating an empty subfolder in the repo folder did not work because `pytest` can still find `setup.py` and use repo files. So you have to create an empty folder side-by-side and test from there.\nI too am experiencing similar issues, am curious about a way forward. Given my use case, I do not have the option of creating a directory and cd'ing into it given my working environment.\nThis is an issue for my org.\r\nWe deploy applications fully isolated, so they all ship with their own python deps, similar to venv.\r\nWe have a generic test tool that allows running pytest via `--pyargs`, however the collector now doesn't stay within the confines of the package and starts adding dirs starting from root which contains tons of files and folders that it isn't permissioned to look at.\r\n\r\nThe typical invocation would look something like:\r\n\r\n```\r\n/root/packages/libexec/mypackage/bin/python -m pytest --pyargs myorg.myteam.mypackage\r\n```\r\n\r\nWith v8, looking at pytest debug file, this starts traversing /root first, encountering all sorts of things. Instead, what we expect is that it will stay within the confines of where the module is installed, i.e.\r\n```\r\n/root/packages/libexec/mypackage/python/lib/python3.11/site-packages/myorg/myteam/mypackage\r\n```\r\n\r\nAs a workaround, I can simply run pytest on the folder `...myorg/myteam/mypackage` but this is far less elegant than `--pyargs` that should just resolve this.\nAnother possible workaround is specifying `--confcutdir` to the directory you want pytest to start to and below.\r\n\r\nBut I agree the current situation is not optimal.", "created_at": "2024-03-01T13:15:25Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12027, "instance_id": "pytest-dev__pytest-12027", "issue_numbers": ["11850", "11934"], "base_commit": "b510adf9efcd21e7ff2ab8e93e925f3e8363bb7d", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex bb27dd1d7c2..f78c4b3f94b 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -128,6 +128,7 @@ Edison Gustavo Muenz\n Edoardo Batini\n Edson Tadeu M. Manoel\n Eduardo Schettino\n+Edward Haigh\n Eero Vaher\n Eli Boyarski\n Elizaveta Shashkova\ndiff --git a/changelog/11850.improvement.rst b/changelog/11850.improvement.rst\nnew file mode 100644\nindex 00000000000..87fc0953c19\n--- /dev/null\n+++ b/changelog/11850.improvement.rst\n@@ -0,0 +1,1 @@\n+Added support for :data:`sys.last_exc` for post-mortem debugging on Python>=3.12.\n", "test_patch": "diff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex 7ed8f09bdbe..b60af9dd3fb 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -164,6 +164,8 @@ def pytest_runtest_call(item: Item) -> None:\n         del sys.last_type\n         del sys.last_value\n         del sys.last_traceback\n+        if sys.version_info >= (3, 12, 0):\n+            del sys.last_exc  # type: ignore[attr-defined]\n     except AttributeError:\n         pass\n     try:\n@@ -172,6 +174,8 @@ def pytest_runtest_call(item: Item) -> None:\n         # Store trace info to allow postmortem debugging\n         sys.last_type = type(e)\n         sys.last_value = e\n+        if sys.version_info >= (3, 12, 0):\n+            sys.last_exc = e  # type: ignore[attr-defined]\n         assert e.__traceback__ is not None\n         # Skip *this* frame\n         sys.last_traceback = e.__traceback__.tb_next\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 322e6dc0462..8cc496f7064 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -926,6 +926,9 @@ def runtest(self):\n     # Check that exception info is stored on sys\n     assert sys.last_type is IndexError\n     assert isinstance(sys.last_value, IndexError)\n+    if sys.version_info >= (3, 12, 0):\n+        assert isinstance(sys.last_exc, IndexError)  # type: ignore[attr-defined]\n+\n     assert sys.last_value.args[0] == \"TEST\"\n     assert sys.last_traceback\n \n@@ -934,6 +937,8 @@ def runtest(self):\n     runner.pytest_runtest_call(ItemMightRaise())  # type: ignore[arg-type]\n     assert not hasattr(sys, \"last_type\")\n     assert not hasattr(sys, \"last_value\")\n+    if sys.version_info >= (3, 12, 0):\n+        assert not hasattr(sys, \"last_exc\")\n     assert not hasattr(sys, \"last_traceback\")\n \n \n", "problem_statement": "Set `sys.last_exc` in addition to `last_type`/`last_value`/`last_traceback` on Python>=3.12\nPython 3.12 added [`sys.last_exc`](https://docs.python.org/3/library/sys.html#sys.last_exc). We should set it [like we do the older variants](https://github.com/pytest-dev/pytest/blob/c3fc717ff74cb8be6fb04c630b28b720d6c041ad/src/_pytest/runner.py#L166-L181).\nIssue #11850 - Add sys.last_exc\nCloses #11850 \n", "hints_text": "\n", "created_at": "2024-02-23T14:02:24Z"}
{"repo": "pytest-dev/pytest", "pull_number": 12022, "instance_id": "pytest-dev__pytest-12022", "issue_numbers": ["12021"], "base_commit": "010ce2ab0f6d2e90f295d4e3f9e725d31dd5721d", "patch": "diff --git a/changelog/12021.bugfix.rst b/changelog/12021.bugfix.rst\nnew file mode 100644\nindex 00000000000..eb8771ad720\n--- /dev/null\n+++ b/changelog/12021.bugfix.rst\n@@ -0,0 +1,1 @@\n+Reverted a fix to `--maxfail` handling in pytest 8.0.0 because it caused a regression in pytest-xdist whereby session fixture teardowns may get executed multiple times when the max-fails is reached.\ndiff --git a/doc/en/changelog.rst b/doc/en/changelog.rst\nindex 6ed764207e6..88f67635565 100644\n--- a/doc/en/changelog.rst\n+++ b/doc/en/changelog.rst\n@@ -85,6 +85,8 @@ Bug Fixes\n \n - `#11706 <https://github.com/pytest-dev/pytest/issues/11706>`_: Fix reporting of teardown errors in higher-scoped fixtures when using `--maxfail` or `--stepwise`.\n \n+  NOTE: This change was reverted in pytest 8.0.2 to fix a `regression <https://github.com/pytest-dev/pytest-xdist/issues/1024>`_ it caused in pytest-xdist.\n+\n \n - `#11758 <https://github.com/pytest-dev/pytest/issues/11758>`_: Fixed ``IndexError: string index out of range`` crash in ``if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\"``.\n   This bug was introduced in pytest 8.0.0rc1.\n", "test_patch": "diff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex d25fdb73836..7ed8f09bdbe 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -132,10 +132,6 @@ def runtestprotocol(\n             show_test_item(item)\n         if not item.config.getoption(\"setuponly\", False):\n             reports.append(call_and_report(item, \"call\", log))\n-    # If the session is about to fail or stop, teardown everything - this is\n-    # necessary to correctly report fixture teardown errors (see #11706)\n-    if item.session.shouldfail or item.session.shouldstop:\n-        nextitem = None\n     reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n     # After all teardown hooks have been called\n     # want funcargs and request info to go away.\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex 6b2b3105b0c..322e6dc0462 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -1089,53 +1089,3 @@ def func() -> None:\n     with pytest.raises(TypeError) as excinfo:\n         OutcomeException(func)  # type: ignore\n     assert str(excinfo.value) == expected\n-\n-\n-def test_teardown_session_failed(pytester: Pytester) -> None:\n-    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n-    item after the test session bails early due to --maxfail.\n-\n-    Regression test for #11706.\n-    \"\"\"\n-    pytester.makepyfile(\n-        \"\"\"\n-        import pytest\n-\n-        @pytest.fixture(scope=\"module\")\n-        def baz():\n-            yield\n-            pytest.fail(\"This is a failing teardown\")\n-\n-        def test_foo(baz):\n-            pytest.fail(\"This is a failing test\")\n-\n-        def test_bar(): pass\n-        \"\"\"\n-    )\n-    result = pytester.runpytest(\"--maxfail=1\")\n-    result.assert_outcomes(failed=1, errors=1)\n-\n-\n-def test_teardown_session_stopped(pytester: Pytester) -> None:\n-    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n-    item after the test session bails early due to --stepwise.\n-\n-    Regression test for #11706.\n-    \"\"\"\n-    pytester.makepyfile(\n-        \"\"\"\n-        import pytest\n-\n-        @pytest.fixture(scope=\"module\")\n-        def baz():\n-            yield\n-            pytest.fail(\"This is a failing teardown\")\n-\n-        def test_foo(baz):\n-            pytest.fail(\"This is a failing test\")\n-\n-        def test_bar(): pass\n-        \"\"\"\n-    )\n-    result = pytester.runpytest(\"--stepwise\")\n-    result.assert_outcomes(failed=1, errors=1)\n", "problem_statement": "Pytest 8.0.0 `--maxfail` fix caused a regression in pytest-xdist\nSee https://github.com/pytest-dev/pytest-xdist/issues/1024. When using `--maxfail` and the max fails is reached in a certain worker, the worker executes session fixture teardown twice. A fix in pytest-xdist is not very simple from what I can tell.\n", "hints_text": "", "created_at": "2024-02-23T09:49:27Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11997, "instance_id": "pytest-dev__pytest-11997", "issue_numbers": ["11475", "11931"], "base_commit": "6ed005161d329cc079e6439a17e7ac935c7c02e0", "patch": "diff --git a/changelog/11475.feature.rst b/changelog/11475.feature.rst\nnew file mode 100644\nindex 00000000000..42550235d80\n--- /dev/null\n+++ b/changelog/11475.feature.rst\n@@ -0,0 +1,3 @@\n+Added the new :confval:`consider_namespace_packages` configuration option, defaulting to ``False``.\n+\n+If set to ``True``, pytest will attempt to identify modules that are part of `namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages>`__ when importing modules.\ndiff --git a/changelog/11475.improvement.rst b/changelog/11475.improvement.rst\nnew file mode 100644\nindex 00000000000..4f6a4bffaad\n--- /dev/null\n+++ b/changelog/11475.improvement.rst\n@@ -0,0 +1,3 @@\n+:ref:`--import-mode=importlib <import-mode-importlib>` now tries to import modules using the standard import mechanism (but still without changing :py:data:`sys.path`), falling back to importing modules directly only if that fails.\n+\n+This means that installed packages will be imported under their canonical name if possible first, for example ``app.core.models``, instead of having the module name always be derived from their path (for example ``.env310.lib.site_packages.app.core.models``).\ndiff --git a/doc/en/explanation/goodpractices.rst b/doc/en/explanation/goodpractices.rst\nindex efde420cd8f..1390ba4e8fe 100644\n--- a/doc/en/explanation/goodpractices.rst\n+++ b/doc/en/explanation/goodpractices.rst\n@@ -60,8 +60,10 @@ Within Python modules, ``pytest`` also discovers tests using the standard\n :ref:`unittest.TestCase <unittest.TestCase>` subclassing technique.\n \n \n-Choosing a test layout / import rules\n--------------------------------------\n+.. _`test layout`:\n+\n+Choosing a test layout\n+----------------------\n \n ``pytest`` supports two common test layouts:\n \ndiff --git a/doc/en/explanation/pythonpath.rst b/doc/en/explanation/pythonpath.rst\nindex 5b533f47fdc..33eba86b57a 100644\n--- a/doc/en/explanation/pythonpath.rst\n+++ b/doc/en/explanation/pythonpath.rst\n@@ -10,19 +10,27 @@ Import modes\n \n pytest as a testing framework needs to import test modules and ``conftest.py`` files for execution.\n \n-Importing files in Python (at least until recently) is a non-trivial processes, often requiring\n-changing :data:`sys.path`. Some aspects of the\n+Importing files in Python is a non-trivial processes, so aspects of the\n import process can be controlled through the ``--import-mode`` command-line flag, which can assume\n these values:\n \n+.. _`import-mode-prepend`:\n+\n * ``prepend`` (default): the directory path containing each module will be inserted into the *beginning*\n-  of :py:data:`sys.path` if not already there, and then imported with the :func:`importlib.import_module <importlib.import_module>` function.\n+  of :py:data:`sys.path` if not already there, and then imported with\n+  the :func:`importlib.import_module <importlib.import_module>` function.\n+\n+  It is highly recommended to arrange your test modules as packages by adding ``__init__.py`` files to your directories\n+  containing tests. This will make the tests part of a proper Python package, allowing pytest to resolve their full\n+  name (for example ``tests.core.test_core`` for ``test_core.py`` inside the ``tests.core`` package).\n \n-  This requires test module names to be unique when the test directory tree is not arranged in\n-  packages, because the modules will put in :py:data:`sys.modules` after importing.\n+  If the test directory tree is not arranged as packages, then each test file needs to have a unique name\n+  compared to the other test files, otherwise pytest will raise an error if it finds two tests with the same name.\n \n   This is the classic mechanism, dating back from the time Python 2 was still supported.\n \n+.. _`import-mode-append`:\n+\n * ``append``: the directory containing each module is appended to the end of :py:data:`sys.path` if not already\n   there, and imported with :func:`importlib.import_module <importlib.import_module>`.\n \n@@ -38,32 +46,78 @@ these values:\n   the tests will run against the installed version\n   of ``pkg_under_test`` when ``--import-mode=append`` is used whereas\n   with ``prepend`` they would pick up the local version. This kind of confusion is why\n-  we advocate for using :ref:`src <src-layout>` layouts.\n+  we advocate for using :ref:`src-layouts <src-layout>`.\n \n   Same as ``prepend``, requires test module names to be unique when the test directory tree is\n   not arranged in packages, because the modules will put in :py:data:`sys.modules` after importing.\n \n-* ``importlib``: new in pytest-6.0, this mode uses more fine control mechanisms provided by :mod:`importlib` to import test modules. This gives full control over the import process, and doesn't require changing :py:data:`sys.path`.\n+.. _`import-mode-importlib`:\n+\n+* ``importlib``: this mode uses more fine control mechanisms provided by :mod:`importlib` to import test modules, without changing :py:data:`sys.path`.\n+\n+  Advantages of this mode:\n+\n+  * pytest will not change :py:data:`sys.path` at all.\n+  * Test module names do not need to be unique -- pytest will generate a unique name automatically based on the ``rootdir``.\n+\n+  Disadvantages:\n+\n+  * Test modules can't import each other.\n+  * Testing utility modules in the tests directories (for example a ``tests.helpers`` module containing test-related functions/classes)\n+    are not importable. The recommendation in this case it to place testing utility modules together with the application/library\n+    code, for example ``app.testing.helpers``.\n+\n+    Important: by \"test utility modules\" we mean functions/classes which are imported by\n+    other tests directly; this does not include fixtures, which should be placed in ``conftest.py`` files, along\n+    with the test modules, and are discovered automatically by pytest.\n+\n+  It works like this:\n+\n+  1. Given a certain module path, for example ``tests/core/test_models.py``, derives a canonical name\n+     like ``tests.core.test_models`` and tries to import it.\n \n-  For this reason this doesn't require test module names to be unique.\n+     For non-test modules this will work if they are accessible via :py:data:`sys.path`, so\n+     for example ``.env/lib/site-packages/app/core.py`` will be importable as ``app.core``.\n+     This is happens when plugins import non-test modules (for example doctesting).\n \n-  One drawback however is that test modules are non-importable by each other. Also,  utility\n-  modules in the tests directories are not automatically importable because the tests directory is no longer\n-  added to :py:data:`sys.path`.\n+     If this step succeeds, the module is returned.\n \n-  Initially we intended to make ``importlib`` the default in future releases, however it is clear now that\n-  it has its own set of drawbacks so the default will remain ``prepend`` for the foreseeable future.\n+     For test modules, unless they are reachable from :py:data:`sys.path`, this step will fail.\n+\n+  2. If the previous step fails, we import the module directly using ``importlib`` facilities, which lets us import it without\n+     changing :py:data:`sys.path`.\n+\n+     Because Python requires the module to also be available in :py:data:`sys.modules`, pytest derives a unique name for it based\n+     on its relative location from the ``rootdir``, and adds the module to :py:data:`sys.modules`.\n+\n+     For example, ``tests/core/test_models.py`` will end up being imported as the module ``tests.core.test_models``.\n+\n+  .. versionadded:: 6.0\n+\n+.. note::\n+\n+    Initially we intended to make ``importlib`` the default in future releases, however it is clear now that\n+    it has its own set of drawbacks so the default will remain ``prepend`` for the foreseeable future.\n+\n+.. note::\n+\n+    By default, pytest will not attempt to resolve namespace packages automatically, but that can\n+    be changed via the :confval:`consider_namespace_packages` configuration variable.\n \n .. seealso::\n \n     The :confval:`pythonpath` configuration variable.\n \n+    The :confval:`consider_namespace_packages` configuration variable.\n+\n+    :ref:`test layout`.\n+\n \n ``prepend`` and ``append`` import modes scenarios\n -------------------------------------------------\n \n Here's a list of scenarios when using ``prepend`` or ``append`` import modes where pytest needs to\n-change ``sys.path`` in order to import test modules or ``conftest.py`` files, and the issues users\n+change :py:data:`sys.path` in order to import test modules or ``conftest.py`` files, and the issues users\n might encounter because of that.\n \n Test modules / ``conftest.py`` files inside packages\n@@ -92,7 +146,7 @@ pytest will find ``foo/bar/tests/test_foo.py`` and realize it is part of a packa\n there's an ``__init__.py`` file in the same folder. It will then search upwards until it can find the\n last folder which still contains an ``__init__.py`` file in order to find the package *root* (in\n this case ``foo/``). To load the module, it will insert ``root/``  to the front of\n-``sys.path`` (if not there already) in order to load\n+:py:data:`sys.path` (if not there already) in order to load\n ``test_foo.py`` as the *module* ``foo.bar.tests.test_foo``.\n \n The same logic applies to the ``conftest.py`` file: it will be imported as ``foo.conftest`` module.\n@@ -122,8 +176,8 @@ When executing:\n \n pytest will find ``foo/bar/tests/test_foo.py`` and realize it is NOT part of a package given that\n there's no ``__init__.py`` file in the same folder. It will then add ``root/foo/bar/tests`` to\n-``sys.path`` in order to import ``test_foo.py`` as the *module* ``test_foo``. The same is done\n-with the ``conftest.py`` file by adding ``root/foo`` to ``sys.path`` to import it as ``conftest``.\n+:py:data:`sys.path` in order to import ``test_foo.py`` as the *module* ``test_foo``. The same is done\n+with the ``conftest.py`` file by adding ``root/foo`` to :py:data:`sys.path` to import it as ``conftest``.\n \n For this reason this layout cannot have test modules with the same name, as they all will be\n imported in the global import namespace.\n@@ -136,7 +190,7 @@ Invoking ``pytest`` versus ``python -m pytest``\n -----------------------------------------------\n \n Running pytest with ``pytest [...]`` instead of ``python -m pytest [...]`` yields nearly\n-equivalent behaviour, except that the latter will add the current directory to ``sys.path``, which\n+equivalent behaviour, except that the latter will add the current directory to :py:data:`sys.path`, which\n is standard ``python`` behavior.\n \n See also :ref:`invoke-python`.\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex bba4a399c72..f84b7ea4847 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -1274,6 +1274,19 @@ passed multiple times. The expected format is ``name=value``. For example::\n    variables, that will be expanded. For more information about cache plugin\n    please refer to :ref:`cache_provider`.\n \n+.. confval:: consider_namespace_packages\n+\n+   Controls if pytest should attempt to identify `namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages>`__\n+   when collecting Python modules. Default is ``False``.\n+\n+   Set to ``True`` if you are testing namespace packages installed into a virtual environment and it is important for\n+   your packages to be imported using their full namespace package name.\n+\n+   Only `native namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#native-namespace-packages>`__\n+   are supported, with no plans to support `legacy namespace packages <https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#legacy-namespace-packages>`__.\n+\n+   .. versionadded:: 8.1\n+\n .. confval:: console_output_style\n \n    Sets the console output style while running tests:\n", "test_patch": "diff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex 069e2196d25..7ed79483c4e 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -547,6 +547,8 @@ def _set_initial_conftests(\n         confcutdir: Optional[Path],\n         invocation_dir: Path,\n         importmode: Union[ImportMode, str],\n+        *,\n+        consider_namespace_packages: bool,\n     ) -> None:\n         \"\"\"Load initial conftest files given a preparsed \"namespace\".\n \n@@ -572,10 +574,20 @@ def _set_initial_conftests(\n             # Ensure we do not break if what appears to be an anchor\n             # is in fact a very long option (#10169, #11394).\n             if safe_exists(anchor):\n-                self._try_load_conftest(anchor, importmode, rootpath)\n+                self._try_load_conftest(\n+                    anchor,\n+                    importmode,\n+                    rootpath,\n+                    consider_namespace_packages=consider_namespace_packages,\n+                )\n                 foundanchor = True\n         if not foundanchor:\n-            self._try_load_conftest(invocation_dir, importmode, rootpath)\n+            self._try_load_conftest(\n+                invocation_dir,\n+                importmode,\n+                rootpath,\n+                consider_namespace_packages=consider_namespace_packages,\n+            )\n \n     def _is_in_confcutdir(self, path: Path) -> bool:\n         \"\"\"Whether to consider the given path to load conftests from.\"\"\"\n@@ -593,17 +605,37 @@ def _is_in_confcutdir(self, path: Path) -> bool:\n         return path not in self._confcutdir.parents\n \n     def _try_load_conftest(\n-        self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path\n+        self,\n+        anchor: Path,\n+        importmode: Union[str, ImportMode],\n+        rootpath: Path,\n+        *,\n+        consider_namespace_packages: bool,\n     ) -> None:\n-        self._loadconftestmodules(anchor, importmode, rootpath)\n+        self._loadconftestmodules(\n+            anchor,\n+            importmode,\n+            rootpath,\n+            consider_namespace_packages=consider_namespace_packages,\n+        )\n         # let's also consider test* subdirs\n         if anchor.is_dir():\n             for x in anchor.glob(\"test*\"):\n                 if x.is_dir():\n-                    self._loadconftestmodules(x, importmode, rootpath)\n+                    self._loadconftestmodules(\n+                        x,\n+                        importmode,\n+                        rootpath,\n+                        consider_namespace_packages=consider_namespace_packages,\n+                    )\n \n     def _loadconftestmodules(\n-        self, path: Path, importmode: Union[str, ImportMode], rootpath: Path\n+        self,\n+        path: Path,\n+        importmode: Union[str, ImportMode],\n+        rootpath: Path,\n+        *,\n+        consider_namespace_packages: bool,\n     ) -> None:\n         if self._noconftest:\n             return\n@@ -620,7 +652,12 @@ def _loadconftestmodules(\n             if self._is_in_confcutdir(parent):\n                 conftestpath = parent / \"conftest.py\"\n                 if conftestpath.is_file():\n-                    mod = self._importconftest(conftestpath, importmode, rootpath)\n+                    mod = self._importconftest(\n+                        conftestpath,\n+                        importmode,\n+                        rootpath,\n+                        consider_namespace_packages=consider_namespace_packages,\n+                    )\n                     clist.append(mod)\n         self._dirpath2confmods[directory] = clist\n \n@@ -642,7 +679,12 @@ def _rget_with_confmod(\n         raise KeyError(name)\n \n     def _importconftest(\n-        self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path\n+        self,\n+        conftestpath: Path,\n+        importmode: Union[str, ImportMode],\n+        rootpath: Path,\n+        *,\n+        consider_namespace_packages: bool,\n     ) -> types.ModuleType:\n         conftestpath_plugin_name = str(conftestpath)\n         existing = self.get_plugin(conftestpath_plugin_name)\n@@ -661,7 +703,12 @@ def _importconftest(\n                 pass\n \n         try:\n-            mod = import_path(conftestpath, mode=importmode, root=rootpath)\n+            mod = import_path(\n+                conftestpath,\n+                mode=importmode,\n+                root=rootpath,\n+                consider_namespace_packages=consider_namespace_packages,\n+            )\n         except Exception as e:\n             assert e.__traceback__ is not None\n             raise ConftestImportFailure(conftestpath, cause=e) from e\n@@ -1177,6 +1224,9 @@ def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n             confcutdir=early_config.known_args_namespace.confcutdir,\n             invocation_dir=early_config.invocation_params.dir,\n             importmode=early_config.known_args_namespace.importmode,\n+            consider_namespace_packages=early_config.getini(\n+                \"consider_namespace_packages\"\n+            ),\n         )\n \n     def _initini(self, args: Sequence[str]) -> None:\ndiff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex b7ed72ddc3b..8e8d238acbb 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -222,6 +222,12 @@ def pytest_addoption(parser: Parser) -> None:\n         help=\"Prepend/append to sys.path when importing test modules and conftest \"\n         \"files. Default: prepend.\",\n     )\n+    parser.addini(\n+        \"consider_namespace_packages\",\n+        type=\"bool\",\n+        default=False,\n+        help=\"Consider namespace packages when resolving module names during import\",\n+    )\n \n     group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n     group.addoption(\ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex 1e0891153e5..a19e89aa116 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -484,73 +484,86 @@ class ImportPathMismatchError(ImportError):\n \n \n def import_path(\n-    p: Union[str, \"os.PathLike[str]\"],\n+    path: Union[str, \"os.PathLike[str]\"],\n     *,\n     mode: Union[str, ImportMode] = ImportMode.prepend,\n     root: Path,\n+    consider_namespace_packages: bool,\n ) -> ModuleType:\n-    \"\"\"Import and return a module from the given path, which can be a file (a module) or\n+    \"\"\"\n+    Import and return a module from the given path, which can be a file (a module) or\n     a directory (a package).\n \n-    The import mechanism used is controlled by the `mode` parameter:\n+    :param path:\n+        Path to the file to import.\n \n-    * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\n-      `__init__.py` files into account) will be put at the *start* of `sys.path` before\n-      being imported with `importlib.import_module`.\n+    :param mode:\n+        Controls the underlying import mechanism that will be used:\n \n-    * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\n-      to the end of `sys.path`, if not already in `sys.path`.\n+        * ImportMode.prepend: the directory containing the module (or package, taking\n+          `__init__.py` files into account) will be put at the *start* of `sys.path` before\n+          being imported with `importlib.import_module`.\n \n-    * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\n-      to import the module, which avoids having to muck with `sys.path` at all. It effectively\n-      allows having same-named test modules in different places.\n+        * ImportMode.append: same as `prepend`, but the directory will be appended\n+          to the end of `sys.path`, if not already in `sys.path`.\n+\n+        * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`\n+          to import the module, which avoids having to muck with `sys.path` at all. It effectively\n+          allows having same-named test modules in different places.\n \n     :param root:\n         Used as an anchor when mode == ImportMode.importlib to obtain\n         a unique name for the module being imported so it can safely be stored\n         into ``sys.modules``.\n \n+    :param consider_namespace_packages:\n+        If True, consider namespace packages when resolving module names.\n+\n     :raises ImportPathMismatchError:\n         If after importing the given `path` and the module `__file__`\n         are different. Only raised in `prepend` and `append` modes.\n     \"\"\"\n+    path = Path(path)\n     mode = ImportMode(mode)\n \n-    path = Path(p)\n-\n     if not path.exists():\n         raise ImportError(path)\n \n     if mode is ImportMode.importlib:\n+        # Try to import this module using the standard import mechanisms, but\n+        # without touching sys.path.\n+        try:\n+            pkg_root, module_name = resolve_pkg_root_and_module_name(\n+                path, consider_namespace_packages=consider_namespace_packages\n+            )\n+        except CouldNotResolvePathError:\n+            pass\n+        else:\n+            mod = _import_module_using_spec(\n+                module_name, path, pkg_root, insert_modules=False\n+            )\n+            if mod is not None:\n+                return mod\n+\n+        # Could not import the module with the current sys.path, so we fall back\n+        # to importing the file as a single module, not being a part of a package.\n         module_name = module_name_from_path(path, root)\n         with contextlib.suppress(KeyError):\n             return sys.modules[module_name]\n \n-        for meta_importer in sys.meta_path:\n-            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n-            if spec is not None:\n-                break\n-        else:\n-            spec = importlib.util.spec_from_file_location(module_name, str(path))\n-\n-        if spec is None:\n+        mod = _import_module_using_spec(\n+            module_name, path, path.parent, insert_modules=True\n+        )\n+        if mod is None:\n             raise ImportError(f\"Can't find module {module_name} at location {path}\")\n-        mod = importlib.util.module_from_spec(spec)\n-        sys.modules[module_name] = mod\n-        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n-        insert_missing_modules(sys.modules, module_name)\n         return mod\n \n-    pkg_path = resolve_package_path(path)\n-    if pkg_path is not None:\n-        pkg_root = pkg_path.parent\n-        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n-        if names[-1] == \"__init__\":\n-            names.pop()\n-        module_name = \".\".join(names)\n-    else:\n-        pkg_root = path.parent\n-        module_name = path.stem\n+    try:\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            path, consider_namespace_packages=consider_namespace_packages\n+        )\n+    except CouldNotResolvePathError:\n+        pkg_root, module_name = path.parent, path.stem\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -592,6 +605,40 @@ def import_path(\n     return mod\n \n \n+def _import_module_using_spec(\n+    module_name: str, module_path: Path, module_location: Path, *, insert_modules: bool\n+) -> Optional[ModuleType]:\n+    \"\"\"\n+    Tries to import a module by its canonical name, path to the .py file, and its\n+    parent location.\n+\n+    :param insert_modules:\n+        If True, will call insert_missing_modules to create empty intermediate modules\n+        for made-up module names (when importing test files not reachable from sys.path).\n+        Note: we can probably drop insert_missing_modules altogether: instead of\n+        generating module names such as \"src.tests.test_foo\", which require intermediate\n+        empty modules, we might just as well generate unique module names like\n+        \"src_tests_test_foo\".\n+    \"\"\"\n+    # Checking with sys.meta_path first in case one of its hooks can import this module,\n+    # such as our own assertion-rewrite hook.\n+    for meta_importer in sys.meta_path:\n+        spec = meta_importer.find_spec(module_name, [str(module_location)])\n+        if spec is not None:\n+            break\n+    else:\n+        spec = importlib.util.spec_from_file_location(module_name, str(module_path))\n+    if spec is not None:\n+        mod = importlib.util.module_from_spec(spec)\n+        sys.modules[module_name] = mod\n+        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n+        if insert_modules:\n+            insert_missing_modules(sys.modules, module_name)\n+        return mod\n+\n+    return None\n+\n+\n # Implement a special _is_same function on Windows which returns True if the two filenames\n # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).\n if sys.platform.startswith(\"win\"):\n@@ -628,6 +675,11 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     if len(path_parts) >= 2 and path_parts[-1] == \"__init__\":\n         path_parts = path_parts[:-1]\n \n+    # Module names cannot contain \".\", normalize them to \"_\". This prevents\n+    # a directory having a \".\" in the name (\".env.310\" for example) causing extra intermediate modules.\n+    # Also, important to replace \".\" at the start of paths, as those are considered relative imports.\n+    path_parts = tuple(x.replace(\".\", \"_\") for x in path_parts)\n+\n     return \".\".join(path_parts)\n \n \n@@ -689,6 +741,60 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def resolve_pkg_root_and_module_name(\n+    path: Path, *, consider_namespace_packages: bool = False\n+) -> Tuple[Path, str]:\n+    \"\"\"\n+    Return the path to the directory of the root package that contains the\n+    given Python file, and its module name:\n+\n+        src/\n+            app/\n+                __init__.py\n+                core/\n+                    __init__.py\n+                    models.py\n+\n+    Passing the full path to `models.py` will yield Path(\"src\") and \"app.core.models\".\n+\n+    If consider_namespace_packages is True, then we additionally check upwards in the hierarchy\n+    until we find a directory that is reachable from sys.path, which marks it as a namespace package:\n+\n+    https://packaging.python.org/en/latest/guides/packaging-namespace-packages\n+\n+    Raises CouldNotResolvePathError if the given path does not belong to a package (missing any __init__.py files).\n+    \"\"\"\n+    pkg_path = resolve_package_path(path)\n+    if pkg_path is not None:\n+        pkg_root = pkg_path.parent\n+        # https://packaging.python.org/en/latest/guides/packaging-namespace-packages/\n+        if consider_namespace_packages:\n+            # Go upwards in the hierarchy, if we find a parent path included\n+            # in sys.path, it means the package found by resolve_package_path()\n+            # actually belongs to a namespace package.\n+            for parent in pkg_root.parents:\n+                # If any of the parent paths has a __init__.py, it means it is not\n+                # a namespace package (see the docs linked above).\n+                if (parent / \"__init__.py\").is_file():\n+                    break\n+                if str(parent) in sys.path:\n+                    # Point the pkg_root to the root of the namespace package.\n+                    pkg_root = parent\n+                    break\n+\n+        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+        if names[-1] == \"__init__\":\n+            names.pop()\n+        module_name = \".\".join(names)\n+        return pkg_root, module_name\n+\n+    raise CouldNotResolvePathError(f\"Could not resolve for {path}\")\n+\n+\n+class CouldNotResolvePathError(Exception):\n+    \"\"\"Custom exception raised by resolve_pkg_root_and_module_name.\"\"\"\n+\n+\n def scandir(\n     path: Union[str, \"os.PathLike[str]\"],\n     sort_key: Callable[[\"os.DirEntry[str]\"], object] = lambda entry: entry.name,\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex ca64a877d42..e1730b1a7e0 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -516,7 +516,12 @@ def importtestmodule(\n     # We assume we are only called once per module.\n     importmode = config.getoption(\"--import-mode\")\n     try:\n-        mod = import_path(path, mode=importmode, root=config.rootpath)\n+        mod = import_path(\n+            path,\n+            mode=importmode,\n+            root=config.rootpath,\n+            consider_namespace_packages=config.getini(\"consider_namespace_packages\"),\n+        )\n     except SyntaxError as e:\n         raise nodes.Collector.CollectError(\n             ExceptionInfo.from_current().getrepr(style=\"short\")\ndiff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex b60af9dd3fb..16abb895d58 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -380,6 +380,9 @@ def collect() -> List[Union[Item, Collector]]:\n                 collector.path,\n                 collector.config.getoption(\"importmode\"),\n                 rootpath=collector.config.rootpath,\n+                consider_namespace_packages=collector.config.getini(\n+                    \"consider_namespace_packages\"\n+                ),\n             )\n \n         return list(collector.collect())\ndiff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex cce23bf87d4..49c5dd3715b 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -180,7 +180,7 @@ def test_traceback_cut(self) -> None:\n     def test_traceback_cut_excludepath(self, pytester: Pytester) -> None:\n         p = pytester.makepyfile(\"def f(): raise ValueError\")\n         with pytest.raises(ValueError) as excinfo:\n-            import_path(p, root=pytester.path).f()  # type: ignore[attr-defined]\n+            import_path(p, root=pytester.path, consider_namespace_packages=False).f()  # type: ignore[attr-defined]\n         basedir = Path(pytest.__file__).parent\n         newtraceback = excinfo.traceback.cut(excludepath=basedir)\n         for x in newtraceback:\n@@ -543,7 +543,9 @@ def importasmod(source):\n             tmp_path.joinpath(\"__init__.py\").touch()\n             modpath.write_text(source, encoding=\"utf-8\")\n             importlib.invalidate_caches()\n-            return import_path(modpath, root=tmp_path)\n+            return import_path(\n+                modpath, root=tmp_path, consider_namespace_packages=False\n+            )\n \n         return importasmod\n \ndiff --git a/testing/code/test_source.py b/testing/code/test_source.py\nindex 9d0565380e4..12ea27b3517 100644\n--- a/testing/code/test_source.py\n+++ b/testing/code/test_source.py\n@@ -296,7 +296,7 @@ def method(self):\n     )\n     path = tmp_path.joinpath(\"a.py\")\n     path.write_text(str(source), encoding=\"utf-8\")\n-    mod: Any = import_path(path, root=tmp_path)\n+    mod: Any = import_path(path, root=tmp_path, consider_namespace_packages=False)\n     s2 = Source(mod.A)\n     assert str(source).strip() == str(s2).strip()\n \ndiff --git a/testing/test_conftest.py b/testing/test_conftest.py\nindex bb74fa75d61..3116dfe2584 100644\n--- a/testing/test_conftest.py\n+++ b/testing/test_conftest.py\n@@ -38,6 +38,7 @@ def conftest_setinitial(\n         confcutdir=confcutdir,\n         invocation_dir=Path.cwd(),\n         importmode=\"prepend\",\n+        consider_namespace_packages=False,\n     )\n \n \n@@ -64,7 +65,9 @@ def basedir(\n     def test_basic_init(self, basedir: Path) -> None:\n         conftest = PytestPluginManager()\n         p = basedir / \"adir\"\n-        conftest._loadconftestmodules(p, importmode=\"prepend\", rootpath=basedir)\n+        conftest._loadconftestmodules(\n+            p, importmode=\"prepend\", rootpath=basedir, consider_namespace_packages=False\n+        )\n         assert conftest._rget_with_confmod(\"a\", p)[1] == 1\n \n     def test_immediate_initialiation_and_incremental_are_the_same(\n@@ -72,15 +75,26 @@ def test_immediate_initialiation_and_incremental_are_the_same(\n     ) -> None:\n         conftest = PytestPluginManager()\n         assert not len(conftest._dirpath2confmods)\n-        conftest._loadconftestmodules(basedir, importmode=\"prepend\", rootpath=basedir)\n+        conftest._loadconftestmodules(\n+            basedir,\n+            importmode=\"prepend\",\n+            rootpath=basedir,\n+            consider_namespace_packages=False,\n+        )\n         snap1 = len(conftest._dirpath2confmods)\n         assert snap1 == 1\n         conftest._loadconftestmodules(\n-            basedir / \"adir\", importmode=\"prepend\", rootpath=basedir\n+            basedir / \"adir\",\n+            importmode=\"prepend\",\n+            rootpath=basedir,\n+            consider_namespace_packages=False,\n         )\n         assert len(conftest._dirpath2confmods) == snap1 + 1\n         conftest._loadconftestmodules(\n-            basedir / \"b\", importmode=\"prepend\", rootpath=basedir\n+            basedir / \"b\",\n+            importmode=\"prepend\",\n+            rootpath=basedir,\n+            consider_namespace_packages=False,\n         )\n         assert len(conftest._dirpath2confmods) == snap1 + 2\n \n@@ -92,10 +106,18 @@ def test_value_access_not_existing(self, basedir: Path) -> None:\n     def test_value_access_by_path(self, basedir: Path) -> None:\n         conftest = ConftestWithSetinitial(basedir)\n         adir = basedir / \"adir\"\n-        conftest._loadconftestmodules(adir, importmode=\"prepend\", rootpath=basedir)\n+        conftest._loadconftestmodules(\n+            adir,\n+            importmode=\"prepend\",\n+            rootpath=basedir,\n+            consider_namespace_packages=False,\n+        )\n         assert conftest._rget_with_confmod(\"a\", adir)[1] == 1\n         conftest._loadconftestmodules(\n-            adir / \"b\", importmode=\"prepend\", rootpath=basedir\n+            adir / \"b\",\n+            importmode=\"prepend\",\n+            rootpath=basedir,\n+            consider_namespace_packages=False,\n         )\n         assert conftest._rget_with_confmod(\"a\", adir / \"b\")[1] == 1.5\n \n@@ -152,7 +174,12 @@ def test_conftest_global_import(pytester: Pytester) -> None:\n         import pytest\n         from _pytest.config import PytestPluginManager\n         conf = PytestPluginManager()\n-        mod = conf._importconftest(Path(\"conftest.py\"), importmode=\"prepend\", rootpath=Path.cwd())\n+        mod = conf._importconftest(\n+            Path(\"conftest.py\"),\n+            importmode=\"prepend\",\n+            rootpath=Path.cwd(),\n+            consider_namespace_packages=False,\n+        )\n         assert mod.x == 3\n         import conftest\n         assert conftest is mod, (conftest, mod)\n@@ -160,7 +187,12 @@ def test_conftest_global_import(pytester: Pytester) -> None:\n         sub.mkdir()\n         subconf = sub / \"conftest.py\"\n         subconf.write_text(\"y=4\", encoding=\"utf-8\")\n-        mod2 = conf._importconftest(subconf, importmode=\"prepend\", rootpath=Path.cwd())\n+        mod2 = conf._importconftest(\n+            subconf,\n+            importmode=\"prepend\",\n+            rootpath=Path.cwd(),\n+            consider_namespace_packages=False,\n+        )\n         assert mod != mod2\n         assert mod2.y == 4\n         import conftest\n@@ -176,17 +208,30 @@ def test_conftestcutdir(pytester: Pytester) -> None:\n     p = pytester.mkdir(\"x\")\n     conftest = PytestPluginManager()\n     conftest_setinitial(conftest, [pytester.path], confcutdir=p)\n-    conftest._loadconftestmodules(p, importmode=\"prepend\", rootpath=pytester.path)\n+    conftest._loadconftestmodules(\n+        p,\n+        importmode=\"prepend\",\n+        rootpath=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n     values = conftest._getconftestmodules(p)\n     assert len(values) == 0\n     conftest._loadconftestmodules(\n-        conf.parent, importmode=\"prepend\", rootpath=pytester.path\n+        conf.parent,\n+        importmode=\"prepend\",\n+        rootpath=pytester.path,\n+        consider_namespace_packages=False,\n     )\n     values = conftest._getconftestmodules(conf.parent)\n     assert len(values) == 0\n     assert not conftest.has_plugin(str(conf))\n     # but we can still import a conftest directly\n-    conftest._importconftest(conf, importmode=\"prepend\", rootpath=pytester.path)\n+    conftest._importconftest(\n+        conf,\n+        importmode=\"prepend\",\n+        rootpath=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n     values = conftest._getconftestmodules(conf.parent)\n     assert values[0].__file__ is not None\n     assert values[0].__file__.startswith(str(conf))\n@@ -405,13 +450,18 @@ def test_conftest_import_order(pytester: Pytester, monkeypatch: MonkeyPatch) ->\n     ct2 = sub / \"conftest.py\"\n     ct2.write_text(\"\", encoding=\"utf-8\")\n \n-    def impct(p, importmode, root):\n+    def impct(p, importmode, root, consider_namespace_packages):\n         return p\n \n     conftest = PytestPluginManager()\n     conftest._confcutdir = pytester.path\n     monkeypatch.setattr(conftest, \"_importconftest\", impct)\n-    conftest._loadconftestmodules(sub, importmode=\"prepend\", rootpath=pytester.path)\n+    conftest._loadconftestmodules(\n+        sub,\n+        importmode=\"prepend\",\n+        rootpath=pytester.path,\n+        consider_namespace_packages=False,\n+    )\n     mods = cast(List[Path], conftest._getconftestmodules(sub))\n     expected = [ct1, ct2]\n     assert mods == expected\ndiff --git a/testing/test_doctest.py b/testing/test_doctest.py\nindex 32897a916fe..58fce244f45 100644\n--- a/testing/test_doctest.py\n+++ b/testing/test_doctest.py\n@@ -117,12 +117,12 @@ def test_simple_doctestfile(self, pytester: Pytester):\n     def test_importmode(self, pytester: Pytester):\n         pytester.makepyfile(\n             **{\n-                \"namespacepkg/innerpkg/__init__.py\": \"\",\n-                \"namespacepkg/innerpkg/a.py\": \"\"\"\n+                \"src/namespacepkg/innerpkg/__init__.py\": \"\",\n+                \"src/namespacepkg/innerpkg/a.py\": \"\"\"\n                   def some_func():\n                     return 42\n                 \"\"\",\n-                \"namespacepkg/innerpkg/b.py\": \"\"\"\n+                \"src/namespacepkg/innerpkg/b.py\": \"\"\"\n                   from namespacepkg.innerpkg.a import some_func\n                   def my_func():\n                     '''\n@@ -133,6 +133,10 @@ def my_func():\n                 \"\"\",\n             }\n         )\n+        # For 'namespacepkg' to be considered a namespace package, its containing directory\n+        # needs to be reachable from sys.path:\n+        # https://packaging.python.org/en/latest/guides/packaging-namespace-packages\n+        pytester.syspathinsert(pytester.path / \"src\")\n         reprec = pytester.inline_run(\"--doctest-modules\", \"--import-mode=importlib\")\n         reprec.assertoutcome(passed=1)\n \ndiff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 075259009de..357860563a8 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -3,17 +3,20 @@\n import os.path\n from pathlib import Path\n import pickle\n+import shutil\n import sys\n from textwrap import dedent\n from types import ModuleType\n from typing import Any\n from typing import Generator\n from typing import Iterator\n+from typing import Tuple\n import unittest.mock\n \n from _pytest.monkeypatch import MonkeyPatch\n from _pytest.pathlib import bestrelpath\n from _pytest.pathlib import commonpath\n+from _pytest.pathlib import CouldNotResolvePathError\n from _pytest.pathlib import ensure_deletable\n from _pytest.pathlib import fnmatch_ex\n from _pytest.pathlib import get_extended_length_path_str\n@@ -25,6 +28,7 @@\n from _pytest.pathlib import maybe_delete_a_numbered_dir\n from _pytest.pathlib import module_name_from_path\n from _pytest.pathlib import resolve_package_path\n+from _pytest.pathlib import resolve_pkg_root_and_module_name\n from _pytest.pathlib import safe_exists\n from _pytest.pathlib import symlink_or_skip\n from _pytest.pathlib import visit\n@@ -33,6 +37,20 @@\n import pytest\n \n \n+@pytest.fixture(autouse=True)\n+def autouse_pytester(pytester: Pytester) -> None:\n+    \"\"\"\n+    Fixture to make pytester() being autouse for all tests in this module.\n+\n+    pytester makes sure to restore sys.path to its previous state, and many tests in this module\n+    import modules and change sys.path because of that, so common module names such as \"test\" or \"test.conftest\"\n+    end up leaking to tests in other modules.\n+\n+    Note: we might consider extracting the sys.path restoration aspect into its own fixture, and apply it\n+    to the entire test suite always.\n+    \"\"\"\n+\n+\n class TestFNMatcherPort:\n     \"\"\"Test our port of py.common.FNMatcher (fnmatch_ex).\"\"\"\n \n@@ -82,6 +100,15 @@ def test_not_matching(self, pattern: str, path: str) -> None:\n         assert not fnmatch_ex(pattern, path)\n \n \n+@pytest.fixture(params=[True, False])\n+def ns_param(request: pytest.FixtureRequest) -> bool:\n+    \"\"\"\n+    Simple parametrized fixture for tests which call import_path() with consider_namespace_packages\n+    using True and False.\n+    \"\"\"\n+    return bool(request.param)\n+\n+\n class TestImportPath:\n     \"\"\"\n \n@@ -152,87 +179,113 @@ def setuptestfs(self, path: Path) -> None:\n             encoding=\"utf-8\",\n         )\n \n-    def test_smoke_test(self, path1: Path) -> None:\n-        obj = import_path(path1 / \"execfile.py\", root=path1)\n+    def test_smoke_test(self, path1: Path, ns_param: bool) -> None:\n+        obj = import_path(\n+            path1 / \"execfile.py\", root=path1, consider_namespace_packages=ns_param\n+        )\n         assert obj.x == 42  # type: ignore[attr-defined]\n         assert obj.__name__ == \"execfile\"\n \n-    def test_import_path_missing_file(self, path1: Path) -> None:\n+    def test_import_path_missing_file(self, path1: Path, ns_param: bool) -> None:\n         with pytest.raises(ImportPathMismatchError):\n-            import_path(path1 / \"sampledir\", root=path1)\n+            import_path(\n+                path1 / \"sampledir\", root=path1, consider_namespace_packages=ns_param\n+            )\n \n     def test_renamed_dir_creates_mismatch(\n-        self, tmp_path: Path, monkeypatch: MonkeyPatch\n+        self, tmp_path: Path, monkeypatch: MonkeyPatch, ns_param: bool\n     ) -> None:\n         tmp_path.joinpath(\"a\").mkdir()\n         p = tmp_path.joinpath(\"a\", \"test_x123.py\")\n         p.touch()\n-        import_path(p, root=tmp_path)\n+        import_path(p, root=tmp_path, consider_namespace_packages=ns_param)\n         tmp_path.joinpath(\"a\").rename(tmp_path.joinpath(\"b\"))\n         with pytest.raises(ImportPathMismatchError):\n-            import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n+            import_path(\n+                tmp_path.joinpath(\"b\", \"test_x123.py\"),\n+                root=tmp_path,\n+                consider_namespace_packages=ns_param,\n+            )\n \n         # Errors can be ignored.\n         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"1\")\n-        import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n+        import_path(\n+            tmp_path.joinpath(\"b\", \"test_x123.py\"),\n+            root=tmp_path,\n+            consider_namespace_packages=ns_param,\n+        )\n \n         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.\n         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"0\")\n         with pytest.raises(ImportPathMismatchError):\n-            import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n+            import_path(\n+                tmp_path.joinpath(\"b\", \"test_x123.py\"),\n+                root=tmp_path,\n+                consider_namespace_packages=ns_param,\n+            )\n \n-    def test_messy_name(self, tmp_path: Path) -> None:\n+    def test_messy_name(self, tmp_path: Path, ns_param: bool) -> None:\n         # https://bitbucket.org/hpk42/py-trunk/issue/129\n         path = tmp_path / \"foo__init__.py\"\n         path.touch()\n-        module = import_path(path, root=tmp_path)\n+        module = import_path(path, root=tmp_path, consider_namespace_packages=ns_param)\n         assert module.__name__ == \"foo__init__\"\n \n-    def test_dir(self, tmp_path: Path) -> None:\n+    def test_dir(self, tmp_path: Path, ns_param: bool) -> None:\n         p = tmp_path / \"hello_123\"\n         p.mkdir()\n         p_init = p / \"__init__.py\"\n         p_init.touch()\n-        m = import_path(p, root=tmp_path)\n+        m = import_path(p, root=tmp_path, consider_namespace_packages=ns_param)\n         assert m.__name__ == \"hello_123\"\n-        m = import_path(p_init, root=tmp_path)\n+        m = import_path(p_init, root=tmp_path, consider_namespace_packages=ns_param)\n         assert m.__name__ == \"hello_123\"\n \n-    def test_a(self, path1: Path) -> None:\n+    def test_a(self, path1: Path, ns_param: bool) -> None:\n         otherdir = path1 / \"otherdir\"\n-        mod = import_path(otherdir / \"a.py\", root=path1)\n+        mod = import_path(\n+            otherdir / \"a.py\", root=path1, consider_namespace_packages=ns_param\n+        )\n         assert mod.result == \"got it\"  # type: ignore[attr-defined]\n         assert mod.__name__ == \"otherdir.a\"\n \n-    def test_b(self, path1: Path) -> None:\n+    def test_b(self, path1: Path, ns_param: bool) -> None:\n         otherdir = path1 / \"otherdir\"\n-        mod = import_path(otherdir / \"b.py\", root=path1)\n+        mod = import_path(\n+            otherdir / \"b.py\", root=path1, consider_namespace_packages=ns_param\n+        )\n         assert mod.stuff == \"got it\"  # type: ignore[attr-defined]\n         assert mod.__name__ == \"otherdir.b\"\n \n-    def test_c(self, path1: Path) -> None:\n+    def test_c(self, path1: Path, ns_param: bool) -> None:\n         otherdir = path1 / \"otherdir\"\n-        mod = import_path(otherdir / \"c.py\", root=path1)\n+        mod = import_path(\n+            otherdir / \"c.py\", root=path1, consider_namespace_packages=ns_param\n+        )\n         assert mod.value == \"got it\"  # type: ignore[attr-defined]\n \n-    def test_d(self, path1: Path) -> None:\n+    def test_d(self, path1: Path, ns_param: bool) -> None:\n         otherdir = path1 / \"otherdir\"\n-        mod = import_path(otherdir / \"d.py\", root=path1)\n+        mod = import_path(\n+            otherdir / \"d.py\", root=path1, consider_namespace_packages=ns_param\n+        )\n         assert mod.value2 == \"got it\"  # type: ignore[attr-defined]\n \n-    def test_import_after(self, tmp_path: Path) -> None:\n+    def test_import_after(self, tmp_path: Path, ns_param: bool) -> None:\n         tmp_path.joinpath(\"xxxpackage\").mkdir()\n         tmp_path.joinpath(\"xxxpackage\", \"__init__.py\").touch()\n         mod1path = tmp_path.joinpath(\"xxxpackage\", \"module1.py\")\n         mod1path.touch()\n-        mod1 = import_path(mod1path, root=tmp_path)\n+        mod1 = import_path(\n+            mod1path, root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         assert mod1.__name__ == \"xxxpackage.module1\"\n         from xxxpackage import module1\n \n         assert module1 is mod1\n \n     def test_check_filepath_consistency(\n-        self, monkeypatch: MonkeyPatch, tmp_path: Path\n+        self, monkeypatch: MonkeyPatch, tmp_path: Path, ns_param: bool\n     ) -> None:\n         name = \"pointsback123\"\n         p = tmp_path.joinpath(name + \".py\")\n@@ -244,7 +297,9 @@ def test_check_filepath_consistency(\n                 pseudopath.touch()\n                 mod.__file__ = str(pseudopath)\n                 mp.setitem(sys.modules, name, mod)\n-                newmod = import_path(p, root=tmp_path)\n+                newmod = import_path(\n+                    p, root=tmp_path, consider_namespace_packages=ns_param\n+                )\n                 assert mod == newmod\n         mod = ModuleType(name)\n         pseudopath = tmp_path.joinpath(name + \"123.py\")\n@@ -252,40 +307,32 @@ def test_check_filepath_consistency(\n         mod.__file__ = str(pseudopath)\n         monkeypatch.setitem(sys.modules, name, mod)\n         with pytest.raises(ImportPathMismatchError) as excinfo:\n-            import_path(p, root=tmp_path)\n+            import_path(p, root=tmp_path, consider_namespace_packages=ns_param)\n         modname, modfile, orig = excinfo.value.args\n         assert modname == name\n         assert modfile == str(pseudopath)\n         assert orig == p\n         assert issubclass(ImportPathMismatchError, ImportError)\n \n-    def test_issue131_on__init__(self, tmp_path: Path) -> None:\n-        # __init__.py files may be namespace packages, and thus the\n-        # __file__ of an imported module may not be ourselves\n-        # see issue\n-        tmp_path.joinpath(\"proja\").mkdir()\n-        p1 = tmp_path.joinpath(\"proja\", \"__init__.py\")\n-        p1.touch()\n-        tmp_path.joinpath(\"sub\", \"proja\").mkdir(parents=True)\n-        p2 = tmp_path.joinpath(\"sub\", \"proja\", \"__init__.py\")\n-        p2.touch()\n-        m1 = import_path(p1, root=tmp_path)\n-        m2 = import_path(p2, root=tmp_path)\n-        assert m1 == m2\n-\n-    def test_ensuresyspath_append(self, tmp_path: Path) -> None:\n+    def test_ensuresyspath_append(self, tmp_path: Path, ns_param: bool) -> None:\n         root1 = tmp_path / \"root1\"\n         root1.mkdir()\n         file1 = root1 / \"x123.py\"\n         file1.touch()\n         assert str(root1) not in sys.path\n-        import_path(file1, mode=\"append\", root=tmp_path)\n+        import_path(\n+            file1, mode=\"append\", root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         assert str(root1) == sys.path[-1]\n         assert str(root1) not in sys.path[:-1]\n \n-    def test_invalid_path(self, tmp_path: Path) -> None:\n+    def test_invalid_path(self, tmp_path: Path, ns_param: bool) -> None:\n         with pytest.raises(ImportError):\n-            import_path(tmp_path / \"invalid.py\", root=tmp_path)\n+            import_path(\n+                tmp_path / \"invalid.py\",\n+                root=tmp_path,\n+                consider_namespace_packages=ns_param,\n+            )\n \n     @pytest.fixture\n     def simple_module(\n@@ -300,10 +347,19 @@ def simple_module(\n         sys.modules.pop(module_name, None)\n \n     def test_importmode_importlib(\n-        self, simple_module: Path, tmp_path: Path, request: pytest.FixtureRequest\n+        self,\n+        simple_module: Path,\n+        tmp_path: Path,\n+        request: pytest.FixtureRequest,\n+        ns_param: bool,\n     ) -> None:\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n-        module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            simple_module,\n+            mode=\"importlib\",\n+            root=tmp_path,\n+            consider_namespace_packages=ns_param,\n+        )\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n         assert str(simple_module.parent) not in sys.path\n         assert module.__name__ in sys.modules\n@@ -312,19 +368,38 @@ def test_importmode_importlib(\n         assert \"_src.tests\" in sys.modules\n \n     def test_remembers_previous_imports(\n-        self, simple_module: Path, tmp_path: Path\n+        self, simple_module: Path, tmp_path: Path, ns_param: bool\n     ) -> None:\n         \"\"\"`importlib` mode called remembers previous module (#10341, #10811).\"\"\"\n-        module1 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n-        module2 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+        module1 = import_path(\n+            simple_module,\n+            mode=\"importlib\",\n+            root=tmp_path,\n+            consider_namespace_packages=ns_param,\n+        )\n+        module2 = import_path(\n+            simple_module,\n+            mode=\"importlib\",\n+            root=tmp_path,\n+            consider_namespace_packages=ns_param,\n+        )\n         assert module1 is module2\n \n     def test_no_meta_path_found(\n-        self, simple_module: Path, monkeypatch: MonkeyPatch, tmp_path: Path\n+        self,\n+        simple_module: Path,\n+        monkeypatch: MonkeyPatch,\n+        tmp_path: Path,\n+        ns_param: bool,\n     ) -> None:\n         \"\"\"Even without any meta_path should still import module.\"\"\"\n         monkeypatch.setattr(sys, \"meta_path\", [])\n-        module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            simple_module,\n+            mode=\"importlib\",\n+            root=tmp_path,\n+            consider_namespace_packages=ns_param,\n+        )\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n \n         # mode='importlib' fails if no spec is found to load the module\n@@ -337,7 +412,12 @@ def test_no_meta_path_found(\n             importlib.util, \"spec_from_file_location\", lambda *args: None\n         )\n         with pytest.raises(ImportError):\n-            import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+            import_path(\n+                simple_module,\n+                mode=\"importlib\",\n+                root=tmp_path,\n+                consider_namespace_packages=False,\n+            )\n \n \n def test_resolve_package_path(tmp_path: Path) -> None:\n@@ -473,12 +553,16 @@ def test_samefile_false_negatives(tmp_path: Path, monkeypatch: MonkeyPatch) -> N\n         # the paths too. Using a context to narrow the patch as much as possible given\n         # this is an important system function.\n         mp.setattr(os.path, \"samefile\", lambda x, y: False)\n-        module = import_path(module_path, root=tmp_path)\n+        module = import_path(\n+            module_path, root=tmp_path, consider_namespace_packages=False\n+        )\n     assert getattr(module, \"foo\")() == 42\n \n \n class TestImportLibMode:\n-    def test_importmode_importlib_with_dataclass(self, tmp_path: Path) -> None:\n+    def test_importmode_importlib_with_dataclass(\n+        self, tmp_path: Path, ns_param: bool\n+    ) -> None:\n         \"\"\"Ensure that importlib mode works with a module containing dataclasses (#7856).\"\"\"\n         fn = tmp_path.joinpath(\"_src/tests/test_dataclass.py\")\n         fn.parent.mkdir(parents=True)\n@@ -495,13 +579,17 @@ class Data:\n             encoding=\"utf-8\",\n         )\n \n-        module = import_path(fn, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            fn, mode=\"importlib\", root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         Data: Any = getattr(module, \"Data\")\n         data = Data(value=\"foo\")\n         assert data.value == \"foo\"\n         assert data.__module__ == \"_src.tests.test_dataclass\"\n \n-    def test_importmode_importlib_with_pickle(self, tmp_path: Path) -> None:\n+    def test_importmode_importlib_with_pickle(\n+        self, tmp_path: Path, ns_param: bool\n+    ) -> None:\n         \"\"\"Ensure that importlib mode works with pickle (#7859).\"\"\"\n         fn = tmp_path.joinpath(\"_src/tests/test_pickle.py\")\n         fn.parent.mkdir(parents=True)\n@@ -521,13 +609,15 @@ def round_trip():\n             encoding=\"utf-8\",\n         )\n \n-        module = import_path(fn, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            fn, mode=\"importlib\", root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         round_trip = getattr(module, \"round_trip\")\n         action = round_trip()\n         assert action() == 42\n \n     def test_importmode_importlib_with_pickle_separate_modules(\n-        self, tmp_path: Path\n+        self, tmp_path: Path, ns_param: bool\n     ) -> None:\n         \"\"\"\n         Ensure that importlib mode works can load pickles that look similar but are\n@@ -571,10 +661,14 @@ def round_trip(obj):\n             s = pickle.dumps(obj)\n             return pickle.loads(s)\n \n-        module = import_path(fn1, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            fn1, mode=\"importlib\", root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         Data1 = getattr(module, \"Data\")\n \n-        module = import_path(fn2, mode=\"importlib\", root=tmp_path)\n+        module = import_path(\n+            fn2, mode=\"importlib\", root=tmp_path, consider_namespace_packages=ns_param\n+        )\n         Data2 = getattr(module, \"Data\")\n \n         assert round_trip(Data1(20)) == Data1(20)\n@@ -598,6 +692,53 @@ def test_module_name_from_path(self, tmp_path: Path) -> None:\n         result = module_name_from_path(tmp_path / \"__init__.py\", tmp_path)\n         assert result == \"__init__\"\n \n+        # Modules which start with \".\" are considered relative and will not be imported\n+        # unless part of a package, so we replace it with a \"_\" when generating the fake module name.\n+        result = module_name_from_path(tmp_path / \".env/tests/test_foo.py\", tmp_path)\n+        assert result == \"_env.tests.test_foo\"\n+\n+        # We want to avoid generating extra intermediate modules if some directory just happens\n+        # to contain a \".\" in the name.\n+        result = module_name_from_path(\n+            tmp_path / \".env.310/tests/test_foo.py\", tmp_path\n+        )\n+        assert result == \"_env_310.tests.test_foo\"\n+\n+    def test_resolve_pkg_root_and_module_name(\n+        self, tmp_path: Path, monkeypatch: MonkeyPatch\n+    ) -> None:\n+        # Create a directory structure first without __init__.py files.\n+        (tmp_path / \"src/app/core\").mkdir(parents=True)\n+        models_py = tmp_path / \"src/app/core/models.py\"\n+        models_py.touch()\n+        with pytest.raises(CouldNotResolvePathError):\n+            _ = resolve_pkg_root_and_module_name(models_py)\n+\n+        # Create the __init__.py files, it should now resolve to a proper module name.\n+        (tmp_path / \"src/app/__init__.py\").touch()\n+        (tmp_path / \"src/app/core/__init__.py\").touch()\n+        assert resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        ) == (\n+            tmp_path / \"src\",\n+            \"app.core.models\",\n+        )\n+\n+        # If we add tmp_path to sys.path, src becomes a namespace package.\n+        monkeypatch.syspath_prepend(tmp_path)\n+        assert resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        ) == (\n+            tmp_path,\n+            \"src.app.core.models\",\n+        )\n+        assert resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=False\n+        ) == (\n+            tmp_path / \"src\",\n+            \"app.core.models\",\n+        )\n+\n     def test_insert_missing_modules(\n         self, monkeypatch: MonkeyPatch, tmp_path: Path\n     ) -> None:\n@@ -629,7 +770,9 @@ def test_parent_contains_child_module_attribute(\n         assert modules[\"xxx\"].tests is modules[\"xxx.tests\"]\n         assert modules[\"xxx.tests\"].foo is modules[\"xxx.tests.foo\"]\n \n-    def test_importlib_package(self, monkeypatch: MonkeyPatch, tmp_path: Path):\n+    def test_importlib_package(\n+        self, monkeypatch: MonkeyPatch, tmp_path: Path, ns_param: bool\n+    ):\n         \"\"\"\n         Importing a package using --importmode=importlib should not import the\n         package's __init__.py file more than once (#11306).\n@@ -666,7 +809,12 @@ def __init__(self) -> None:\n             encoding=\"ascii\",\n         )\n \n-        mod = import_path(init, root=tmp_path, mode=ImportMode.importlib)\n+        mod = import_path(\n+            init,\n+            root=tmp_path,\n+            mode=ImportMode.importlib,\n+            consider_namespace_packages=ns_param,\n+        )\n         assert len(mod.instance.INSTANCES) == 1\n \n     def test_importlib_root_is_package(self, pytester: Pytester) -> None:\n@@ -685,6 +833,203 @@ def test_my_test():\n         result = pytester.runpytest(\"--import-mode=importlib\")\n         result.stdout.fnmatch_lines(\"* 1 passed *\")\n \n+    def create_installed_doctests_and_tests_dir(\n+        self, path: Path, monkeypatch: MonkeyPatch\n+    ) -> Tuple[Path, Path, Path]:\n+        \"\"\"\n+        Create a directory structure where the application code is installed in a virtual environment,\n+        and the tests are in an outside \".tests\" directory.\n+\n+        Return the paths to the core module (installed in the virtualenv), and the test modules.\n+        \"\"\"\n+        app = path / \"src/app\"\n+        app.mkdir(parents=True)\n+        (app / \"__init__.py\").touch()\n+        core_py = app / \"core.py\"\n+        core_py.write_text(\n+            dedent(\n+                \"\"\"\n+                def foo():\n+                    '''\n+                    >>> 1 + 1\n+                    2\n+                    '''\n+                \"\"\"\n+            ),\n+            encoding=\"ascii\",\n+        )\n+\n+        # Install it into a site-packages directory, and add it to sys.path, mimicking what\n+        # happens when installing into a virtualenv.\n+        site_packages = path / \".env/lib/site-packages\"\n+        site_packages.mkdir(parents=True)\n+        shutil.copytree(app, site_packages / \"app\")\n+        assert (site_packages / \"app/core.py\").is_file()\n+\n+        monkeypatch.syspath_prepend(site_packages)\n+\n+        # Create the tests files, outside 'src' and the virtualenv.\n+        # We use the same test name on purpose, but in different directories, to ensure\n+        # this works as advertised.\n+        conftest_path1 = path / \".tests/a/conftest.py\"\n+        conftest_path1.parent.mkdir(parents=True)\n+        conftest_path1.write_text(\n+            dedent(\n+                \"\"\"\n+                import pytest\n+                @pytest.fixture\n+                def a_fix(): return \"a\"\n+                \"\"\"\n+            ),\n+            encoding=\"ascii\",\n+        )\n+        test_path1 = path / \".tests/a/test_core.py\"\n+        test_path1.write_text(\n+            dedent(\n+                \"\"\"\n+                import app.core\n+                def test(a_fix):\n+                    assert a_fix == \"a\"\n+                \"\"\",\n+            ),\n+            encoding=\"ascii\",\n+        )\n+\n+        conftest_path2 = path / \".tests/b/conftest.py\"\n+        conftest_path2.parent.mkdir(parents=True)\n+        conftest_path2.write_text(\n+            dedent(\n+                \"\"\"\n+                import pytest\n+                @pytest.fixture\n+                def b_fix(): return \"b\"\n+                \"\"\"\n+            ),\n+            encoding=\"ascii\",\n+        )\n+\n+        test_path2 = path / \".tests/b/test_core.py\"\n+        test_path2.write_text(\n+            dedent(\n+                \"\"\"\n+                import app.core\n+                def test(b_fix):\n+                    assert b_fix == \"b\"\n+                \"\"\",\n+            ),\n+            encoding=\"ascii\",\n+        )\n+        return (site_packages / \"app/core.py\"), test_path1, test_path2\n+\n+    def test_import_using_normal_mechanism_first(\n+        self, monkeypatch: MonkeyPatch, pytester: Pytester, ns_param: bool\n+    ) -> None:\n+        \"\"\"\n+        Test import_path imports from the canonical location when possible first, only\n+        falling back to its normal flow when the module being imported is not reachable via sys.path (#11475).\n+        \"\"\"\n+        core_py, test_path1, test_path2 = self.create_installed_doctests_and_tests_dir(\n+            pytester.path, monkeypatch\n+        )\n+\n+        # core_py is reached from sys.path, so should be imported normally.\n+        mod = import_path(\n+            core_py,\n+            mode=\"importlib\",\n+            root=pytester.path,\n+            consider_namespace_packages=ns_param,\n+        )\n+        assert mod.__name__ == \"app.core\"\n+        assert mod.__file__ and Path(mod.__file__) == core_py\n+\n+        # tests are not reachable from sys.path, so they are imported as a standalone modules.\n+        # Instead of '.tests.a.test_core', we import as \"_tests.a.test_core\" because\n+        # importlib considers module names starting with '.' to be local imports.\n+        mod = import_path(\n+            test_path1,\n+            mode=\"importlib\",\n+            root=pytester.path,\n+            consider_namespace_packages=ns_param,\n+        )\n+        assert mod.__name__ == \"_tests.a.test_core\"\n+        mod = import_path(\n+            test_path2,\n+            mode=\"importlib\",\n+            root=pytester.path,\n+            consider_namespace_packages=ns_param,\n+        )\n+        assert mod.__name__ == \"_tests.b.test_core\"\n+\n+    def test_import_using_normal_mechanism_first_integration(\n+        self, monkeypatch: MonkeyPatch, pytester: Pytester, ns_param: bool\n+    ) -> None:\n+        \"\"\"\n+        Same test as above, but verify the behavior calling pytest.\n+\n+        We should not make this call in the same test as above, as the modules have already\n+        been imported by separate import_path() calls.\n+        \"\"\"\n+        core_py, test_path1, test_path2 = self.create_installed_doctests_and_tests_dir(\n+            pytester.path, monkeypatch\n+        )\n+        result = pytester.runpytest(\n+            \"--import-mode=importlib\",\n+            \"-o\",\n+            f\"consider_namespace_packages={ns_param}\",\n+            \"--doctest-modules\",\n+            \"--pyargs\",\n+            \"app\",\n+            \"./.tests\",\n+        )\n+        result.stdout.fnmatch_lines(\n+            [\n+                f\"{core_py.relative_to(pytester.path)} . *\",\n+                f\"{test_path1.relative_to(pytester.path)} . *\",\n+                f\"{test_path2.relative_to(pytester.path)} . *\",\n+                \"* 3 passed*\",\n+            ]\n+        )\n+\n+    def test_import_path_imports_correct_file(\n+        self, pytester: Pytester, ns_param: bool\n+    ) -> None:\n+        \"\"\"\n+        Import the module by the given path, even if other module with the same name\n+        is reachable from sys.path.\n+        \"\"\"\n+        pytester.syspathinsert()\n+        # Create a 'x.py' module reachable from sys.path that raises AssertionError\n+        # if imported.\n+        x_at_root = pytester.path / \"x.py\"\n+        x_at_root.write_text(\"raise AssertionError('x at root')\", encoding=\"ascii\")\n+\n+        # Create another x.py module, but in some subdirectories to ensure it is not\n+        # accessible from sys.path.\n+        x_in_sub_folder = pytester.path / \"a/b/x.py\"\n+        x_in_sub_folder.parent.mkdir(parents=True)\n+        x_in_sub_folder.write_text(\"X = 'a/b/x'\", encoding=\"ascii\")\n+\n+        # Import our x.py module from the subdirectories.\n+        # The 'x.py' module from sys.path was not imported for sure because\n+        # otherwise we would get an AssertionError.\n+        mod = import_path(\n+            x_in_sub_folder,\n+            mode=ImportMode.importlib,\n+            root=pytester.path,\n+            consider_namespace_packages=ns_param,\n+        )\n+        assert mod.__file__ and Path(mod.__file__) == x_in_sub_folder\n+        assert mod.X == \"a/b/x\"\n+\n+        # Attempt to import root 'x.py'.\n+        with pytest.raises(AssertionError, match=\"x at root\"):\n+            _ = import_path(\n+                x_at_root,\n+                mode=ImportMode.importlib,\n+                root=pytester.path,\n+                consider_namespace_packages=ns_param,\n+            )\n+\n \n def test_safe_exists(tmp_path: Path) -> None:\n     d = tmp_path.joinpath(\"some_dir\")\n@@ -713,3 +1058,109 @@ def test_safe_exists(tmp_path: Path) -> None:\n         side_effect=ValueError(\"name too long\"),\n     ):\n         assert safe_exists(p) is False\n+\n+\n+class TestNamespacePackages:\n+    \"\"\"Test import_path support when importing from properly namespace packages.\"\"\"\n+\n+    def setup_directories(\n+        self, tmp_path: Path, monkeypatch: MonkeyPatch, pytester: Pytester\n+    ) -> Tuple[Path, Path]:\n+        # Set up a namespace package \"com.company\", containing\n+        # two subpackages, \"app\" and \"calc\".\n+        (tmp_path / \"src/dist1/com/company/app/core\").mkdir(parents=True)\n+        (tmp_path / \"src/dist1/com/company/app/__init__.py\").touch()\n+        (tmp_path / \"src/dist1/com/company/app/core/__init__.py\").touch()\n+        models_py = tmp_path / \"src/dist1/com/company/app/core/models.py\"\n+        models_py.touch()\n+\n+        (tmp_path / \"src/dist2/com/company/calc/algo\").mkdir(parents=True)\n+        (tmp_path / \"src/dist2/com/company/calc/__init__.py\").touch()\n+        (tmp_path / \"src/dist2/com/company/calc/algo/__init__.py\").touch()\n+        algorithms_py = tmp_path / \"src/dist2/com/company/calc/algo/algorithms.py\"\n+        algorithms_py.touch()\n+\n+        # Validate the namespace package by importing it in a Python subprocess.\n+        r = pytester.runpython_c(\n+            dedent(\n+                f\"\"\"\n+                import sys\n+                sys.path.append(r{str(tmp_path / \"src/dist1\")!r})\n+                sys.path.append(r{str(tmp_path / \"src/dist2\")!r})\n+                import com.company.app.core.models\n+                import com.company.calc.algo.algorithms\n+                \"\"\"\n+            )\n+        )\n+        assert r.ret == 0\n+\n+        monkeypatch.syspath_prepend(tmp_path / \"src/dist1\")\n+        monkeypatch.syspath_prepend(tmp_path / \"src/dist2\")\n+        return models_py, algorithms_py\n+\n+    @pytest.mark.parametrize(\"import_mode\", [\"prepend\", \"append\", \"importlib\"])\n+    def test_resolve_pkg_root_and_module_name_ns_multiple_levels(\n+        self,\n+        tmp_path: Path,\n+        monkeypatch: MonkeyPatch,\n+        pytester: Pytester,\n+        import_mode: str,\n+    ) -> None:\n+        models_py, algorithms_py = self.setup_directories(\n+            tmp_path, monkeypatch, pytester\n+        )\n+\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist1\",\n+            \"com.company.app.core.models\",\n+        )\n+\n+        mod = import_path(\n+            models_py, mode=import_mode, root=tmp_path, consider_namespace_packages=True\n+        )\n+        assert mod.__name__ == \"com.company.app.core.models\"\n+        assert mod.__file__ == str(models_py)\n+\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            algorithms_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist2\",\n+            \"com.company.calc.algo.algorithms\",\n+        )\n+\n+        mod = import_path(\n+            algorithms_py,\n+            mode=import_mode,\n+            root=tmp_path,\n+            consider_namespace_packages=True,\n+        )\n+        assert mod.__name__ == \"com.company.calc.algo.algorithms\"\n+        assert mod.__file__ == str(algorithms_py)\n+\n+    @pytest.mark.parametrize(\"import_mode\", [\"prepend\", \"append\", \"importlib\"])\n+    def test_incorrect_namespace_package(\n+        self,\n+        tmp_path: Path,\n+        monkeypatch: MonkeyPatch,\n+        pytester: Pytester,\n+        import_mode: str,\n+    ) -> None:\n+        models_py, algorithms_py = self.setup_directories(\n+            tmp_path, monkeypatch, pytester\n+        )\n+        # Namespace packages must not have an __init__.py at any of its\n+        # directories; if it does, we then fall back to importing just the\n+        # part of the package containing the __init__.py files.\n+        (tmp_path / \"src/dist1/com/__init__.py\").touch()\n+\n+        pkg_root, module_name = resolve_pkg_root_and_module_name(\n+            models_py, consider_namespace_packages=True\n+        )\n+        assert (pkg_root, module_name) == (\n+            tmp_path / \"src/dist1/com/company\",\n+            \"app.core.models\",\n+        )\ndiff --git a/testing/test_pluginmanager.py b/testing/test_pluginmanager.py\nindex f68f143f433..da43364f643 100644\n--- a/testing/test_pluginmanager.py\n+++ b/testing/test_pluginmanager.py\n@@ -46,7 +46,10 @@ def pytest_myhook(xyz):\n             kwargs=dict(pluginmanager=config.pluginmanager)\n         )\n         config.pluginmanager._importconftest(\n-            conf, importmode=\"prepend\", rootpath=pytester.path\n+            conf,\n+            importmode=\"prepend\",\n+            rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         # print(config.pluginmanager.get_plugins())\n         res = config.hook.pytest_myhook(xyz=10)\n@@ -75,7 +78,10 @@ def pytest_addoption(parser):\n         \"\"\"\n         )\n         config.pluginmanager._importconftest(\n-            p, importmode=\"prepend\", rootpath=pytester.path\n+            p,\n+            importmode=\"prepend\",\n+            rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         assert config.option.test123\n \n@@ -115,6 +121,7 @@ def test_conftestpath_case_sensitivity(self, pytester: Pytester) -> None:\n             conftest,\n             importmode=\"prepend\",\n             rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         plugin = config.pluginmanager.get_plugin(str(conftest))\n         assert plugin is mod\n@@ -123,6 +130,7 @@ def test_conftestpath_case_sensitivity(self, pytester: Pytester) -> None:\n             conftest_upper_case,\n             importmode=\"prepend\",\n             rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         plugin_uppercase = config.pluginmanager.get_plugin(str(conftest_upper_case))\n         assert plugin_uppercase is mod_uppercase\n@@ -174,12 +182,18 @@ def test_hook_proxy(self, pytester: Pytester) -> None:\n         conftest2 = pytester.path.joinpath(\"tests/subdir/conftest.py\")\n \n         config.pluginmanager._importconftest(\n-            conftest1, importmode=\"prepend\", rootpath=pytester.path\n+            conftest1,\n+            importmode=\"prepend\",\n+            rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         ihook_a = session.gethookproxy(pytester.path / \"tests\")\n         assert ihook_a is not None\n         config.pluginmanager._importconftest(\n-            conftest2, importmode=\"prepend\", rootpath=pytester.path\n+            conftest2,\n+            importmode=\"prepend\",\n+            rootpath=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         ihook_b = session.gethookproxy(pytester.path / \"tests\")\n         assert ihook_a is not ihook_b\n@@ -398,7 +412,9 @@ def test_consider_conftest_deps(\n         pytestpm: PytestPluginManager,\n     ) -> None:\n         mod = import_path(\n-            pytester.makepyfile(\"pytest_plugins='xyz'\"), root=pytester.path\n+            pytester.makepyfile(\"pytest_plugins='xyz'\"),\n+            root=pytester.path,\n+            consider_namespace_packages=False,\n         )\n         with pytest.raises(ImportError):\n             pytestpm.consider_conftest(mod, registration_name=\"unused\")\n", "problem_statement": "ModuleNotFoundError when using `--doctest-modules`, a `src/` layout, and `--import-mode=importlib` (and no editable mode install)\n## [reproducer](https://github.com/flying-sheep/pytest-doctest-import-mismatch)\r\n\r\nWe\u2019d like to run our tests on an installed package instead of the development version, as we delete some files in our build process. We therefore don\u2019t use editable installs.\r\n\r\nI think the problem is that there seems to be no way to configure the import root used with the importlib import mode. The project rootdir gets passed here instead of something user configurable:\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/c34eaaaa1c485e9c8c3d1fe7f05549b6436f49cc/src/_pytest/doctest.py#L545-L549\r\n\r\nWhich means that the following code will run `module_name = module_name_from_path('<rootdir>/src/anndata/_types.py', '<rootdir>')`, i.e. `module_name = 'src.anndata._types'` when it should be `'anndata._types'`\r\n\r\nhttps://github.com/pytest-dev/pytest/blob/9f3bdac1500143c51ab358d07eb58b4cfa6d3fdf/src/_pytest/pathlib.py#L524-L525\r\n\r\nWithout `src/` layout, this works accidentally, as the `module_name` happens to match the real module name, and the module only gets imported once.\r\n\r\nPytest 7.4.2\nUse shortest module name for importlib imports\n<!--\nThanks for submitting a PR, your contribution is really appreciated!\n\nHere is a quick checklist that should be present in PRs.\n\n- [x] Include documentation when adding new features.\n- [x] Include new tests or update existing tests when applicable.\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\n\nIf this change fixes an issue, please:\n\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\n\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\n\n- [ ] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\n\n  Write sentences in the **past or present tense**, examples:\n\n  * *Improved verbose diff output with sequences.*\n  * *Terminal summary statistics now use multiple colors.*\n\n  Also make sure to end the sentence with a `.`.\n\n- [ ] Add yourself to `AUTHORS` in alphabetical order.\n-->\n\n\nCloses #11475\n", "hints_text": "I just wanted to add that we are hitting this issue as well, but we _are_ using editable installs, so it looks like this issue affects both the case with editable and non-editable installs of the project source files.\r\n\r\nJust to be clear, our project is:\r\n\r\n- an editable installation\r\n- has a `src/` layout\r\n- puts non-doctest tests outside the application code, in a `tests/` directory that is a sibling to the `src/` directory\r\n- uses `--import-mode=importlib`\r\n- (attempts to) use `--doctest-modules`\r\n\r\nWe more or less exactly follow the suggested layout and settings in https://docs.pytest.org/en/7.1.x/explanation/goodpractices.html#tests-outside-application-code, and everything was working fine until attempting to run doctests within the application code using `--doctest-modules`.\nYeah, could this please be added to the 8.0 milestone?\r\n\r\nThis might require a new setting or some breaking change, so this is the ideal moment\nDoes it work better if you use `pytest --doctest-modules --import-mode=importlib --pyargs my.package`?\n~~Actually yes! It\u2019s getting really complicated though:~~\r\n\r\n```toml\r\n[tool.pytest.ini_options]\r\naddopts = [\r\n    \"--strict-markers\",\r\n    \"--doctest-modules\",\r\n    \"--pyargs\",\r\n]\r\ntestpaths = [\r\n    \"anndata\", # doctests in docstrings (module name due to --pyargs)\r\n    \"./src/anndata/tests\", # unit tests\r\n    \"./docs/concatenation.rst\", # further doctests\r\n]\r\n```\r\n\r\n~~and then in `src/anndata/tests/conftest.py` a `collect_ignore = [\"helpers.py\"]`. But it works.~~\nIn the issue subject you write `--import-mode=importlib` but you are *not* using that right?\r\n\r\nIf you give me a bit of instructions how to reproduce this locally, I can take a look.\nSorry, I muddled my project (https://github.com/scverse/anndata/pull/1151) too much with this issue. I\u2019m trying to be clear now.\r\n\r\nAdding `--import-mode=importlib` to the above results in this:\r\n\r\n```\r\nE   ModuleNotFoundError: No module named\r\n  'home.phil..local.share.hatch.[\u2026].site-packages.anndata._core';\r\n  'home.phil..local.share.hatch.[\u2026].site-packages.anndata' is not a package\r\n```\r\n\r\nWhat needs to work for this issue to be considered fixed:\r\n\r\n```\r\n+ src/my_module/__init__.py  # containing a doctest\r\n+ tests/test_basic.py\r\n```\r\n\r\n```toml\r\n[build-system]\r\nbuild-backend = \"hatchling.build\"\r\nrequires = [\"hatchling\", \"hatch-vcs\"]\r\n\r\n[project]\r\nname = \"my_module\"\r\nversion = \"0.1.0\"\r\n\r\n[tool.pytest.ini_options]\r\naddopts = [\r\n    \"--import-mode=importlib\",\r\n    \"--strict-markers\",\r\n    \"--doctest-modules\",\r\n    \"--pyargs\",\r\n]\r\ntestpaths = [\r\n    \"my_module\",  # or without `--pyargs`: \"./src/my_module\"\r\n    \"./tests\",\r\n]\r\n```\r\n\r\n<details><summary>What would be nice if it worked for migrating our project:</summary>\r\n\r\n```\r\n+ src/my_module/\r\n  + __init__.py  # containing a doctest\r\n  + tests/\r\n    + conftest.py  # containing `collect_ignore = [\"helpers.py\"]`\r\n    + helpers.py\r\n    + test_basic.py\r\n```\r\n\r\n```toml\r\n...\r\n\r\n[tool.pytest.ini_options]\r\naddopts = [\r\n    \"--import-mode=importlib\",\r\n    \"--strict-markers\",\r\n    \"--doctest-modules\",\r\n    \"--pyargs\",\r\n]\r\ntestpaths = [\r\n    \"my_module\",\r\n    \"./src/my_module/tests\",\r\n]\r\n```\r\n\r\n</details>\nVery weird, I just can\u2019t find a good reproducer. In our project, it fails: https://dev.azure.com/scverse/anndata/_build/results?buildId=5213&view=logs&jobId=5ea502cf-d418-510c-3b5f-c4ba606ae534&j=5ea502cf-d418-510c-3b5f-c4ba606ae534&t=5091afe0-1787-5ef7-c6a1-ce6dc06b30a7\r\n\r\n```\r\nplatform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0\r\nrootdir: /home/vsts/work/1/s\r\nconfigfile: pyproject.toml\r\ntestpaths: anndata, ./src/anndata/tests, ./docs/concatenation.rst\r\nplugins: xdist-3.5.0, memray-1.5.0, anyio-4.2.0, cov-4.1.0\r\ncollected 3028 items / 20 errors\r\n\r\n==================================== ERRORS ====================================\r\n__________________________ ERROR collecting utils.py ___________________________\r\n/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/anndata/utils.py:13: in <module>\r\n    from ._core.sparse_dataset import BaseCompressedSparseDataset\r\nE   ModuleNotFoundError: No module named 'opt.hostedtoolcache.Python.3.11.7.x64.lib.python3.11.site-packages.anndata._core'; 'opt.hostedtoolcache.Python.3.11.7.x64.lib.python3.11.site-packages.anndata' is not a package\r\n__________________ ERROR collecting _core/aligned_mapping.py ___________________\r\n/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/anndata/_core/aligned_mapping.py:23: in <module>\r\n    from ..utils import deprecated, dim_len, ensure_df_homogeneous, warn_once\r\nE   ImportError: cannot import name 'deprecated' from 'opt.hostedtoolcache.Python.3.11.7.x64.lib.python3.11.site-packages.anndata.utils' (/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/anndata/utils.py)\r\n...\r\n```\r\n\r\nbut using the \u201creproducer\u201d I so confidently outlined above, everything works.\nOK, I minified the repo somewhat. I assume the problem is that even with `--pyargs`, pytest tries to import the module with weird names while running doctest.\r\n\r\nhttps://github.com/flying-sheep/pytest-doctest-import-mismatch\r\n\r\nI see errors like this:\r\n\r\n```pytb\r\n____ ERROR collecting _core/merge.py ____\r\n/home/phil/.local/share/hatch/env/virtual/anndata/kX3YdB0h/anndata/lib/python3.11/site-packages/anndata/_core/merge.py:28: in <module>\r\n   from ..compat import _map_cat_to_str\r\nE   ModuleNotFoundError: No module named 'home.phil..local.share.hatch.env.virtual.anndata.kX3YdB0h.anndata.lib.python3.11.site-packages.anndata.compat'; 'home.phil..local.share.hatch.env.virtual.anndata.kX3YdB0h.anndata.lib.python3.11.site-packages.anndata' is not a package\r\n____ ERROR collecting _core/raw.py ____\r\n/home/phil/.local/share/hatch/env/virtual/anndata/kX3YdB0h/anndata/lib/python3.11/site-packages/anndata/_core/raw.py:9: in <module>\r\n   from .aligned_mapping import AxisArrays\r\nE   ImportError: cannot import name 'AxisArrays' from 'home.phil..local.share.hatch.env.virtual.anndata.kX3YdB0h.anndata.lib.python3.11.site-packages.anndata._core.aligned_mapping' (/home/phil/.local/share/hatch/env/virtual/anndata/kX3YdB0h/anndata/lib/python3.11/site-packages/anndata/_core/aligned_mapping.py)\r\n```\r\n\r\nThe reproducer is by no means minimal yet, and I can make it smaller for sure, but maybe it\u2019s helpful before i get to that already.\n(First, consider editing the original post to point to the reproduction; the `ImportPathMismatchError` error stated there *cannot* happen in `--import-mode=importlib` so it's quite confusing).\r\n\r\nThanks for creating a reproduction. I tried it now. I was able to reproduce with pytest 7.4, but with pytest main it works (only if using venv name `venv` instead of `.venv` -- see below). I bisected the fix to commit 194a782e3817ee9f4f77a7a61ec68d25b3b08250 which is also included in 8.0.0rc1.\r\n\r\nHowever, there's an issue I noticed: If the path contains dots, e.g. `.venv` and `python3.11` in this case, then `--import-mode=importlib` fails like this:\r\n\r\n<details><summary>Dot problem</summary>\r\n<p>\r\n\r\n```\r\n__________________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/__init__.py ___________________________________________________\r\n.venv/lib/python3.11/site-packages/anndata/__init__.py:11: in <module>\r\n    from ._core.anndata import AnnData\r\nE   ValueError: Empty module name\r\n________________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/_core/access.py _________________________________________________\r\n/usr/lib/python3.11/importlib/__init__.py:121: in import_module\r\n    raise TypeError(msg.format(name))\r\nE   TypeError: the 'package' argument is required to perform a relative import for '.venv.lib.python3.11.site-packages'\r\n____________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/_core/aligned_mapping.py ____________________________________________\r\n/usr/lib/python3.11/importlib/__init__.py:121: in import_module\r\n    raise TypeError(msg.format(name))\r\nE   TypeError: the 'package' argument is required to perform a relative import for '.venv.lib.python3.11.site-packages'\r\n________________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/_core/anndata.py ________________________________________________\r\n/usr/lib/python3.11/importlib/__init__.py:121: in import_module\r\n    raise TypeError(msg.format(name))\r\nE   TypeError: the 'package' argument is required to perform a relative import for '.venv.lib.python3.11.site-packages'\r\n_________________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/_core/merge.py _________________________________________________\r\n/usr/lib/python3.11/importlib/__init__.py:121: in import_module\r\n    raise TypeError(msg.format(name))\r\nE   TypeError: the 'package' argument is required to perform a relative import for '.venv.lib.python3.11.site-packages'\r\n_____________________________________________________ ERROR collecting .venv/lib/python3.11/site-packages/anndata/tests ______________________________________________________\r\n/usr/lib/python3.11/importlib/__init__.py:121: in import_module\r\n    raise TypeError(msg.format(name))\r\nE   TypeError: the 'package' argument is required to perform a relative import for '.venv.lib.python3.11.site-packages.anndata.tests'\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\n Python module names (individual components) cannot contain dots, and the `--import-mode=importlib` code does stuff like `module_name.split(\".\")`.\r\n\r\nI tried \"escaping\" the dots by replacing them with `_dot_`, which allows things to continue, however then it fails like this:\r\n\r\n<details><summary>Exec module problem</summary>\r\n<p>\r\n\r\n```\r\nself = <DoctestModule __init__.py>\r\n\r\n    def collect(self) -> Iterable[DoctestItem]:\r\n        import doctest\r\n    \r\n        class MockAwareDocTestFinder(doctest.DocTestFinder):\r\n            \"\"\"A hackish doctest finder that overrides stdlib internals to fix a stdlib bug.\r\n    \r\n            https://github.com/pytest-dev/pytest/issues/3456\r\n            https://bugs.python.org/issue25532\r\n            \"\"\"\r\n    \r\n            def _find_lineno(self, obj, source_lines):\r\n                \"\"\"Doctest code does not take into account `@property`, this\r\n                is a hackish way to fix it. https://bugs.python.org/issue17446\r\n    \r\n                Wrapped Doctests will need to be unwrapped so the correct\r\n                line number is returned. This will be reported upstream. #8796\r\n                \"\"\"\r\n                if isinstance(obj, property):\r\n                    obj = getattr(obj, \"fget\", obj)\r\n    \r\n                if hasattr(obj, \"__wrapped__\"):\r\n                    # Get the main obj in case of it being wrapped\r\n                    obj = inspect.unwrap(obj)\r\n    \r\n                # Type ignored because this is a private function.\r\n                return super()._find_lineno(  # type:ignore[misc]\r\n                    obj,\r\n                    source_lines,\r\n                )\r\n    \r\n            def _find(\r\n                self, tests, obj, name, module, source_lines, globs, seen\r\n            ) -> None:\r\n                if _is_mocked(obj):\r\n                    return\r\n                with _patch_unwrap_mock_aware():\r\n                    # Type ignored because this is a private function.\r\n                    super()._find(  # type:ignore[misc]\r\n                        tests, obj, name, module, source_lines, globs, seen\r\n                    )\r\n    \r\n            if sys.version_info < (3, 13):\r\n    \r\n                def _from_module(self, module, object):\r\n                    \"\"\"`cached_property` objects are never considered a part\r\n                    of the 'current module'. As such they are skipped by doctest.\r\n                    Here we override `_from_module` to check the underlying\r\n                    function instead. https://github.com/python/cpython/issues/107995\r\n                    \"\"\"\r\n                    if isinstance(object, functools.cached_property):\r\n                        object = object.func\r\n    \r\n                    # Type ignored because this is a private function.\r\n                    return super()._from_module(module, object)  # type: ignore[misc]\r\n    \r\n            else:  # pragma: no cover\r\n                pass\r\n    \r\n        if self.path.name == \"conftest.py\":\r\n            module = self.config.pluginmanager._importconftest(\r\n                self.path,\r\n                self.config.getoption(\"importmode\"),\r\n                rootpath=self.config.rootpath,\r\n            )\r\n        else:\r\n            try:\r\n>               module = import_path(\r\n                    self.path,\r\n                    root=self.config.rootpath,\r\n                    mode=self.config.getoption(\"importmode\"),\r\n                )\r\n\r\n../../src/pytest/src/_pytest/doctest.py:569: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\np = PosixPath('/home/ran/tmp/pytest-doctest-import-mismatch/.venv/lib/python3.11/site-packages/anndata/__init__.py')\r\n\r\n    def import_path(\r\n        p: Union[str, \"os.PathLike[str]\"],\r\n        *,\r\n        mode: Union[str, ImportMode] = ImportMode.prepend,\r\n        root: Path,\r\n    ) -> ModuleType:\r\n        \"\"\"Import and return a module from the given path, which can be a file (a module) or\r\n        a directory (a package).\r\n    \r\n        The import mechanism used is controlled by the `mode` parameter:\r\n    \r\n        * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\r\n          `__init__.py` files into account) will be put at the *start* of `sys.path` before\r\n          being imported with `importlib.import_module`.\r\n    \r\n        * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\r\n          to the end of `sys.path`, if not already in `sys.path`.\r\n    \r\n        * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\r\n          to import the module, which avoids having to muck with `sys.path` at all. It effectively\r\n          allows having same-named test modules in different places.\r\n    \r\n        :param root:\r\n            Used as an anchor when mode == ImportMode.importlib to obtain\r\n            a unique name for the module being imported so it can safely be stored\r\n            into ``sys.modules``.\r\n    \r\n        :raises ImportPathMismatchError:\r\n            If after importing the given `path` and the module `__file__`\r\n            are different. Only raised in `prepend` and `append` modes.\r\n        \"\"\"\r\n        mode = ImportMode(mode)\r\n    \r\n        path = Path(p)\r\n    \r\n        if not path.exists():\r\n            raise ImportError(path)\r\n    \r\n        if mode is ImportMode.importlib:\r\n            module_name = module_name_from_path(path, root)\r\n            with contextlib.suppress(KeyError):\r\n                return sys.modules[module_name]\r\n    \r\n            for meta_importer in sys.meta_path:\r\n                spec = meta_importer.find_spec(module_name, [str(path.parent)])\r\n                if spec is not None:\r\n                    break\r\n            else:\r\n                spec = importlib.util.spec_from_file_location(module_name, str(path))\r\n    \r\n            if spec is None:\r\n                raise ImportError(f\"Can't find module {module_name} at location {path}\")\r\n            mod = importlib.util.module_from_spec(spec)\r\n            sys.modules[module_name] = mod\r\n>           spec.loader.exec_module(mod)  # type: ignore[union-attr]\r\n\r\n../../src/pytest/src/_pytest/pathlib.py:540: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <_frozen_importlib_external.SourceFileLoader object at 0x7feac0a280d0>\r\nmodule = <module '_dot_venv.lib.python3_dot_11.site-packages.anndata' from '/home/ran/tmp/pytest-doctest-import-mismatch/.venv/lib/python3.11/site-packages/anndata/__init__.py'>\r\n\r\n>   ???\r\n\r\n<frozen importlib._bootstrap_external>:940: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nf = <built-in function exec>\r\nargs = (<code object <module> at 0x7feac0c24ff0, file \"/home/ran/tmp/pytest-doctest-import-mismatch/.venv/lib/python3.11/site...__file__': '/home/ran/tmp/pytest-doctest-import-mismatch/.venv/lib/python3.11/site-packages/anndata/__init__.py', ...})\r\nkwds = {}\r\n\r\n>   ???\r\n\r\n<frozen importlib._bootstrap>:241: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\n    \"\"\"Annotated multivariate observation data.\"\"\"\r\n    from __future__ import annotations\r\n    \r\n    # Allowing notes to be added to exceptions. See: https://github.com/scverse/anndata/issues/868\r\n    import sys\r\n    \r\n    if sys.version_info < (3, 11):\r\n        # Backport package for exception groups\r\n        import exceptiongroup  # noqa: F401\r\n    \r\n>   from ._core.anndata import AnnData\r\nE   ModuleNotFoundError: No module named '_dot_venv'\r\n\r\n.venv/lib/python3.11/site-packages/anndata/__init__.py:11: ModuleNotFoundError\r\n```\r\n\r\n\r\n</p>\r\n</details>\r\n\r\nThis is possibly another problem with `--import-mode=importlib`; if I swap the order of the `exec_module` and the `insert_missing_modules` statements then it does work, but I'm not familiar enough the code to know if it's correct.\r\n\r\n@nicoddemus Do you have any idea about this?\n> First, consider editing the original post to point to the reproduction; the ImportPathMismatchError error stated there cannot happen in --import-mode=importlib so it's quite confusing\r\n\r\nfixed\r\n\r\n> Thanks for creating a reproduction. I tried it now. I was able to reproduce with pytest 7.4, but with pytest main it works \r\n\r\nWell, unless I\u2019m missing something, the same package is still imported twice with this approach, right?\r\n\r\nWhich might cause problems similar to https://github.com/pytest-dev/pytest/issues/11306 when the two versions try to access some shared resource. (e.g. let\u2019s say they both open a database connection or write a file on import time \u2013 not super good style, but possible)\n@nicoddemus any idea?\nI think no \u201cescaping\u201d hackery is necessary. We run `pytest --pyargs <modulename>`, so the parent module of any doctest should start with `<modulename>` and not `_dot_venv` or `opt.hostedtoolcache.Python*site-packages`.\r\n\r\nSo how about we just infer the correct module name of the parent module using `sys.path` by enforcing that it matches the module name supplied using `--pyargs`?\nSorry for the long post, spent the last 3 hours working on this and I'm afraid there's no simple \"fix\" for this case.\r\n\r\n\r\nThe short answer is that pytest uses `--import-mode=importlib` for all imports, not only tests and conftests as originally intended.\r\n\r\nThe introduction of `importlib` mode was meant to give an alternative to the other modes so that:\r\n\r\n1. pytest does not need change `sys.path` to import tests and conftest files.\r\n2. Different test modules can have the same base name, without `__init__.py` files.\r\n\r\n(Full explanation [in the docs](https://docs.pytest.org/en/stable/explanation/pythonpath.html#import-modes)).\r\n\r\nOn a non-src layout:\r\n\r\n\r\n```\r\npkg/__init__.py\r\ntests/\r\n  test_foo.py\r\n```\r\n\r\n\r\nOne of the reasons why changing `sys.path` is problematic in this case is because it will add `.` to the root directory to import the tests under `tests`, which has the side effect of making `pkg` also importable. This can hide problems when trying to test the installed package in `.venv`, because now we are actually testing the local sources as they are reachable through `sys.path` during testing, instead of the installed packages in `.venv`.\r\n\r\n\r\nOn `src` layouts:\r\n\r\n```\r\nsrc/pkg/__init__.py\r\ntests/\r\n  test_foo.py\r\n```\r\n\r\nThis is not a problem: adding `.` to `sys.path` does not make `pkg` importable, so `import pkg` will import from the `.venv` as desired.\r\n\r\n\r\nThe reproducer repository is using `importlib` mode, I'm guessing because of reason 2 (duplicated test names), or perhaps because at one point we recommended using `importlib` intending to turn it into the default, however since then we realized this is not possible, as it brings it has its own drawbacks.\r\n\r\n@flying-sheep, by changing your configuration slightly I was able to make your reproduce run without problems in pytest `main` and in `7.4.4`:\r\n\r\n* Exclude `conftest.py` files from being installed: they should be imported by pytest directly.\r\n* Drop `importlib`, as you are using `src` layout. If the problem is due to duplicated test names, just adding `__init__.py` on the folders with the duplicated tests solves it.\r\n```pytest\r\n\u03bb pytest\r\n======================== test session starts ========================\r\nplatform win32 -- Python 3.11.5, pytest-7.4.4, pluggy-1.4.0\r\nrootdir: e:\\projects\\pytest-doctest-import-mismatch\r\nconfigfile: pyproject.toml\r\ntestpaths: anndata, ./src/anndata/tests\r\ncollected 6 items\r\n\r\n.env311\\Lib\\site-packages\\anndata\\utils.py .                   [ 16%]\r\n.env311\\Lib\\site-packages\\anndata\\_core\\anndata.py ..          [ 50%]\r\n.env311\\Lib\\site-packages\\anndata\\_core\\merge.py ..            [ 83%]\r\nsrc\\anndata\\tests\\test_base.py .                               [100%]\r\n\r\n========================= warnings summary ==========================\r\n```\r\n\r\nHere's the diff:\r\n\r\n```diff\r\ndiff --git a/pyproject.toml b/pyproject.toml\r\nindex 81389c5..d15f40a 100644\r\n--- a/pyproject.toml\r\n+++ b/pyproject.toml\r\n@@ -21,12 +21,12 @@ dependencies = [\r\n \r\n [tool.hatch.build]\r\n exclude = [\r\n+    'src/anndata/tests/conftest.py',\r\n     'src/anndata/tests/test_*.py',\r\n ]\r\n \r\n [tool.pytest.ini_options]\r\n addopts = [\r\n-    '--import-mode=importlib',\r\n     '--doctest-modules',\r\n     '--pyargs',\r\n ]\r\n```\r\n\r\n\r\nFollows is a long description of the overall problem.\r\n\r\n---\r\n\r\nThe introduction of `importlib` mode was meant to give an alternative to the other modes so that:\r\n\r\n1. pytest does not need change `sys.path` to import tests and conftest files.\r\n2. Different test modules can have the same base name, without `__init__.py` files.\r\n\r\n(Full explanation [in the docs](https://docs.pytest.org/en/stable/explanation/pythonpath.html#import-modes)).\r\n\r\nOne important thing in that description is *test modules and *conftests*. \r\n\r\nBefore we introduced the `importlib` mode, all modules *directly* imported by pytest used the same function, `import_path`, which changes `sys.path` to import a module in case it is not already importable. \"All modules\" in the majority means tests and conftests (as user application code is imported indirectly through these), but it also includes user application code in some cases, doctests being one case relevant here.\r\n\r\nThe `importlib` mode works by assuming it is importing a module that cannot be reached from `sys.path` through the normal means, a common example being the `tests` directory layout at the root of the package, where we have a test file `tests/foo/bar/test_foo.py` without any `__init__.py` files within. It is not importable because `tests` is not reachable from `sys.path`, and we also do not want to change it.\r\n\r\nTo import that file, we:\r\n\r\n1. Try to come up with a \"module name\" for it based on its full path and root, so for the file `tests/foo/bar/test_foo.py` we make up an non-existing module name `\"tests.foo.bar.test_foo\"`. This module name will be unique, and not conflict with other test modules named `test_foo.py` in the same suite, as they will be in a different directory and will be assigned a different module name using the same mechanism (`\"tests.schema.test_foo\"` for example).\r\n\r\n2. Import the module using its full path using `importlib.importmodule`, and then place that module in `sys.modules` with the `module_name` we determined above.\r\n\r\nThis works well when used to import just test modules and conftests, but will create divergences when used import application code. In the reproducer repo, we are trying to import `anndata` using `importlib` mode, so it ends up being imported as a module named using the logic described above, however it *is* reachable through `sys.path` and we probably should import it using the normal mechanisms.\r\n\r\nProbably one solution is to revisit all places where we manually import modules, and possibly use \"importlib\" (when configured) for tests+conftests or fallback to the other mechanisms for normal modules, but this feels *extremely* risky given the millions of test suites out there.\r\n\r\nThe `importlib` mode was intended to solve avoid changing `sys.path`/\"ImportMismatch\" errors, but particularly if I knew all the problems/details it involves, I would just recommend other solutions:\r\n\r\n1. pytest changes `sys.path` and it is testing the local copy? Switch to `src` layout.\r\n2. Test module names with the same? Add `__init__.py` files in your tests turning them into packages.\r\n\r\nBut here we are. \r\n\r\nI'm not sure how to proceed here. Perhaps we can right away add a warning on `--doctest-modules` that it might be problematic to use together with `--import-mode=importlib`.\r\n\r\nI will spend some more time trying to see if there's a simple and safe solution to this general mess.\r\n\r\n\r\n\nMaybe I missed it when reading your summary, but isn\u2019t my PR a simple and safe solution?\r\n\r\nIt gets rid of this iffy strategy:\r\n\r\n> Try to come up with a \"module name\" for it based on its full path and root, so for the file tests/foo/bar/test_foo.py we make up an non-existing module name \"tests.foo.bar.test_foo\".\r\n\r\nwhenever some module *does* live below one of the `sys.path` entries.\nI will double check, but @bluetech's concern is valid: search through `sys.path` entries can be very costly, specially in environment configurations where modules are reachable by configuring `PYTHONPATH` -- at work we use this, and our `sys.path` entry will contain dozens of entries.\r\n\r\nIt does not invalidate it completely of course, but it is something we should consider.\r\n\r\nAs I said, I will double check it later. \ud83d\udc4d  \nI don\u2018t think it invalidates it in the slightest before someone has measured the impact :wink:\r\n\r\nAlso keep in mind that I outlined some strategies to make it faster.\r\n\r\nI don\u2018t think we should even consider sacrificing correctness before having tried out all other sensible avenues.\r\nImporting modules twice can lead to very subtle and hard to debug breakage, so I feel like everyone waiting 5 seconds more for the test suite would be an amazing trade-off compared to a handful of people debugging some weird double-import bug for 3 hours.\n> I don\u2018t think we should even consider sacrificing correctness before having tried out all other sensible avenues.\r\n\r\nOh I agree 100%, I didn't mean to imply that we were not applying your fix based solely on any performance problems that we have a gut feeling about -- I am just thinking there might be some other solution.\r\n\r\nOne such solution that occurred to me, and I plan to test, is that when using importlib, we *first* try to import the module normally, without altering `sys.path`. If the module ends up being importable, then we just use it; if not, then we fallback with the current importlib shenaningans. If I'm right, this would probably be the simplest and a good solution still aligned with importlib's goal: not changing sys.path and allow duplicated module names.\nI plan to spend more time this week on this, and solve this once and for all (with your fix or something else).\n> that when using importlib, we first try to import the module normally, without altering sys.path.\r\n\r\nI\u2019m confused, I thought importlib\u2019s point is that it doesn\u2019t alter sys.path?\r\n\r\n> I plan to spend more time this week on this, and solve this once and for all (with your fix or something else).\r\n\r\nAnother possibility is to just be able to make PyTest aware of the module root(s) the project has, e.g. `src/`. Then that would be used for imports instead of the project root directory.\n> I\u2019m confused, I thought importlib\u2019s point is that it doesn\u2019t alter sys.path?\r\n\r\nYep, what I mean is just try to import the module, without changing `sys.path`: in case we are trying to import a normal module which is installed in the virtualenv, this would just work.\r\n\r\n> Another possibility is to just be able to make PyTest aware of the module root(s) the project has, e.g. src/. Then that would be used for imports instead of the project root directory.\r\n\r\nThat would be another solution too.\nJust to provide another data point, I was intrigued by this comment:\r\n\r\n> The `importlib` mode was intended to solve avoid changing `sys.path`/\"ImportMismatch\" errors, but particularly if I knew all the problems/details it involves, I would just recommend other solutions:\r\n> \r\n> 1. pytest changes `sys.path` and it is testing the local copy? Switch to `src` layout.\r\n> 2. Test module names with the same? Add `__init__.py` files in your tests turning them into packages.\r\n\r\nFor what it's worth, I hadn't realized that `importlib` was no longer being recommended by default. I had been using `--import-mode=importlib` because I thought it was the recommended mode going forward, but it sounds like that's no longer the case. It looks like the [Good Integration Practices](https://docs.pytest.org/en/8.0.x/explanation/goodpractices.html#tests-outside-application-code) documentation page still (as of 8.0.x) states that:\r\n\r\n> For new projects, we recommend to use importlib [import mode](https://docs.pytest.org/en/8.0.x/explanation/pythonpath.html#import-modes) (see [which-import-mode](https://docs.pytest.org/en/8.0.x/explanation/goodpractices.html#which-import-mode) for a detailed explanation). To this end, add the following to your pyproject.toml:\r\n\r\nIs that no longer the best recommendation, even for new projects?\r\n\r\nFor what it's worth, simply removing `--import-mode=importlib` seems to fix the problem for me, though there was one little weirdness that I thought I'd mention here, related to the `pythonpath` setting and whether we are or are not using editable installs.\r\n\r\n| `--import-mode` | pythonpath | `--doctest-modules` | editable install | non-doctests pass? |\r\n| --------------- | ---------- | ------------------- | ---------------- | ------------------ |\r\n| prepend         | (omitted)  | no                  | no               | no                 |\r\n| prepend         | (omitted)  | no                  | yes              | yes                |\r\n| prepend         | (omitted)  | yes                 | no               | yes                |\r\n| prepend         | (omitted)  | yes                 | yes              | yes                |\r\n| prepend         | src        | no                  | no               | yes                |\r\n| prepend         | src        | no                  | yes              | yes                |\r\n| prepend         | src        | yes                 | no               | yes                |\r\n| prepend         | src        | yes                 | yes              | yes                |\r\n| importlib       | (omitted)  | no                  | no               | no                 |\r\n| importlib       | (omitted)  | no                  | yes              | yes                |\r\n| importlib       | (omitted)  | yes                 | no               | no                 |\r\n| importlib       | (omitted)  | yes                 | yes              | yes                |\r\n| importlib       | src        | no                  | no               | yes                |\r\n| importlib       | src        | no                  | yes              | yes                |\r\n| importlib       | src        | yes                 | no               | no                 |\r\n| importlib       | src        | yes                 | yes              | yes                |\r\n\r\nWhat I mean by the last column, \"non-doctests pass?\", is that when I write a \"no\", it means that the non-doctest tests fail with import errors.\r\n\r\nEdit: The version of pytest that I am currently using is 7.3.1, so the data in the table reflects that version.\r\n\r\nTo summarize the table, it looks like editable and non-editable installs behave very differently depending on the values of `--import-mode`, `pythonpath`, and presence of `--doctest-modules`. For some reason, when in `prepend` mode, if you don't set `pythonpath` to `src` and if you don't pass in `--doctest-modules`, then all the non-doctest tests will fail in editable installs, but if pass in `--doctest-modules` without setting `src`, then the non-doctest tests will pass.\r\n\r\nDoes the presence of `--doctest-modules` cause you to not need to specify `pythonpath = \"src\"` for some reason?\r\n\r\nI'm asking because I'm managing multiple Python projects, some with doctests and others without any doctests, and I'd like to keep their pytest configurations as close as possible, ideally only passing in `--doctest-modules` in the projects that actually have doctests written. I found it strange that in projects without doctests, going back to `prepend` mode caused the non-doctest tests to all fail, but in projects with doctests, they ran fine, and I determined that the `--doctest-modules` option was affecting how non-doctest tests were being imported.\r\n\r\nFor my use case, I think I can standardize on `prepend` mode, explicitly setting `pythonpath = src`, and optionally adding or omitting `--doctest-modules` depending on the project, and it seems to work and have the expected behavior for both editable and non-editable installs.\r\n\r\nBTW, thanks for the really detailed discussion in this ticket. I've been following this ticket mostly as an observer, and it's been helping me understand how the various settings interact with each other.\nI don\u2019t want to use any `sys.path`-modifying method. It\u2019s much cleaner to have PyTest\u2019s collection deal with importing and running tests, and leave `sys.path` for the actual library under test.\nProposing a definite solution (IMHO) in #11997. \ud83d\udc4d \nThanks @flying-sheep for the PR.\r\n\r\nSorry, the original issue escaped my radar. I will set aside some time this week to understand the original issue and review this PR.\r\n\r\nThanks and sorry again for the delay on this. \ud83d\udc4d \nNo problem, I know how it is, and I\u2019m hesitant to be too annoying with pings, so I hoped this PR might be a productive way to get this going :smile: \nSuperseded by #11997", "created_at": "2024-02-17T16:26:01Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11996, "instance_id": "pytest-dev__pytest-11996", "issue_numbers": ["11953"], "base_commit": "984478109f2e597f1eee86d69cb29b5de67cb051", "patch": "diff --git a/changelog/11953.bugfix.rst b/changelog/11953.bugfix.rst\nnew file mode 100644\nindex 00000000000..5aff5f7fdb7\n--- /dev/null\n+++ b/changelog/11953.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix an ``IndexError`` crash raising from ``getstatementrange_ast``.\n", "test_patch": "diff --git a/src/_pytest/_code/source.py b/src/_pytest/_code/source.py\nindex 69f580e2055..dac3c3867d8 100644\n--- a/src/_pytest/_code/source.py\n+++ b/src/_pytest/_code/source.py\n@@ -197,7 +197,9 @@ def getstatementrange_ast(\n         # by using the BlockFinder helper used which inspect.getsource() uses itself.\n         block_finder = inspect.BlockFinder()\n         # If we start with an indented line, put blockfinder to \"started\" mode.\n-        block_finder.started = source.lines[start][0].isspace()\n+        block_finder.started = (\n+            bool(source.lines[start]) and source.lines[start][0].isspace()\n+        )\n         it = ((x + \"\\n\") for x in source.lines[start:end])\n         try:\n             for tok in tokenize.generate_tokens(lambda: next(it)):\n", "problem_statement": "Internal IndexError when testing\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\nI've encountered a strange IndexError when testing my package on GitHub Actions. It doesn't happen locally and only Python 3.11+ is affected.\r\n\r\npytest is 8.0.0, OS is ubuntu-20.04\r\nHere's the log from the failed action: [logs.txt](https://github.com/pytest-dev/pytest/files/14210376/logs.txt)\r\n\r\nYou can check my repository for details: https://github.com/solaluset/pwcp/tree/rename\n", "hints_text": "Relevant part of the logs:\r\n\r\n```pytb\r\nTraceback (most recent call last):\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/main.py\", line 272, in wrap_session\r\n    session.exitstatus = doit(config, session) or 0\r\n                         ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/main.py\", line 326, in _main\r\n    config.hook.pytest_runtestloop(session=session)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_hooks.py\", line 501, in __call__\r\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_manager.py\", line 119, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 138, in _multicall\r\n    raise exception.with_traceback(exception.__traceback__)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/logging.py\", line 796, in pytest_runtestloop\r\n    return (yield)  # Run all the tests.\r\n            ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 102, in _multicall\r\n    res = hook_impl.function(*args)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/main.py\", line 351, in pytest_runtestloop\r\n    item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_hooks.py\", line 501, in __call__\r\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_manager.py\", line 119, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 138, in _multicall\r\n    raise exception.with_traceback(exception.__traceback__)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/warnings.py\", line 109, in pytest_runtest_protocol\r\n    return (yield)\r\n            ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/assertion/__init__.py\", line 174, in pytest_runtest_protocol\r\n    return (yield)\r\n            ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/unittest.py\", line 408, in pytest_runtest_protocol\r\n    res = yield\r\n          ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/faulthandler.py\", line 85, in pytest_runtest_protocol\r\n    return (yield)\r\n            ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 102, in _multicall\r\n    res = hook_impl.function(*args)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/runner.py\", line 114, in pytest_runtest_protocol\r\n    runtestprotocol(item, nextitem=nextitem)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/runner.py\", line 133, in runtestprotocol\r\n    reports.append(call_and_report(item, \"call\", log))\r\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/runner.py\", line 228, in call_and_report\r\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\r\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_hooks.py\", line 501, in __call__\r\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_manager.py\", line 119, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 138, in _multicall\r\n    raise exception.with_traceback(exception.__traceback__)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/tmpdir.py\", line 316, in pytest_runtest_makereport\r\n    rep = yield\r\n          ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\r\n    teardown.throw(exception)  # type: ignore[union-attr]\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/skipping.py\", line 269, in pytest_runtest_makereport\r\n    rep = yield\r\n          ^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 102, in _multicall\r\n    res = hook_impl.function(*args)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/runner.py\", line 372, in pytest_runtest_makereport\r\n    return TestReport.from_item_and_call(item, call)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/reports.py\", line 364, in from_item_and_call\r\n    longrepr = item.repr_failure(excinfo)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/python.py\", line 1877, in repr_failure\r\n    return self._repr_failure_py(excinfo, style=style)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/nodes.py\", line 497, in _repr_failure_py\r\n    return excinfo.getrepr(\r\n           ^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 698, in getrepr\r\n    return fmt.repr_excinfo(self)\r\n           ^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 1057, in repr_excinfo\r\n    reprtraceback = self.repr_traceback(excinfo_)\r\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 981, in repr_traceback\r\n    entries = [\r\n              ^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 982, in <listcomp>\r\n    self.repr_traceback_entry(entry, excinfo if last == entry else None)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 920, in repr_traceback_entry\r\n    source = self._getentrysource(entry)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 822, in _getentrysource\r\n    source = entry.getsource(self.astcache)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/code.py\", line 259, in getsource\r\n    astnode, _, end = getstatementrange_ast(\r\n                      ^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_code/source.py\", line 199, in getstatementrange_ast\r\n    block_finder.started = source.lines[start][0].isspace()\r\n                           ~~~~~~~~~~~~~~~~~~~^^^\r\nIndexError: string index out of range\r\n```\nThis was because `incomplete_input` (https://github.com/python/cpython/commit/cd6e0a04a16535d8bc727c84f73730c53267184e) was causing an error in my module. Still, pytest was of no help until I monkey patched it to check if the string actually contains something.", "created_at": "2024-02-17T10:26:05Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11991, "instance_id": "pytest-dev__pytest-11991", "issue_numbers": ["11906"], "base_commit": "6ef0cf150ab234eaa631e54b3122e2f01571eafb", "patch": "diff --git a/changelog/11906.bugfix.rst b/changelog/11906.bugfix.rst\nnew file mode 100644\nindex 00000000000..68bede540a8\n--- /dev/null\n+++ b/changelog/11906.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix regression with :func:`pytest.warns` using custom warning subclasses which have more than one parameter in their `__init__`.\n", "test_patch": "diff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\nindex 9eced36ff53..bcf9f1466c5 100644\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -334,10 +334,10 @@ def found_str() -> str:\n             for w in self:\n                 if not self.matches(w):\n                     warnings.warn_explicit(\n-                        str(w.message),\n-                        w.message.__class__,  # type: ignore[arg-type]\n-                        w.filename,\n-                        w.lineno,\n+                        message=w.message,\n+                        category=w.category,\n+                        filename=w.filename,\n+                        lineno=w.lineno,\n                         module=w.__module__,\n                         source=w.source,\n                     )\ndiff --git a/testing/test_recwarn.py b/testing/test_recwarn.py\nindex edd4f51b585..27ee9aa72f0 100644\n--- a/testing/test_recwarn.py\n+++ b/testing/test_recwarn.py\n@@ -581,3 +581,17 @@ def test_raise_type_error_on_invalid_warning_message_cpython() -> None:\n         with warnings.catch_warnings():\n             warnings.filterwarnings(\"ignore\", \"test\")\n             warnings.warn(1)  # type: ignore\n+\n+\n+def test_multiple_arg_custom_warning() -> None:\n+    \"\"\"Test for issue #11906.\"\"\"\n+\n+    class CustomWarning(UserWarning):\n+        def __init__(self, a, b):\n+            pass\n+\n+    with pytest.warns(CustomWarning):\n+        with pytest.raises(pytest.fail.Exception, match=\"DID NOT WARN\"):\n+            with pytest.warns(CustomWarning, match=\"not gonna match\"):\n+                a, b = 1, 2\n+                warnings.warn(CustomWarning(a, b))\n", "problem_statement": "Bug in 8.0.0 `pytest.warns` handling\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\nThere seems to be a handling error in 8.0.0, when `pytest.warns` fails to match the message. **Seems that the warning class itself is being called towards the end of the handling...**\r\n\r\n```python\r\nimport pytest\r\nimport warnings\r\n\r\nassert pytest.__version__ == \"8.0.0\"\r\n\r\nclass AWarning(UserWarning):\r\n    \r\n    def __init__(self, a, b):\r\n        pass\r\n\r\na, b = 1, 2\r\nwith pytest.warns(AWarning, match=\"not gonna match\"):\r\n    warnings.warn(AWarning(a, b))\r\n```\r\n```\r\n---------------------------------------------------------------------------\r\nFailed                                    Traceback (most recent call last)\r\n    [... skipping hidden 1 frame]\r\n\r\nFile ~\\...\\market_prices\\.venv\\lib\\site-packages\\_pytest\\outcomes.py:187, in fail(reason, pytrace, msg)\r\n    186 reason = _resolve_msg_to_reason(\"fail\", reason, msg)\r\n--> 187 raise Failed(msg=reason, pytrace=pytrace)\r\n\r\nFailed: DID NOT WARN. No warnings of type (<class '__main__.AWarning'>,) matching the regex were emitted.\r\n Regex: not gonna match\r\n Emitted warnings: [AWarning(1, 2)].\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\nCell In[1], line 13\r\n     11 a, b = 1, 2\r\n     12 with pytest.warns(AWarning, match=\"not gonna match\"):\r\n---> 13     warnings.warn(AWarning(a, b))\r\n\r\nFile ~\\...\\market_prices\\.venv\\lib\\site-packages\\_pytest\\recwarn.py:333, in WarningsChecker.__exit__(self, exc_type, exc_val, exc_tb)\r\n    331 for w in self:\r\n    332     if not self.matches(w):\r\n--> 333         warnings.warn_explicit(\r\n    334             str(w.message),\r\n    335             w.message.__class__,  # type: ignore[arg-type]\r\n    336             w.filename,\r\n    337             w.lineno,\r\n    338             module=w.__module__,\r\n    339             source=w.source,\r\n    340         )\r\n\r\nTypeError: __init__() missing 1 required positional argument: 'b'\r\n```\r\n\r\n**NB: only seems to happen if the Warning class takes more than one argument.** For example, if arg b is stripped from all the above then the failure to match is handled as expected.\r\n\r\nAlso, worked fine in 7.4.4:\r\n\r\n```python\r\nimport pytest\r\nimport warnings\r\n\r\nassert pytest.__version__ == \"7.4.4\"\r\n\r\nclass AWarning(UserWarning):\r\n    \r\n    def __init__(self, a, b):\r\n        pass\r\n\r\na, b = 1, 2\r\nwith pytest.warns(AWarning, match=\"not gonna match\"):\r\n    warnings.warn(AWarning(a, b))\r\n```\r\n```\r\n---------------------------------------------------------------------------\r\nFailed                                    Traceback (most recent call last)\r\nCell In[1], line 13\r\n     11 a, b = 1, 2\r\n     12 with pytest.warns(AWarning, match=\"not gonna match\"):\r\n---> 13     warnings.warn(AWarning(a, b))\r\n\r\n    [... skipping hidden 1 frame]\r\n\r\nFile ~\\...\\market_prices\\.venv\\lib\\site-packages\\_pytest\\outcomes.py:198, in fail(reason, pytrace, msg)\r\n    196 __tracebackhide__ = True\r\n    197 reason = _resolve_msg_to_reason(\"fail\", reason, msg)\r\n--> 198 raise Failed(msg=reason, pytrace=pytrace)\r\n\r\nFailed: DID NOT WARN. No warnings of type (<class '__main__.AWarning'>,) matching the regex were emitted.\r\n Regex: not gonna match\r\n Emitted warnings: [AWarning(1, 2)]\r\n```\r\n\r\nThanks is advance for looking at this!\r\n\r\nOS: 'Windows-10-10.0.22631-SP0'\n", "hints_text": "Also reproducible outside pytest:\r\n\r\n```python\r\n>>> w = AWarning(1, 2)\r\n>>> warnings.warn_explicit(message=str(w), category=w.__class__, filename=\"test.py\", lineno=1)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: AWarning.__init__() missing 1 required positional argument: 'b'\r\n```\r\n\r\nSo while I can't find this documented explicitly anywhere, it looks like Python doesn't expect the signature of a warning's `__init__` changing. Not really much pytest can do about that.\nThanks for the quick reply @The-Compiler!\r\n\r\n> looks like Python doesn't expect the signature of a warning's __init__ changing. Not really much pytest can do about that.\r\n\r\nAlthough pytest handled this fine prior to 8.0,0?\r\n\r\nIsn't the following call merely an election on the part of pytest?\r\n```python\r\nwarnings.warn_explicit(message=str(w), category=w.__class__, filename=\"test.py\", lineno=1)\r\n```\r\nI'm not clear on why the implication of Python providing for raising a warning in this way is that warning messages shouldn't be dynamic (which they obviously can be) (?).\r\n\r\nThanks again.\nYes, the call was added in #10937 - but unless others disagree (@reaganjlee @Zac-HD thoughts?), I'd argue that the bug is in your code and not pytest.\nSo we're saying that the `warn_explicit` method's signature implies that you shouldn't do the following, which would be considered a bug...(?)\r\n\r\n```python\r\nclass CustomWarning(UserWarning):\r\n\r\n    def __init__(self, a, b):\r\n        self._msg = (\r\n            \"This warning message is customised to include reference to\"\r\n            f\"parameters {a} and {b}\"\r\n        )\r\n\r\n    def __str__(self):\r\n        return self._msg\r\n```\r\nLike yourself, I can't find any documentation suggesting that this shouldn't be done...\nIndeed - looking at the call pytest does in isolation, I can't see anything that would be wrong with it. The failure happens inside Python's [own `warn_explicit` implementation](https://github.com/python/cpython/blob/v3.12.1/Lib/warnings.py#L360) (or rather, the equivalent [C implementation](https://github.com/python/cpython/blob/v3.12.1/Python/_warnings.c#L669)).\r\n\r\nThat being said, the [`warn_explicit` docs say](https://docs.python.org/3/library/warnings.html#warnings.warn_explicit) (emphasis mine):\r\n\r\n> *message* must be a string and *category* a subclass of [`Warning`](https://docs.python.org/3/library/exceptions.html#Warning) or ***message* may be a [`Warning`](https://docs.python.org/3/library/exceptions.html#Warning) instance, in which case *category* will be ignored.**\r\n\r\nSo I suppose pytest could still work around this by using `message=w, category=None` or somesuch instead?\nInteresting.\r\n\r\nI'm not sure of the purposes for why pytest now makes this call in 8.0. Although, I notice that you now re-raise captured warnings that don't match any passed regex, so I'm guessing that's it (?), in which case passing the instance to 'message' sounds reasonable?\r\n\r\nI just find the change in behaviour unexpected.\r\n\r\nRegardless of any action taken, or not, thank you for looking at this.\n> So I suppose pytest could still work around this by using `message=w, category=None` or somesuch instead?\r\n\r\nI think it's worth check that this would have the desired effect, and shipping it in our next patch if so.  \r\n\r\nI'm [aware that re-emitting warnings can be a breaking change](https://github.com/pytest-dev/pytest/pull/10937#issuecomment-1619222493) and think that missing fewer warnings is worth it, but if we can make a slight change to our use of the stdlib to break _less_ downstream code that'd be nice.  ", "created_at": "2024-02-16T12:15:21Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11979, "instance_id": "pytest-dev__pytest-11979", "issue_numbers": ["11978"], "base_commit": "8a410d0ba60bca7073bf18a1503c59a3b5445780", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex dce91c4fe0e..bb27dd1d7c2 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -56,6 +56,7 @@ Babak Keyvani\n Barney Gale\n Ben Brown\n Ben Gartner\n+Ben Leith\n Ben Webb\n Benjamin Peterson\n Benjamin Schubert\ndiff --git a/changelog/11978.improvement.rst b/changelog/11978.improvement.rst\nnew file mode 100644\nindex 00000000000..1f1143dacf0\n--- /dev/null\n+++ b/changelog/11978.improvement.rst\n@@ -0,0 +1,3 @@\n+Add ``--log-file-mode`` option to the logging plugin, enabling appending to log-files. This option accepts either ``\"w\"`` or ``\"a\"`` and defaults to ``\"w\"``.\n+\n+Previously, the mode was hard-coded to be ``\"w\"`` which truncates the file before logging.\ndiff --git a/doc/en/how-to/logging.rst b/doc/en/how-to/logging.rst\nindex bdcfbe34fa2..300e9f6e6c2 100644\n--- a/doc/en/how-to/logging.rst\n+++ b/doc/en/how-to/logging.rst\n@@ -206,8 +206,9 @@ option names are:\n * ``log_cli_date_format``\n \n If you need to record the whole test suite logging calls to a file, you can pass\n-``--log-file=/path/to/log/file``. This log file is opened in write mode which\n+``--log-file=/path/to/log/file``. This log file is opened in write mode by default which\n means that it will be overwritten at each run tests session.\n+If you'd like the file opened in append mode instead, then you can pass ``--log-file-mode=a``.\n Note that relative paths for the log-file location, whether passed on the CLI or declared in a\n config file, are always resolved relative to the current working directory.\n \n@@ -223,12 +224,13 @@ All of the log file options can also be set in the configuration INI file. The\n option names are:\n \n * ``log_file``\n+* ``log_file_mode``\n * ``log_file_level``\n * ``log_file_format``\n * ``log_file_date_format``\n \n You can call ``set_log_path()`` to customize the log_file path dynamically. This functionality\n-is considered **experimental**.\n+is considered **experimental**. Note that ``set_log_path()`` respects the ``log_file_mode`` option.\n \n .. _log_colors:\n \n", "test_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex aa3a33e6377..e9a3234fdec 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -298,6 +298,13 @@ def add_option_ini(option, dest, default=None, type=None, **kwargs):\n         default=None,\n         help=\"Path to a file when logging will be written to\",\n     )\n+    add_option_ini(\n+        \"--log-file-mode\",\n+        dest=\"log_file_mode\",\n+        default=\"w\",\n+        choices=[\"w\", \"a\"],\n+        help=\"Log file open mode\",\n+    )\n     add_option_ini(\n         \"--log-file-level\",\n         dest=\"log_file_level\",\n@@ -669,7 +676,10 @@ def __init__(self, config: Config) -> None:\n             if not os.path.isdir(directory):\n                 os.makedirs(directory)\n \n-        self.log_file_handler = _FileHandler(log_file, mode=\"w\", encoding=\"UTF-8\")\n+        self.log_file_mode = get_option_ini(config, \"log_file_mode\") or \"w\"\n+        self.log_file_handler = _FileHandler(\n+            log_file, mode=self.log_file_mode, encoding=\"UTF-8\"\n+        )\n         log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n         log_file_date_format = get_option_ini(\n             config, \"log_file_date_format\", \"log_date_format\"\n@@ -746,7 +756,7 @@ def set_log_path(self, fname: str) -> None:\n             fpath.parent.mkdir(exist_ok=True, parents=True)\n \n         # https://github.com/python/mypy/issues/11193\n-        stream: io.TextIOWrapper = fpath.open(mode=\"w\", encoding=\"UTF-8\")  # type: ignore[assignment]\n+        stream: io.TextIOWrapper = fpath.open(mode=self.log_file_mode, encoding=\"UTF-8\")  # type: ignore[assignment]\n         old_stream = self.log_file_handler.setStream(stream)\n         if old_stream:\n             old_stream.close()\ndiff --git a/testing/logging/test_reporting.py b/testing/logging/test_reporting.py\nindex 24eae19b7ba..7e592febf56 100644\n--- a/testing/logging/test_reporting.py\n+++ b/testing/logging/test_reporting.py\n@@ -661,6 +661,73 @@ def test_log_file(request):\n         assert \"This log message won't be shown\" not in contents\n \n \n+def test_log_file_mode_cli(pytester: Pytester) -> None:\n+    # Default log file level\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        import logging\n+        def test_log_file(request):\n+            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n+            assert plugin.log_file_handler.level == logging.WARNING\n+            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n+            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n+            print('PASSED')\n+    \"\"\"\n+    )\n+\n+    log_file = str(pytester.path.joinpath(\"pytest.log\"))\n+\n+    with open(log_file, mode=\"w\", encoding=\"utf-8\") as wfh:\n+        wfh.write(\"A custom header\\n\")\n+\n+    result = pytester.runpytest(\n+        \"-s\",\n+        f\"--log-file={log_file}\",\n+        \"--log-file-mode=a\",\n+        \"--log-file-level=WARNING\",\n+    )\n+\n+    # fnmatch_lines does an assertion internally\n+    result.stdout.fnmatch_lines([\"test_log_file_mode_cli.py PASSED\"])\n+\n+    # make sure that we get a '0' exit code for the testsuite\n+    assert result.ret == 0\n+    assert os.path.isfile(log_file)\n+    with open(log_file, encoding=\"utf-8\") as rfh:\n+        contents = rfh.read()\n+        assert \"A custom header\" in contents\n+        assert \"This log message will be shown\" in contents\n+        assert \"This log message won't be shown\" not in contents\n+\n+\n+def test_log_file_mode_cli_invalid(pytester: Pytester) -> None:\n+    # Default log file level\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        import logging\n+        def test_log_file(request):\n+            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n+            assert plugin.log_file_handler.level == logging.WARNING\n+            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n+            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n+    \"\"\"\n+    )\n+\n+    log_file = str(pytester.path.joinpath(\"pytest.log\"))\n+\n+    result = pytester.runpytest(\n+        \"-s\",\n+        f\"--log-file={log_file}\",\n+        \"--log-file-mode=b\",\n+        \"--log-file-level=WARNING\",\n+    )\n+\n+    # make sure that we get a '4' exit code for the testsuite\n+    assert result.ret == ExitCode.USAGE_ERROR\n+\n+\n def test_log_file_cli_level(pytester: Pytester) -> None:\n     # Default log file level\n     pytester.makepyfile(\n@@ -741,6 +808,47 @@ def test_log_file(request):\n         assert \"This log message won't be shown\" not in contents\n \n \n+def test_log_file_mode_ini(pytester: Pytester) -> None:\n+    log_file = str(pytester.path.joinpath(\"pytest.log\"))\n+\n+    pytester.makeini(\n+        f\"\"\"\n+        [pytest]\n+        log_file={log_file}\n+        log_file_mode=a\n+        log_file_level=WARNING\n+        \"\"\"\n+    )\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+        import logging\n+        def test_log_file(request):\n+            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n+            assert plugin.log_file_handler.level == logging.WARNING\n+            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n+            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n+            print('PASSED')\n+    \"\"\"\n+    )\n+\n+    with open(log_file, mode=\"w\", encoding=\"utf-8\") as wfh:\n+        wfh.write(\"A custom header\\n\")\n+\n+    result = pytester.runpytest(\"-s\")\n+\n+    # fnmatch_lines does an assertion internally\n+    result.stdout.fnmatch_lines([\"test_log_file_mode_ini.py PASSED\"])\n+\n+    assert result.ret == ExitCode.OK\n+    assert os.path.isfile(log_file)\n+    with open(log_file, encoding=\"utf-8\") as rfh:\n+        contents = rfh.read()\n+        assert \"A custom header\" in contents\n+        assert \"This log message will be shown\" in contents\n+        assert \"This log message won't be shown\" not in contents\n+\n+\n def test_log_file_ini_level(pytester: Pytester) -> None:\n     log_file = str(pytester.path.joinpath(\"pytest.log\"))\n \n@@ -1060,6 +1168,66 @@ def test_second():\n         assert \"message from test 2\" in content\n \n \n+def test_log_set_path_with_log_file_mode(pytester: Pytester) -> None:\n+    report_dir_base = str(pytester.path)\n+\n+    pytester.makeini(\n+        \"\"\"\n+        [pytest]\n+        log_file_level = DEBUG\n+        log_cli=true\n+        log_file_mode=a\n+        \"\"\"\n+    )\n+    pytester.makeconftest(\n+        f\"\"\"\n+            import os\n+            import pytest\n+            @pytest.hookimpl(wrapper=True, tryfirst=True)\n+            def pytest_runtest_setup(item):\n+                config = item.config\n+                logging_plugin = config.pluginmanager.get_plugin(\"logging-plugin\")\n+                report_file = os.path.join({report_dir_base!r}, item._request.node.name)\n+                logging_plugin.set_log_path(report_file)\n+                return (yield)\n+        \"\"\"\n+    )\n+    pytester.makepyfile(\n+        \"\"\"\n+            import logging\n+            logger = logging.getLogger(\"testcase-logger\")\n+            def test_first():\n+                logger.info(\"message from test 1\")\n+                assert True\n+\n+            def test_second():\n+                logger.debug(\"message from test 2\")\n+                assert True\n+        \"\"\"\n+    )\n+\n+    test_first_log_file = os.path.join(report_dir_base, \"test_first\")\n+    test_second_log_file = os.path.join(report_dir_base, \"test_second\")\n+    with open(test_first_log_file, mode=\"w\", encoding=\"utf-8\") as wfh:\n+        wfh.write(\"A custom header for test 1\\n\")\n+\n+    with open(test_second_log_file, mode=\"w\", encoding=\"utf-8\") as wfh:\n+        wfh.write(\"A custom header for test 2\\n\")\n+\n+    result = pytester.runpytest()\n+    assert result.ret == ExitCode.OK\n+\n+    with open(test_first_log_file, encoding=\"utf-8\") as rfh:\n+        content = rfh.read()\n+        assert \"A custom header for test 1\" in content\n+        assert \"message from test 1\" in content\n+\n+    with open(test_second_log_file, encoding=\"utf-8\") as rfh:\n+        content = rfh.read()\n+        assert \"A custom header for test 2\" in content\n+        assert \"message from test 2\" in content\n+\n+\n def test_colored_captured_log(pytester: Pytester) -> None:\n     \"\"\"Test that the level names of captured log messages of a failing test\n     are colored.\"\"\"\n", "problem_statement": "Add `log-file-mode` option to enable appending instead of truncating\n<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\n<!-- What are you trying to do, that you are unable to achieve with pytest as it currently stands? -->\r\nI'm trying to add custom headers to my log-files before running pytest. This is currently impossible because the `LoggingPlugin` hard-codes the `_FileHandler` mode to be `\"w\"` which truncates the log-file before printing logs.\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\nI'd like to be able to pass a `--log-file-mode=a` option that is respected by the `LoggingPlugin` and enables it to append to, rather than truncate, the log-file. \r\n\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\nThis would allow me to add custom headers to my log-files, providing additional context of the test run and the state of the system. These log-files are provided to users for debugging purposes and, as such, additional context is valuable.\r\n\r\n#### Alternative Solutions\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\nIt would be possible to achieve this post hoc by reading the contents of the log-file, adding the custom header, then rewriting the contents, but this seems inefficient.\r\n\r\n#### Additional context\r\n<!-- Add any other context, links, etc. about the feature here. -->\r\nDuring my search, I found this seemingly related [issue](https://github.com/pytest-dev/pytest/issues/10456) that was closed due to a lack of information.\r\n\r\nI'm happy to provide a PR with the required changes and tests.\r\n\n", "hints_text": "", "created_at": "2024-02-15T01:50:36Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11963, "instance_id": "pytest-dev__pytest-11963", "issue_numbers": ["11311"], "base_commit": "7690a0ddf15785f0af0e9a4cf8524379c53cd061", "patch": "diff --git a/changelog/11311.improvement.rst b/changelog/11311.improvement.rst\nnew file mode 100644\nindex 00000000000..0072f39743a\n--- /dev/null\n+++ b/changelog/11311.improvement.rst\n@@ -0,0 +1,4 @@\n+When using ``--override-ini`` for paths in invocations without a configuration file defined, the current working directory is used\n+as the relative directory.\n+\n+Previoulsy this would raise an :class:`AssertionError`.\n", "test_patch": "diff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex cada2aa0978..3d448214cbe 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -1563,9 +1563,11 @@ def _getini(self, name: str):\n         #   in this case, we already have a list ready to use.\n         #\n         if type == \"paths\":\n-            # TODO: This assert is probably not valid in all cases.\n-            assert self.inipath is not None\n-            dp = self.inipath.parent\n+            dp = (\n+                self.inipath.parent\n+                if self.inipath is not None\n+                else self.invocation_params.dir\n+            )\n             input_values = shlex.split(value) if isinstance(value, str) else value\n             return [dp / x for x in input_values]\n         elif type == \"args\":\ndiff --git a/src/_pytest/config/argparsing.py b/src/_pytest/config/argparsing.py\nindex da05acf398e..d98f1ae9a12 100644\n--- a/src/_pytest/config/argparsing.py\n+++ b/src/_pytest/config/argparsing.py\n@@ -198,9 +198,16 @@ def addini(\n                 * ``paths``: a list of :class:`pathlib.Path`, separated as in a shell\n                 * ``pathlist``: a list of ``py.path``, separated as in a shell\n \n+            For ``paths`` and ``pathlist`` types, they are considered relative to the ini-file.\n+            In case the execution is happening without an ini-file defined,\n+            they will be considered relative to the current working directory (for example with ``--override-ini``).\n+\n             .. versionadded:: 7.0\n                 The ``paths`` variable type.\n \n+            .. versionadded:: 8.1\n+                Use the current working directory to resolve ``paths`` and ``pathlist`` in the absence of an ini-file.\n+\n             Defaults to ``string`` if ``None`` or not passed.\n         :param default:\n             Default value if no ini-file option exists but is queried.\ndiff --git a/testing/test_config.py b/testing/test_config.py\nindex ead693cf48b..4377257b12e 100644\n--- a/testing/test_config.py\n+++ b/testing/test_config.py\n@@ -1874,6 +1874,18 @@ def test():\n         assert \"ERROR:\" not in result.stderr.str()\n         result.stdout.fnmatch_lines([\"collected 1 item\", \"*= 1 passed in *=\"])\n \n+    def test_override_ini_without_config_file(self, pytester: Pytester) -> None:\n+        pytester.makepyfile(**{\"src/override_ini_without_config_file.py\": \"\"})\n+        pytester.makepyfile(\n+            **{\n+                \"tests/test_override_ini_without_config_file.py\": (\n+                    \"import override_ini_without_config_file\\ndef test(): pass\"\n+                ),\n+            }\n+        )\n+        result = pytester.runpytest(\"--override-ini\", \"pythonpath=src\")\n+        assert result.parseoutcomes() == {\"passed\": 1}\n+\n \n def test_help_via_addopts(pytester: Pytester) -> None:\n     pytester.makeini(\n", "problem_statement": "AssertionError triggered by `pytest --override-ini='pythonpath=foo'`\n# Description\r\n\r\nThe option `--override-ini='pythonpath=foo'` may trigger an `AssertionError`.\r\n\r\n## Minimal example\r\n\r\nRunning `pytest --override-ini='pythonpath=foo'` in an *empty* directory fails with\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1495, in getini\r\n    return self._inicache[name]\r\n           ~~~~~~~~~~~~~~^^^^^^\r\nKeyError: 'pythonpath'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/miccoli/.pyenv/versions/_pytest_bug/bin/pytest\", line 8, in <module>\r\n    sys.exit(console_main())\r\n             ^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 189, in console_main\r\n    code = main()\r\n           ^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 147, in main\r\n    config = _prepareconfig(args, plugins)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 328, in _prepareconfig\r\n    config = pluginmanager.hook.pytest_cmdline_parse(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_hooks.py\", line 433, in __call__\r\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_manager.py\", line 112, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_callers.py\", line 133, in _multicall\r\n    teardown[0].send(outcome)\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/helpconfig.py\", line 103, in pytest_cmdline_parse\r\n    config: Config = outcome.get_result()\r\n                     ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_result.py\", line 108, in get_result\r\n    raise exc.with_traceback(exc.__traceback__)\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_callers.py\", line 80, in _multicall\r\n    res = hook_impl.function(*args)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1075, in pytest_cmdline_parse\r\n    self.parse(args)\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1425, in parse\r\n    self._preparse(args, addopts=addopts)\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1327, in _preparse\r\n    self.hook.pytest_load_initial_conftests(\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_hooks.py\", line 433, in __call__\r\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_manager.py\", line 112, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_callers.py\", line 155, in _multicall\r\n    return outcome.get_result()\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_result.py\", line 108, in get_result\r\n    raise exc.with_traceback(exc.__traceback__)\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/pluggy/_callers.py\", line 80, in _multicall\r\n    res = hook_impl.function(*args)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/python_path.py\", line 15, in pytest_load_initial_conftests\r\n    for path in reversed(early_config.getini(\"pythonpath\")):\r\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1497, in getini\r\n    self._inicache[name] = val = self._getini(name)\r\n                                 ^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/miccoli/.pyenv/versions/3.11.4/envs/_pytest_bug/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1540, in _getini\r\n    assert self.inipath is not None\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError\r\n```\r\n\r\n## Output of `pip list` and enviornment\r\n\r\n```\r\nPackage    Version\r\n---------- -------\r\niniconfig  2.0.0\r\npackaging  23.1\r\npip        23.2.1\r\npluggy     1.2.0\r\npytest     7.4.0\r\nsetuptools 65.5.0\r\n```\r\n\r\nRun on `macOS-13.2.1-x86_64-i386-64bit`, but same problem also on linux.\r\n\r\n## Context\r\n\r\nI stumbled in this error while building a python package for Arch: instead of using\r\n```bash\r\ncheck(){\r\n    cd \"$_name-$pkgver\"\r\n    PYTHONPATH=src pytest\r\n}\r\n```\r\nI tried \r\n```bash\r\ncheck(){\r\n    cd \"$_name-$pkgver\"\r\n    pytest -o pythonpath=src\r\n}\r\n```\r\nwhich fails with the above traceback.\r\n\r\nI replicated the problem on a MacOs stripped down venv just to be sure that it is not related to the ArchLinux build env, which is quite complicated.\r\n\n", "hints_text": "Thanks for the report.\r\n\r\n### Problem\r\n\r\nThis happens because:\r\n\r\n1. Running `pytest` in a directory without a config file (or in one of the parents) means `config.inipath` is None.\r\n2. `-o pythonpath` uses a `type=\"paths\"` ini option.\r\n3. `type=\"paths\"` ini options are defined to take paths relative to `inipath`.\r\n4. The code does not handle 1 + 3 at the same time:\r\n\r\n    https://github.com/pytest-dev/pytest/blob/73d754bd74ae8ddf86eb90cda29545cef495e927/src/_pytest/config/__init__.py#L1544-L1545\r\n\r\n    (note: similar assert is in legacypath plugin for `type=\"pathlist\"` options)\r\n\r\n### Possible solutions\r\n\r\nOption 1: raise an error in case of trying to use a `type=\"paths\"` option without an ini file.\r\n\r\nOption 1': same as 1 but only for relative paths, so absolute paths are OK.\r\n\r\nOption 2: use some other path instead if the inipath is not defined, most likely the current working directory/invocation path.\r\n\r\nSince this basically can only happen when using `-o` on the command line, I think Option 2 is sensible, but would be interested in other's opinion.\nI see: I made the wrong assumption that `PYTHONPATH=src pytest` and `pytest -o pythonpath=src` should *always* be equivalent, but from your discussion I undestand now that the second one has a different meaning!\r\n\r\nSo I would suggest option 1 in order to enforce the *override ini* meaning of `-o`\r\n\r\n## Brief explanation of the cognitive pitfall\r\n\r\nProbably I didn't read the docs with sufficent attention, but my error here was to assume that every variable in the pytest [configuration options](https://docs.pytest.org/en/7.4.x/reference/reference.html#configuration-options) *has* a default value, and thus *can* be overridden. But when a config file is missing, some variables are undefined, and there is no meaningful way to override them.\r\n\r\nAnother not so easy fact to undestand was that a `pyproject.toml` file defines the `self.inipath` only if it contains a possibly empty `[tool.pytest.ini_options]` table. I was confused from this fact, not being able to undestand why sometimes the `-o pythontpath=src` option didn't trigger an error.\r\n\r\nAs what regards option 2, I would therefore suggest to consider also the directory containing `pyproject.toml` etc. as the `self.inipath`, even if the file does not contain any pytest configuration.\n> As what regards option 2, I would therefore suggest to consider also the directory containing pyproject.toml etc. as the self.inipath, even if the file does not contain any pytest configuration.\r\n\r\nThis is actually a good point, because `pyproject.toml` is now the defacto standard to mean the root of a Python project.", "created_at": "2024-02-10T23:23:40Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11959, "instance_id": "pytest-dev__pytest-11959", "issue_numbers": ["11954"], "base_commit": "8e56795b770a3f56578b2d820c878e2af9803c30", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 25159b8b07f..dce91c4fe0e 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -127,6 +127,7 @@ Edison Gustavo Muenz\n Edoardo Batini\n Edson Tadeu M. Manoel\n Eduardo Schettino\n+Eero Vaher\n Eli Boyarski\n Elizaveta Shashkova\n \u00c9loi Rivard\ndiff --git a/changelog/10865.improvement.rst b/changelog/10865.improvement.rst\nindex 2c2856dfe96..a5ced8e9ae3 100644\n--- a/changelog/10865.improvement.rst\n+++ b/changelog/10865.improvement.rst\n@@ -1,2 +1,3 @@\n-:func:`pytest.warns` now validates that warning object's ``message`` is of type  `str` -- currently in Python it is possible to pass other types than `str` when creating `Warning` instances, however this causes an exception when :func:`warnings.filterwarnings` is used to filter those warnings. See `CPython #103577 <https://github.com/python/cpython/issues/103577>`__ for a discussion.\n+:func:`pytest.warns` now validates that :func:`warnings.warn` was called with a `str` or a `Warning`.\n+Currently in Python it is possible to use other types, however this causes an exception when :func:`warnings.filterwarnings` is used to filter those warnings (see `CPython #103577 <https://github.com/python/cpython/issues/103577>`__ for a discussion).\n While this can be considered a bug in CPython, we decided to put guards in pytest as the error message produced without this check in place is confusing.\n", "test_patch": "diff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\nindex ddb240eb2e7..9eced36ff53 100644\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -314,7 +314,7 @@ def __exit__(\n         ):\n             return\n \n-        def found_str():\n+        def found_str() -> str:\n             return pformat([record.message for record in self], indent=2)\n \n         try:\n@@ -341,14 +341,30 @@ def found_str():\n                         module=w.__module__,\n                         source=w.source,\n                     )\n-            # Check warnings has valid argument type (#10865).\n-            wrn: warnings.WarningMessage\n-            for wrn in self:\n-                self._validate_message(wrn)\n-\n-    @staticmethod\n-    def _validate_message(wrn: Any) -> None:\n-        if not isinstance(msg := wrn.message.args[0], str):\n-            raise TypeError(\n-                f\"Warning message must be str, got {msg!r} (type {type(msg).__name__})\"\n-            )\n+\n+            # Currently in Python it is possible to pass other types than an\n+            # `str` message when creating `Warning` instances, however this\n+            # causes an exception when :func:`warnings.filterwarnings` is used\n+            # to filter those warnings. See\n+            # https://github.com/python/cpython/issues/103577 for a discussion.\n+            # While this can be considered a bug in CPython, we put guards in\n+            # pytest as the error message produced without this check in place\n+            # is confusing (#10865).\n+            for w in self:\n+                if type(w.message) is not UserWarning:\n+                    # If the warning was of an incorrect type then `warnings.warn()`\n+                    # creates a UserWarning. Any other warning must have been specified\n+                    # explicitly.\n+                    continue\n+                if not w.message.args:\n+                    # UserWarning() without arguments must have been specified explicitly.\n+                    continue\n+                msg = w.message.args[0]\n+                if isinstance(msg, str):\n+                    continue\n+                # It's possible that UserWarning was explicitly specified, and\n+                # its first argument was not a string. But that case can't be\n+                # distinguished from an invalid type.\n+                raise TypeError(\n+                    f\"Warning must be str or Warning, got {msg!r} (type {type(msg).__name__})\"\n+                )\ndiff --git a/testing/test_recwarn.py b/testing/test_recwarn.py\nindex 1feb3e654d4..edd4f51b585 100644\n--- a/testing/test_recwarn.py\n+++ b/testing/test_recwarn.py\n@@ -3,6 +3,7 @@\n from typing import List\n from typing import Optional\n from typing import Type\n+from typing import Union\n import warnings\n \n import pytest\n@@ -546,24 +547,34 @@ def test_it():\n         result.assert_outcomes()\n \n \n-def test_raise_type_error_on_non_string_warning() -> None:\n-    \"\"\"Check pytest.warns validates warning messages are strings (#10865).\"\"\"\n-    with pytest.raises(TypeError, match=\"Warning message must be str\"):\n+def test_raise_type_error_on_invalid_warning() -> None:\n+    \"\"\"Check pytest.warns validates warning messages are strings (#10865) or\n+    Warning instances (#11959).\"\"\"\n+    with pytest.raises(TypeError, match=\"Warning must be str or Warning\"):\n         with pytest.warns(UserWarning):\n             warnings.warn(1)  # type: ignore\n \n \n-def test_no_raise_type_error_on_string_warning() -> None:\n-    \"\"\"Check pytest.warns validates warning messages are strings (#10865).\"\"\"\n-    with pytest.warns(UserWarning):\n-        warnings.warn(\"Warning\")\n+@pytest.mark.parametrize(\n+    \"message\",\n+    [\n+        pytest.param(\"Warning\", id=\"str\"),\n+        pytest.param(UserWarning(), id=\"UserWarning\"),\n+        pytest.param(Warning(), id=\"Warning\"),\n+    ],\n+)\n+def test_no_raise_type_error_on_valid_warning(message: Union[str, Warning]) -> None:\n+    \"\"\"Check pytest.warns validates warning messages are strings (#10865) or\n+    Warning instances (#11959).\"\"\"\n+    with pytest.warns(Warning):\n+        warnings.warn(message)\n \n \n @pytest.mark.skipif(\n     hasattr(sys, \"pypy_version_info\"),\n     reason=\"Not for pypy\",\n )\n-def test_raise_type_error_on_non_string_warning_cpython() -> None:\n+def test_raise_type_error_on_invalid_warning_message_cpython() -> None:\n     # Check that we get the same behavior with the stdlib, at least if filtering\n     # (see https://github.com/python/cpython/issues/103577 for details)\n     with pytest.raises(TypeError):\n", "problem_statement": "pytest 8.1.0.dev gives TypeError: Warning message must be str\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\nStarted noticing failures with `pytest 8.1.0.dev171+g9454fc38d`. I suspect it is caused by https://github.com/pytest-dev/pytest/pull/11804 .\r\n\r\nIn astropy , we have a warning class that is a grandchild of Python built-in `Warning` class, defined as follows (don't ask me why, I am just the messenger):\r\n\r\n```python\r\nclass IllegalMinuteWarning(AstropyWarning):\r\n    \"\"\"\r\n    Raised when a minute value is 60.\r\n\r\n    Parameters\r\n    ----------\r\n    minute : int, float\r\n    \"\"\"\r\n\r\n    def __init__(self, minute, alternativeactionstr=None):\r\n        self.minute = minute\r\n        self.alternativeactionstr = alternativeactionstr\r\n\r\n    def __str__(self):\r\n        message = (\r\n            f\"'minute' was found  to be '{self.minute}', which is not in range [0,60).\"\r\n        )\r\n        if self.alternativeactionstr is not None:\r\n            message += \" \" + self.alternativeactionstr\r\n        return message\r\n```\r\n\r\nWorks fine for years, until today. I think pytest type check is now too strict. Is this something you are able to relax a little on your end? Thanks!\r\n\r\nDetailed log and more info here:\r\n\r\n* https://github.com/astropy/astropy/issues/16016\n", "hints_text": "That warning class doesn't implement a expected invariants\n\nAKA it can't be used as category for a string message\n\nI suppose it works by accident\n\nIf bug compatibility is easy enough we should support this while warning \nI'd agree that not accepting a `Warning` as reported in #11959 looks like a bug, but for numerical inputs this makes more sense, and would be fairly easy to fix on the Astropy side.", "created_at": "2024-02-09T21:06:40Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11957, "instance_id": "pytest-dev__pytest-11957", "issue_numbers": ["11937"], "base_commit": "9454fc38d3636b79ee657d6cacf7477eb8acee52", "patch": "diff --git a/changelog/11937.bugfix.rst b/changelog/11937.bugfix.rst\nnew file mode 100644\nindex 00000000000..3b15fb528e9\n--- /dev/null\n+++ b/changelog/11937.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.0.0 whereby items would be collected in reverse order in some circumstances.\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex c9ef877d72e..5c70ad74e40 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -897,7 +897,7 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n \n                 # Prune this level.\n                 any_matched_in_collector = False\n-                for node in subnodes:\n+                for node in reversed(subnodes):\n                     # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.\n                     if isinstance(matchparts[0], Path):\n                         is_match = node.path == matchparts[0]\ndiff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\nindex 0264aa28856..e41d7a81fd9 100644\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -241,7 +241,7 @@ def test_issue88_initial_file_multinodes(self, pytester: Pytester) -> None:\n         pytester.copy_example(\"issue88_initial_file_multinodes\")\n         p = pytester.makepyfile(\"def test_hello(): pass\")\n         result = pytester.runpytest(p, \"--collect-only\")\n-        result.stdout.fnmatch_lines([\"*Module*test_issue88*\", \"*MyFile*test_issue88*\"])\n+        result.stdout.fnmatch_lines([\"*MyFile*test_issue88*\", \"*Module*test_issue88*\"])\n \n     def test_issue93_initialnode_importing_capturing(self, pytester: Pytester) -> None:\n         pytester.makeconftest(\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex 8e41e0fae78..ea8afc7c4de 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -592,12 +592,12 @@ def pytest_collect_file(file_path, parent):\n         hookrec.assert_contains(\n             [\n                 (\"pytest_collectstart\", \"collector.path == collector.session.path\"),\n-                (\"pytest_collectstart\", \"collector.__class__.__name__ == 'Module'\"),\n-                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                 (\n                     \"pytest_collectstart\",\n                     \"collector.__class__.__name__ == 'SpecialFile'\",\n                 ),\n+                (\"pytest_collectstart\", \"collector.__class__.__name__ == 'Module'\"),\n+                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                 (\"pytest_collectreport\", \"report.nodeid.startswith(p.name)\"),\n             ]\n         )\n@@ -671,6 +671,23 @@ def test_method(self):\n         # ensure we are reporting the collection of the single test item (#2464)\n         assert [x.name for x in self.get_reported_items(hookrec)] == [\"test_method\"]\n \n+    def test_collect_parametrized_order(self, pytester: Pytester) -> None:\n+        p = pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            @pytest.mark.parametrize('i', [0, 1, 2])\n+            def test_param(i): ...\n+            \"\"\"\n+        )\n+        items, hookrec = pytester.inline_genitems(f\"{p}::test_param\")\n+        assert len(items) == 3\n+        assert [item.nodeid for item in items] == [\n+            \"test_collect_parametrized_order.py::test_param[0]\",\n+            \"test_collect_parametrized_order.py::test_param[1]\",\n+            \"test_collect_parametrized_order.py::test_param[2]\",\n+        ]\n+\n \n class Test_getinitialnodes:\n     def test_global_file(self, pytester: Pytester) -> None:\n", "problem_statement": "8.0.0 reverses order of parametrize when calling individual tests \n**Summary**\r\nMarking a test with `@pytest.mark.parametrize('i', [1, 2, 3, 4])`, I expect the test to run 1, 2, 3, 4.\r\nAs a file, pytest does this as expected.\r\nRunning individual tests, though, results in 4, 3, 2, 1.\r\nThis is surprising behavior and new to 8.0.0.\r\n```\r\n(foo) $ pytest test_param.py::test_param -v\r\n...\r\nplatform win32 -- Python 3.11.7, pytest-8.0.0, ...\r\n...\r\ntest_param.py::test_param[4] PASSED                                      [ 25%]\r\ntest_param.py::test_param[3] PASSED                                      [ 50%]\r\ntest_param.py::test_param[2] PASSED                                      [ 75%]\r\ntest_param.py::test_param[1] PASSED                                      [100%]\r\n...\r\n```\r\n\r\nVersion 7.4.4 runs the test cases in the expected 1, 2, 3, 4 order.\r\n```\r\n(foo) $ pytest test_param.py::test_param -v\r\n...\r\nplatform win32 -- Python 3.11.7, pytest-7.4.4, ...\r\n...\r\ntest_param.py::test_param[1] PASSED                                      [ 25%]\r\ntest_param.py::test_param[2] PASSED                                      [ 50%]\r\ntest_param.py::test_param[3] PASSED                                      [ 75%]\r\ntest_param.py::test_param[4] PASSED                                      [100%]\r\n...\r\n```\r\n\r\n\r\n**Detail**\r\n- [x] a detailed description of the bug or problem you are having\r\nWhen running individual parametrized tests, the order is reversed. \r\nThis is new in 8.0.0, and not the case in 7.4.4\r\nSince 8.0.0 doesn't guarantee backward compatibility, I'm not sure if this is a bug or a feature. :)\r\nBut I didn't see it in the notes, so I'm guessing this is an unintended change, and it is an unexpected, surprising behavior.\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n\r\n```\r\n$ pip list\r\nPackage    Version\r\n---------- -------\r\ncolorama   0.4.6\r\niniconfig  2.0.0\r\npackaging  23.2\r\npip        23.3.1\r\npluggy     1.3.0\r\npytest     8.0.0\r\nsetuptools 65.5.0\r\n```\r\n\r\n- [x] pytest and operating system versions\r\n\r\nplatform win32 -- Python 3.11.7, pytest-8.0.0, pluggy-1.3.0\r\n\r\n- [x] minimal example if possible\r\n```\r\n$ cat test_param.py\r\nimport pytest\r\n\r\n@pytest.mark.parametrize('i', [1, 2, 3, 4])\r\ndef test_param(i):\r\n    ...\r\n```\r\n\r\n\r\nOutput from 8.0.0, shows expected 1,2,3,4 order with file invocation, but reverse order with individual test, 4, 3, 2, 1\r\n```\r\n(foo) $ pytest test_param.py -v\r\n============================= test session starts =============================\r\nplatform win32 -- Python 3.11.7, pytest-8.0.0, pluggy-1.3.0 -- C:\\Users\\okken\\projects\\foo\\venv\\Scripts\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\Users\\okken\\projects\\foo\r\nconfigfile: pytest.ini\r\ncollecting ... collected 4 items\r\n\r\ntest_param.py::test_param[1] PASSED                                      [ 25%]\r\ntest_param.py::test_param[2] PASSED                                      [ 50%]\r\ntest_param.py::test_param[3] PASSED                                      [ 75%]\r\ntest_param.py::test_param[4] PASSED                                      [100%]\r\n\r\n============================== 4 passed in 0.01s ==============================\r\n(foo) $ pytest test_param.py::test_param -v\r\n============================= test session starts =============================\r\nplatform win32 -- Python 3.11.7, pytest-8.0.0, pluggy-1.3.0 -- C:\\Users\\okken\\projects\\foo\\venv\\Scripts\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\Users\\okken\\projects\\foo\r\nconfigfile: pytest.ini\r\ncollecting ... collected 4 items\r\n\r\ntest_param.py::test_param[4] PASSED                                      [ 25%]\r\ntest_param.py::test_param[3] PASSED                                      [ 50%]\r\ntest_param.py::test_param[2] PASSED                                      [ 75%]\r\ntest_param.py::test_param[1] PASSED                                      [100%]\r\n\r\n============================== 4 passed in 0.02s ==============================\r\n```\r\n\r\n\r\nOutput from 7.4.4, shows expected 1,2,3,4 order with both file and individual test invocation.\r\n```\r\n(foo) $ pytest test_param.py -v\r\n============================= test session starts =============================\r\nplatform win32 -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0 -- C:\\Users\\okken\\projects\\foo\\venv\\Scripts\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\Users\\okken\\projects\\foo\r\nconfigfile: pytest.ini\r\ncollecting ... collected 4 items\r\n\r\ntest_param.py::test_param[1] PASSED                                      [ 25%]\r\ntest_param.py::test_param[2] PASSED                                      [ 50%]\r\ntest_param.py::test_param[3] PASSED                                      [ 75%]\r\ntest_param.py::test_param[4] PASSED                                      [100%]\r\n\r\n============================== 4 passed in 0.02s ==============================\r\n(foo) $ pytest test_param.py::test_param -v\r\n============================= test session starts =============================\r\nplatform win32 -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0 -- C:\\Users\\okken\\projects\\foo\\venv\\Scripts\\python.exe\r\ncachedir: .pytest_cache\r\nrootdir: C:\\Users\\okken\\projects\\foo\r\nconfigfile: pytest.ini\r\ncollecting ... collected 4 items\r\n\r\ntest_param.py::test_param[1] PASSED                                      [ 25%]\r\ntest_param.py::test_param[2] PASSED                                      [ 50%]\r\ntest_param.py::test_param[3] PASSED                                      [ 75%]\r\ntest_param.py::test_param[4] PASSED                                      [100%]\r\n\r\n============================== 4 passed in 0.00s ==============================\r\n```\r\n\n", "hints_text": "Bisected to 385796ba494e7ae65d55892d4a358b371ac7a6b6:\r\n\r\n- PR: #11646\r\n- Fix for #7777\r\n\r\ncc @bluetech ", "created_at": "2024-02-09T13:26:35Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11941, "instance_id": "pytest-dev__pytest-11941", "issue_numbers": ["11929"], "base_commit": "4c894f20a1df9229b871191972b48cac3d8a41d3", "patch": "diff --git a/changelog/11929.bugfix.rst b/changelog/11929.bugfix.rst\nnew file mode 100644\nindex 00000000000..8ab50e6f451\n--- /dev/null\n+++ b/changelog/11929.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.0.0 whereby autouse fixtures defined in a module get ignored by the doctests in the module.\n", "test_patch": "diff --git a/src/_pytest/doctest.py b/src/_pytest/doctest.py\nindex fdf84d3002c..8fe992b6a12 100644\n--- a/src/_pytest/doctest.py\n+++ b/src/_pytest/doctest.py\n@@ -40,7 +40,6 @@\n from _pytest.outcomes import OutcomeException\n from _pytest.outcomes import skip\n from _pytest.pathlib import fnmatch_ex\n-from _pytest.pathlib import import_path\n from _pytest.python import Module\n from _pytest.python_api import approx\n from _pytest.warning_types import PytestWarning\n@@ -107,7 +106,7 @@ def pytest_addoption(parser: Parser) -> None:\n         \"--doctest-ignore-import-errors\",\n         action=\"store_true\",\n         default=False,\n-        help=\"Ignore doctest ImportErrors\",\n+        help=\"Ignore doctest collection errors\",\n         dest=\"doctest_ignore_import_errors\",\n     )\n     group.addoption(\n@@ -561,17 +560,17 @@ def _from_module(self, module, object):\n                 pass\n \n         try:\n-            module = import_path(\n-                self.path,\n-                root=self.config.rootpath,\n-                mode=self.config.getoption(\"importmode\"),\n-            )\n-        except ImportError:\n+            module = self.obj\n+        except Collector.CollectError:\n             if self.config.getvalue(\"doctest_ignore_import_errors\"):\n                 skip(\"unable to import module %r\" % self.path)\n             else:\n                 raise\n \n+        # While doctests currently don't support fixtures directly, we still\n+        # need to pick up autouse fixtures.\n+        self.session._fixturemanager.parsefactories(self)\n+\n         # Uses internal doctest module parsing mechanism.\n         finder = MockAwareDocTestFinder()\n         optionflags = get_optionflags(self.config)\ndiff --git a/testing/test_doctest.py b/testing/test_doctest.py\nindex 3725284907a..c91ec31cd40 100644\n--- a/testing/test_doctest.py\n+++ b/testing/test_doctest.py\n@@ -1376,6 +1376,38 @@ def auto(request):\n         str(result.stdout.no_fnmatch_line(\"*FAILURES*\"))\n         result.stdout.fnmatch_lines([\"*=== 1 passed in *\"])\n \n+    @pytest.mark.parametrize(\"scope\", [*SCOPES, \"package\"])\n+    def test_auto_use_defined_in_same_module(\n+        self, pytester: Pytester, scope: str\n+    ) -> None:\n+        \"\"\"Autouse fixtures defined in the same module as the doctest get picked\n+        up properly.\n+\n+        Regression test for #11929.\n+        \"\"\"\n+        pytester.makepyfile(\n+            f\"\"\"\n+            import pytest\n+\n+            AUTO = \"the fixture did not run\"\n+\n+            @pytest.fixture(autouse=True, scope=\"{scope}\")\n+            def auto(request):\n+                global AUTO\n+                AUTO = \"the fixture ran\"\n+\n+            def my_doctest():\n+                '''My doctest.\n+\n+                >>> my_doctest()\n+                'the fixture ran'\n+                '''\n+                return AUTO\n+            \"\"\"\n+        )\n+        result = pytester.runpytest(\"--doctest-modules\")\n+        result.assert_outcomes(passed=1)\n+\n \n class TestDoctestNamespaceFixture:\n     SCOPES = [\"module\", \"session\", \"class\", \"function\"]\n", "problem_statement": "pytest 8.0.0 ignores autouse fixtures in doctest modules when collecting packages\npyspacewar has a test suite written back when I still thought doctest modules were neat.  It uses --doctest-modules and relies on some module-global setup/teardown specified in a `@pytest.fixture(autouse=True)`.\r\n\r\nThis [broke](https://github.com/mgedmin/pyspacewar/issues/19) with the pytest 8.0.0 release.  If I run\r\n\r\n    pytest src/pyspacewar/tests/ --setup-show\r\n\r\nI can see that the autouse fixtures defined in my conftest.py are being called, but the autouse fixture in [src/pyspacewar/tests/test_main.py](https://github.com/mgedmin/pyspacewar/blob/5bbae0d47876e614c15a180dc7d9cb8f1940a2c6/src/pyspacewar/tests/test_main.py#L47-L50) (fake_game_ui) is not.  This breaks the tests or makes them hang:\r\n\r\n    src/pyspacewar/tests/test_main.py \r\n            src/pyspacewar/tests/test_main.py::pyspacewar.tests.test_main.doctest_main (fixtures used: setUp)\r\n\r\nCuriously, if I run just a single file or all the test files in the directory, this doesn't happen:\r\n\r\n    pytest src/pyspacewar/tests/*.py --setup-show\r\n\r\nshows \r\n\r\n    ...\r\n    src/pyspacewar/tests/test_main.py \r\n        SETUP    M fake_game_ui\r\n            src/pyspacewar/tests/test_main.py::pyspacewar.tests.test_main.doctest_main (fixtures used: fake_game_ui, setUp).\r\n        TEARDOWN M fake_game_ui\r\n    ...\r\n\r\nwhich is also what pytest 7.4.4 used to do.\r\n\r\nI've verified by `pip install \"pytest<8\"` and `pip install -U pytest` that pytest being 7.4.4 vs 8.0.0 is the only difference between a working and a not-working tox environment.  A full pip list is here:\r\n\r\n```\r\nPackage    Version\r\n---------- ----------\r\niniconfig  2.0.0\r\nmock       5.1.0\r\npackaging  23.2\r\npip        23.2.1\r\npluggy     1.4.0\r\npygame     2.5.2\r\npyspacewar 1.2.0.dev0\r\npytest     8.0.0\r\n```\r\n\r\nOS: Ubuntu 23.10.\r\n\r\nI have not yet tried to produce a separate minimal example, but you should be able to quickly reproduce this if you\r\n\r\n    git clone https://github.com/mgedmin/pyspacewar\r\n    tox -e py312 --notest\r\n    .tox/py312/bin/pip install -U pytest    # because I pinned to <8 as a workaround for now\r\n    .tox/py312/bin/pytest src/pyspacewar/tests/ --setup-show\r\n\n", "hints_text": "Thanks for the report. Bisected to ab63ebb3dc07b89670b96ae97044f48406c44fa0. Will check out what exactly is causing the issue.", "created_at": "2024-02-06T22:08:11Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11936, "instance_id": "pytest-dev__pytest-11936", "issue_numbers": ["11895"], "base_commit": "cefb3e2277b6ea24acc7b1088f80ef0f9e9f3858", "patch": "diff --git a/changelog/11895.bugfix.rst b/changelog/11895.bugfix.rst\nnew file mode 100644\nindex 00000000000..4211213c1e5\n--- /dev/null\n+++ b/changelog/11895.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix collection on Windows where initial paths contain the short version of a path (for example ``c:\\PROGRA~1\\tests``).\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 5c70ad74e40..edb1a69e2b7 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -901,6 +901,10 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n                     # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.\n                     if isinstance(matchparts[0], Path):\n                         is_match = node.path == matchparts[0]\n+                        if sys.platform == \"win32\" and not is_match:\n+                            # In case the file paths do not match, fallback to samefile() to\n+                            # account for short-paths on Windows (#11895).\n+                            is_match = os.path.samefile(node.path, matchparts[0])\n                     # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.\n                     else:\n                         # TODO: Remove parametrized workaround once collection structure contains\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex 98cff8fe9a1..5cd9208f575 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -4,9 +4,11 @@\n import pprint\n import shutil\n import sys\n+import tempfile\n import textwrap\n from typing import List\n \n+from _pytest.assertion.util import running_on_ci\n from _pytest.config import ExitCode\n from _pytest.fixtures import FixtureRequest\n from _pytest.main import _in_venv\n@@ -1759,3 +1761,29 @@ def test_foo(): assert True\n \n     assert result.ret == ExitCode.OK\n     assert result.parseoutcomes() == {\"passed\": 1}\n+\n+\n+@pytest.mark.skipif(not sys.platform.startswith(\"win\"), reason=\"Windows only\")\n+def test_collect_short_file_windows(pytester: Pytester) -> None:\n+    \"\"\"Reproducer for #11895: short paths not colleced on Windows.\"\"\"\n+    short_path = tempfile.mkdtemp()\n+    if \"~\" not in short_path:  # pragma: no cover\n+        if running_on_ci():\n+            # On CI, we are expecting that under the current GitHub actions configuration,\n+            # tempfile.mkdtemp() is producing short paths, so we want to fail to prevent\n+            # this from silently changing without us noticing.\n+            pytest.fail(\n+                f\"tempfile.mkdtemp() failed to produce a short path on CI: {short_path}\"\n+            )\n+        else:\n+            # We want to skip failing this test locally in this situation because\n+            # depending on the local configuration tempfile.mkdtemp() might not produce a short path:\n+            # For example, user might have configured %TEMP% exactly to avoid generating short paths.\n+            pytest.skip(\n+                f\"tempfile.mkdtemp() failed to produce a short path: {short_path}, skipping\"\n+            )\n+\n+    test_file = Path(short_path).joinpath(\"test_collect_short_file_windows.py\")\n+    test_file.write_text(\"def test(): pass\", encoding=\"UTF-8\")\n+    result = pytester.runpytest(short_path)\n+    assert result.parseoutcomes() == {\"passed\": 1}\n", "problem_statement": "Short paths in Windows seem to fail to be collected\nThis is an initial report of an issue I observed when updating xdoctest to support pytest 8.0. \r\n\r\nWhat I found is that when I ran a test effectivly using the invocation:\r\n\r\n```\r\nC:\\hostedtoolcache\\windows\\Python\\3.12.1\\x64\\python.exe -m pytest C:\\Users\\RUNNER~1\\AppData\\Local\\Temp\\tmpcttcs8zz\r\n```\r\n\r\nPytest would collect 0 tests even though there was a python file with a test in that directory. \r\n\r\nBy adding this code to convert the short path to a long path, the xdoctest failure went away, and things seem to be working now. \r\n\r\n```python\r\ndpath = tempfile.mkdtemp()\r\n# https://stackoverflow.com/questions/11420689/how-to-get-long-file-system-path-from-python-on-windows\r\nfrom ctypes import create_unicode_buffer, windll\r\nBUFFER_SIZE = 500\r\nbuffer = create_unicode_buffer(BUFFER_SIZE)\r\nget_long_path_name = windll.kernel32.GetLongPathNameW\r\nget_long_path_name(dpath, buffer, BUFFER_SIZE)\r\ndpath = buffer.value\r\n```\r\n\r\nI've documented more of the problem here https://github.com/Erotemic/xdoctest/issues/151\r\n\r\nI don't have a MWE as I don't have a windows machine, but I'm reasonably confident that something in pytest 8 broke short path recognition on windows. I'll leave it to other devs to test further.\r\n\r\n\n", "hints_text": "Thanks for the report.\r\n\r\n> I don't have a MWE as I don't have a windows machine, but I'm reasonably confident that something in pytest 8 broke short path recognition on windows. I'll leave it to other devs to test further.\r\n\r\nIn order to narrow down on the issue, we'll probably need to bisect. I don't have windows either, but I can try with Wine. Can you provide instructions for reproducing the CI failure locally? (Doesn't have to be minimal).\nI think this should work to reproduce it. On a window machine:\r\n\r\n* clone the latest version of xdoctest: https://github.com/Erotemic/xdoctest/tree/v1.1.3\r\n\r\n* `pip install -e .` to install it in development mode\r\n\r\n* Apply the following patch to remove the workaround I added to convert short paths into long paths: \r\n\r\n```diff\r\ndiff --git a/src/xdoctest/utils/util_path.py b/src/xdoctest/utils/util_path.py\r\nindex d49b371..83a0230 100644\r\n--- a/src/xdoctest/utils/util_path.py\r\n+++ b/src/xdoctest/utils/util_path.py\r\n@@ -34,19 +34,8 @@ class TempDir(object):\r\n \r\n     def ensure(self):\r\n         import tempfile\r\n-        import sys\r\n         if not self.dpath:\r\n             dpath = tempfile.mkdtemp()\r\n-            if sys.platform.startswith('win32'):\r\n-                # Force a long path\r\n-                # References:\r\n-                # https://stackoverflow.com/questions/11420689/how-to-get-long-file-system-path-from-python-on-windows\r\n-                from ctypes import create_unicode_buffer, windll\r\n-                BUFFER_SIZE = 500\r\n-                buffer = create_unicode_buffer(BUFFER_SIZE)\r\n-                get_long_path_name = windll.kernel32.GetLongPathNameW\r\n-                get_long_path_name(dpath, buffer, BUFFER_SIZE)\r\n-                dpath = buffer.value\r\n             self.dpath = dpath\r\n         return self.dpath\r\n```\r\n\r\n* install the version of pytest you want to test\r\n\r\n* Run the tests that cause the error (relative to the xdoctest repo root):\r\n\r\n```\r\npytest tests/test_pytest_cli.py -k test_simple_pytest_import_error_cli -s\r\npytest tests/test_pytest_cli.py -k test_simple_pytest_cli -s\r\n```\r\n \r\n\r\nYou can likely make this much more minimal by using `tempfile.mkdtemp()` to make a directory, record the path that it returns (on the actions CLI it was a short path, so I expect it will be the same on a different machine). Then write a small test file that pytest should pickup to that directory and then run `pytest <path>` to that directory. That is effectively what the above xdoctest instructions are doing. \n> You can likely make this much more minimal by using tempfile.mkdtemp() to make a directory, record the path that it returns (on the actions CLI it was a short path, so I expect it will be the same on a different machine). Then write a small test file that pytest should pickup to that directory and then run pytest <path> to that directory. That is effectively what the above xdoctest instructions are doing.\r\n\r\nI did not investigate into details, but I cannot reproduce the behavior using a very short path:\r\n\r\n```\r\n\u03bb pwd\r\nW:\\\r\n\r\n\u03bb cat a\\test_foo.py\r\ndef test(): pass\r\n\r\n\u03bb pytest w:\\a\r\n======================== test session starts ========================\r\nplatform win32 -- Python 3.10.9, pytest-8.0.0, pluggy-1.4.0\r\nrootdir: w:\\a\r\ncollected 1 item\r\n\r\na\\test_foo.py .                                                [100%]\r\n\r\n========================= 1 passed in 0.00s =========================\r\n\r\n\u03bb pytest a\r\n======================== test session starts ========================\r\nplatform win32 -- Python 3.10.9, pytest-8.0.0, pluggy-1.4.0\r\nrootdir: W:\\a\r\ncollected 1 item\r\n\r\na\\test_foo.py .                                                [100%]\r\n\r\n========================= 1 passed in 0.00s =========================\r\n```\r\n\r\nI'm afraid we will need more details to reproduce the issue.\nThere's a misunderstanding on what I mean by \"short path\". It's not a path with a short length, it's a windows shorthand to refer to a real path that's longer. It's like an autocomlete. E.g.\r\n\r\n`c:\\PROGRA~2\\Android\\ANDROI~1` resolves to `c:\\Program Files (x86)\\Android\\android-sdk` \r\n\r\nReference: https://superuser.com/questions/348079/how-can-i-find-the-short-path-of-a-windows-directory-file\r\n\r\nIt's a silly feature, but it seems `tempfile.mkdtemp` is able to return one, so it probably makes sense to support it.\r\n\nAhh of course, brain fart on my part.\r\n\r\nI can reproduce the issue:\r\n\r\n```\r\n(.env310) \u03bb dir c:\\PORTAB~1\\test\\ /b\r\ntest_foo.py\r\n__pycache__\r\n```\r\n\r\n```python\r\n>>> from pathlib import Path\r\n>>> p=Path(r'c:\\PORTAB~1\\test')\r\n>>> p.is_dir()\r\nTrue\r\n>>> (p / \"test_foo.py\").is_file()\r\nTrue\r\n>>>\r\n```\r\n\r\n```\r\n\u03bb pytest c:\\PORTAB~1\\test\\\r\n======================== test session starts ========================\r\nplatform win32 -- Python 3.10.10, pytest-8.1.0.dev108+gca3790102, pluggy-1.4.0\r\nrootdir: e:\\projects\\pytest\r\nplugins: hypothesis-6.84.0, replay-1.4.0\r\ncollected 0 items\r\n\r\n======================= no tests ran in 0.02s =======================\r\nERROR: not found: c:\\PORTAB~1\\test\r\n(no match in any of [<Dir >])\r\n```\r\n\r\nI will investigate this when I find some time, thanks for the report!\nI'm surprised this ever worked. Windows paths - the gift that keeps on giving :)", "created_at": "2024-02-05T21:16:02Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11920, "instance_id": "pytest-dev__pytest-11920", "issue_numbers": ["11907"], "base_commit": "5d7a5a9343ec7d675a9599312f8055e2a81cc1db", "patch": "diff --git a/changelog/11907.bugfix.rst b/changelog/11907.bugfix.rst\nnew file mode 100644\nindex 00000000000..10aa39aeb0c\n--- /dev/null\n+++ b/changelog/11907.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix a regression in pytest 8.0.0 whereby calling :func:`pytest.skip` and similar control-flow exceptions within a :func:`pytest.warns()` block would get suppressed instead of propagating.\n", "test_patch": "diff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\nindex 62df274bd37..ddb240eb2e7 100644\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -20,6 +20,7 @@\n \n from _pytest.deprecated import check_ispytest\n from _pytest.fixtures import fixture\n+from _pytest.outcomes import Exit\n from _pytest.outcomes import fail\n \n \n@@ -302,6 +303,17 @@ def __exit__(\n \n         __tracebackhide__ = True\n \n+        # BaseExceptions like pytest.{skip,fail,xfail,exit} or Ctrl-C within\n+        # pytest.warns should *not* trigger \"DID NOT WARN\" and get suppressed\n+        # when the warning doesn't happen. Control-flow exceptions should always\n+        # propagate.\n+        if exc_val is not None and (\n+            not isinstance(exc_val, Exception)\n+            # Exit is an Exception, not a BaseException, for some reason.\n+            or isinstance(exc_val, Exit)\n+        ):\n+            return\n+\n         def found_str():\n             return pformat([record.message for record in self], indent=2)\n \ndiff --git a/testing/test_recwarn.py b/testing/test_recwarn.py\nindex e269bd7ddc9..1feb3e654d4 100644\n--- a/testing/test_recwarn.py\n+++ b/testing/test_recwarn.py\n@@ -5,9 +5,10 @@\n from typing import Type\n import warnings\n \n-from _pytest.pytester import Pytester\n-from _pytest.recwarn import WarningsRecorder\n import pytest\n+from pytest import ExitCode\n+from pytest import Pytester\n+from pytest import WarningsRecorder\n \n \n def test_recwarn_stacklevel(recwarn: WarningsRecorder) -> None:\n@@ -479,6 +480,71 @@ def test_catch_warning_within_raise(self) -> None:\n                 warnings.warn(\"some warning\", category=FutureWarning)\n                 raise ValueError(\"some exception\")\n \n+    def test_skip_within_warns(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #11907.\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_it():\n+                with pytest.warns(Warning):\n+                    pytest.skip(\"this is OK\")\n+            \"\"\",\n+        )\n+\n+        result = pytester.runpytest()\n+        assert result.ret == ExitCode.OK\n+        result.assert_outcomes(skipped=1)\n+\n+    def test_fail_within_warns(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #11907.\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_it():\n+                with pytest.warns(Warning):\n+                    pytest.fail(\"BOOM\")\n+            \"\"\",\n+        )\n+\n+        result = pytester.runpytest()\n+        assert result.ret == ExitCode.TESTS_FAILED\n+        result.assert_outcomes(failed=1)\n+        assert \"DID NOT WARN\" not in str(result.stdout)\n+\n+    def test_exit_within_warns(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #11907.\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_it():\n+                with pytest.warns(Warning):\n+                    pytest.exit()\n+            \"\"\",\n+        )\n+\n+        result = pytester.runpytest()\n+        assert result.ret == ExitCode.INTERRUPTED\n+        result.assert_outcomes()\n+\n+    def test_keyboard_interrupt_within_warns(self, pytester: Pytester) -> None:\n+        \"\"\"Regression test for #11907.\"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_it():\n+                with pytest.warns(Warning):\n+                    raise KeyboardInterrupt()\n+            \"\"\",\n+        )\n+\n+        result = pytester.runpytest_subprocess()\n+        assert result.ret == ExitCode.INTERRUPTED\n+        result.assert_outcomes()\n+\n \n def test_raise_type_error_on_non_string_warning() -> None:\n     \"\"\"Check pytest.warns validates warning messages are strings (#10865).\"\"\"\n", "problem_statement": "`pytest.warns()` asserts when `pytest.skip()` is called\nWhen `pytest.skip()` is used inside `pytest.warns()` (and no warning is emitted), the test fails. I'm not sure if this is intentional but it feels a bit off, given that the test would normally be skipped instead. I've hit this in the wild in [urllib3](https://github.com/urllib3/urllib3/)'s test suite.\r\n\r\nQuick reproducer:\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\ndef test_foo():\r\n    with pytest.warns(UserWarning):\r\n        pytest.skip(\"skipping\")\r\n```\r\n\r\nYields:\r\n\r\n```pytb\r\n$ python -m pytest\r\n========================================================= test session starts =========================================================\r\nplatform linux -- Python 3.11.7, pytest-8.1.0.dev116+g4546d5445, pluggy-1.4.0\r\nrootdir: /tmp/test\r\ncollected 1 item                                                                                                                      \r\n\r\ntest_foo.py F                                                                                                                   [100%]\r\n\r\n============================================================== FAILURES ===============================================================\r\n______________________________________________________________ test_foo _______________________________________________________________\r\n\r\n    def test_foo():\r\n        with pytest.warns(UserWarning):\r\n>           pytest.skip(\"skipping\")\r\nE           Skipped: skipping\r\n\r\ntest_foo.py:6: Skipped\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\n    def test_foo():\r\n>       with pytest.warns(UserWarning):\r\nE       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.\r\nE        Emitted warnings: [].\r\n\r\ntest_foo.py:5: Failed\r\n======================================================= short test summary info =======================================================\r\nFAILED test_foo.py::test_foo - Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.\r\n========================================================== 1 failed in 0.02s ==========================================================\r\n```\r\n\r\npip list:\r\n\r\n```\r\nPackage    Version\r\n---------- -----------------------\r\niniconfig  2.0.0\r\npackaging  23.2\r\npip        23.3.2\r\npluggy     1.4.0\r\npytest     8.1.0.dev116+g4546d5445\r\nsetuptools 69.0.3\r\n```\r\n\r\n------\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\n\n", "hints_text": "Hmm this is from 15524f34d2aa8a0b311ea1ce735d9b6b471b8018. One might argue that the test should indeed fail because it actually did not warn, but I'd say the previous behavior is the more expected one. Probably pytest exceptions (fail, skip, xfail, exit) need to be special-cased here.\r\n\r\ncc @Cheukting @Zac-HD \nI agree that we should add a special case for these exceptions.", "created_at": "2024-02-04T21:14:51Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11896, "instance_id": "pytest-dev__pytest-11896", "issue_numbers": ["11885"], "base_commit": "407d9841428f037e0ada71f7ca028f7d1171c6db", "patch": "diff --git a/.gitblameignore b/.git-blame-ignore-revs\nsimilarity index 88%\nrename from .gitblameignore\nrename to .git-blame-ignore-revs\nindex 0cb298b024d..249ce70226f 100644\n--- a/.gitblameignore\n+++ b/.git-blame-ignore-revs\n@@ -26,3 +26,6 @@ afc607cfd81458d4e4f3b1f3cf8cc931b933907e\n \n # move argument parser to own file\n c9df77cbd6a365dcb73c39618e4842711817e871\n+\n+# Replace reorder-python-imports by isort due to black incompatibility (#11896)\n+8b54596639f41dfac070030ef20394b9001fe63c\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nindex 26ca339b961..244fe48e052 100644\n--- a/.pre-commit-config.yaml\n+++ b/.pre-commit-config.yaml\n@@ -1,6 +1,6 @@\n repos:\n -   repo: https://github.com/psf/black\n-    rev: 23.12.1\n+    rev: 24.1.1\n     hooks:\n     -   id: black\n         args: [--safe, --quiet]\n@@ -36,11 +36,12 @@ repos:\n         additional_dependencies:\n           - flake8-typing-imports==1.12.0\n           - flake8-docstrings==1.5.0\n--   repo: https://github.com/asottile/reorder-python-imports\n-    rev: v3.12.0\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.13.2\n     hooks:\n-    -   id: reorder-python-imports\n-        args: ['--application-directories=.:src', --py38-plus]\n+      - id: isort\n+        name: isort\n+        args: [--force-single-line, --profile=black]\n -   repo: https://github.com/asottile/pyupgrade\n     rev: v3.15.0\n     hooks:\ndiff --git a/bench/bench.py b/bench/bench.py\nindex c40fc8636c0..c314b4f56bf 100644\n--- a/bench/bench.py\n+++ b/bench/bench.py\n@@ -2,9 +2,10 @@\n \n if __name__ == \"__main__\":\n     import cProfile\n-    import pytest  # NOQA\n     import pstats\n \n+    import pytest  # NOQA\n+\n     script = sys.argv[1:] if len(sys.argv) > 1 else [\"empty.py\"]\n     cProfile.run(\"pytest.cmdline.main(%r)\" % script, \"prof\")\n     p = pstats.Stats(\"prof\")\ndiff --git a/doc/en/conf.py b/doc/en/conf.py\nindex 2bc18be5828..bb5737d7a57 100644\n--- a/doc/en/conf.py\n+++ b/doc/en/conf.py\n@@ -440,9 +440,10 @@\n \n def configure_logging(app: \"sphinx.application.Sphinx\") -> None:\n     \"\"\"Configure Sphinx's WarningHandler to handle (expected) missing include.\"\"\"\n-    import sphinx.util.logging\n     import logging\n \n+    import sphinx.util.logging\n+\n     class WarnLogFilter(logging.Filter):\n         def filter(self, record: logging.LogRecord) -> bool:\n             \"\"\"Ignore warnings about missing include with \"only\" directive.\ndiff --git a/doc/en/example/multipython.py b/doc/en/example/multipython.py\nindex 8d76ed483e8..1354cb37c45 100644\n--- a/doc/en/example/multipython.py\n+++ b/doc/en/example/multipython.py\n@@ -1,12 +1,12 @@\n \"\"\"Module containing a parametrized tests testing cross-python serialization\n via the pickle module.\"\"\"\n+\n import shutil\n import subprocess\n import textwrap\n \n import pytest\n \n-\n pythonlist = [\"python3.9\", \"python3.10\", \"python3.11\"]\n \n \ndiff --git a/scripts/update-plugin-list.py b/scripts/update-plugin-list.py\nindex 0f811b778ed..287073f576e 100644\n--- a/scripts/update-plugin-list.py\n+++ b/scripts/update-plugin-list.py\n@@ -19,7 +19,6 @@\n from requests_cache import SQLiteCache\n from tqdm import tqdm\n \n-\n FILE_HEAD = r\"\"\"\n .. Note this file is autogenerated by scripts/update-plugin-list.py - usually weekly via github action\n \ndiff --git a/tox.ini b/tox.ini\nindex e4ad300a932..b5c28029fc8 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -200,6 +200,8 @@ extend-ignore =\n     D302\n     ; Docstring Content Issues\n     D400,D401,D401,D402,D405,D406,D407,D408,D409,D410,D411,D412,D413,D414,D415,D416,D417\n+    ; Unused imports\n+    F401\n \n \n [isort]\n", "test_patch": "diff --git a/src/_pytest/__init__.py b/src/_pytest/__init__.py\nindex 8a406c5c751..9062768eae3 100644\n--- a/src/_pytest/__init__.py\n+++ b/src/_pytest/__init__.py\n@@ -1,7 +1,8 @@\n __all__ = [\"__version__\", \"version_tuple\"]\n \n try:\n-    from ._version import version as __version__, version_tuple\n+    from ._version import version as __version__\n+    from ._version import version_tuple\n except ImportError:  # pragma: no cover\n     # broken installation, we don't even try\n     # unknown only works because we do poor mans version compare\ndiff --git a/src/_pytest/_argcomplete.py b/src/_pytest/_argcomplete.py\nindex 6a8083770ae..c2ec1797fbc 100644\n--- a/src/_pytest/_argcomplete.py\n+++ b/src/_pytest/_argcomplete.py\n@@ -61,6 +61,7 @@\n   which should throw a KeyError: 'COMPLINE' (which is properly set by the\n   global argcomplete script).\n \"\"\"\n+\n import argparse\n import os\n import sys\ndiff --git a/src/_pytest/_code/__init__.py b/src/_pytest/_code/__init__.py\nindex 511d0dde661..f82c3d2b030 100644\n--- a/src/_pytest/_code/__init__.py\n+++ b/src/_pytest/_code/__init__.py\n@@ -1,4 +1,5 @@\n \"\"\"Python inspection/code generation API.\"\"\"\n+\n from .code import Code\n from .code import ExceptionInfo\n from .code import filter_traceback\ndiff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex 39bbc3c140a..8b38a8e7835 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -278,9 +278,9 @@ def ishidden(self, excinfo: Optional[\"ExceptionInfo[BaseException]\"]) -> bool:\n \n         Mostly for internal use.\n         \"\"\"\n-        tbh: Union[\n-            bool, Callable[[Optional[ExceptionInfo[BaseException]]], bool]\n-        ] = False\n+        tbh: Union[bool, Callable[[Optional[ExceptionInfo[BaseException]]], bool]] = (\n+            False\n+        )\n         for maybe_ns_dct in (self.frame.f_locals, self.frame.f_globals):\n             # in normal cases, f_locals and f_globals are dictionaries\n             # however via `exec(...)` / `eval(...)` they can be other types\n@@ -377,12 +377,10 @@ def cut(\n         return self\n \n     @overload\n-    def __getitem__(self, key: \"SupportsIndex\") -> TracebackEntry:\n-        ...\n+    def __getitem__(self, key: \"SupportsIndex\") -> TracebackEntry: ...\n \n     @overload\n-    def __getitem__(self, key: slice) -> \"Traceback\":\n-        ...\n+    def __getitem__(self, key: slice) -> \"Traceback\": ...\n \n     def __getitem__(\n         self, key: Union[\"SupportsIndex\", slice]\n@@ -1056,13 +1054,13 @@ def repr_excinfo(\n                 # full support for exception groups added to ExceptionInfo.\n                 # See https://github.com/pytest-dev/pytest/issues/9159\n                 if isinstance(e, BaseExceptionGroup):\n-                    reprtraceback: Union[\n-                        ReprTracebackNative, ReprTraceback\n-                    ] = ReprTracebackNative(\n-                        traceback.format_exception(\n-                            type(excinfo_.value),\n-                            excinfo_.value,\n-                            excinfo_.traceback[0]._rawentry,\n+                    reprtraceback: Union[ReprTracebackNative, ReprTraceback] = (\n+                        ReprTracebackNative(\n+                            traceback.format_exception(\n+                                type(excinfo_.value),\n+                                excinfo_.value,\n+                                excinfo_.traceback[0]._rawentry,\n+                            )\n                         )\n                     )\n                 else:\ndiff --git a/src/_pytest/_code/source.py b/src/_pytest/_code/source.py\nindex efee1fad3bf..a85b14371e2 100644\n--- a/src/_pytest/_code/source.py\n+++ b/src/_pytest/_code/source.py\n@@ -47,12 +47,10 @@ def __eq__(self, other: object) -> bool:\n     __hash__ = None  # type: ignore\n \n     @overload\n-    def __getitem__(self, key: int) -> str:\n-        ...\n+    def __getitem__(self, key: int) -> str: ...\n \n     @overload\n-    def __getitem__(self, key: slice) -> \"Source\":\n-        ...\n+    def __getitem__(self, key: slice) -> \"Source\": ...\n \n     def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:\n         if isinstance(key, int):\ndiff --git a/src/_pytest/_io/__init__.py b/src/_pytest/_io/__init__.py\nindex db001e918cb..a804cb549b4 100644\n--- a/src/_pytest/_io/__init__.py\n+++ b/src/_pytest/_io/__init__.py\n@@ -1,7 +1,6 @@\n from .terminalwriter import get_terminal_width\n from .terminalwriter import TerminalWriter\n \n-\n __all__ = [\n     \"TerminalWriter\",\n     \"get_terminal_width\",\ndiff --git a/src/_pytest/_io/terminalwriter.py b/src/_pytest/_io/terminalwriter.py\nindex 56107d56647..89221796aea 100644\n--- a/src/_pytest/_io/terminalwriter.py\n+++ b/src/_pytest/_io/terminalwriter.py\n@@ -1,4 +1,5 @@\n \"\"\"Helper functions for writing to terminals and files.\"\"\"\n+\n import os\n import shutil\n import sys\n@@ -10,7 +11,6 @@\n \n from .wcwidth import wcswidth\n \n-\n # This code was initially copied from py 1.8.1, file _io/terminalwriter.py.\n \n \n@@ -210,8 +210,8 @@ def _highlight(\n                 from pygments.lexers.python import PythonLexer as Lexer\n             elif lexer == \"diff\":\n                 from pygments.lexers.diff import DiffLexer as Lexer\n-            from pygments import highlight\n             import pygments.util\n+            from pygments import highlight\n         except ImportError:\n             return source\n         else:\ndiff --git a/src/_pytest/_py/error.py b/src/_pytest/_py/error.py\nindex 0b8f2d535ef..4b08d3b7a2e 100644\n--- a/src/_pytest/_py/error.py\n+++ b/src/_pytest/_py/error.py\n@@ -1,4 +1,5 @@\n \"\"\"create errno-specific classes for IO or os calls.\"\"\"\n+\n from __future__ import annotations\n \n import errno\ndiff --git a/src/_pytest/_py/path.py b/src/_pytest/_py/path.py\nindex 04b1695f174..44262a524ea 100644\n--- a/src/_pytest/_py/path.py\n+++ b/src/_pytest/_py/path.py\n@@ -204,12 +204,10 @@ class Stat:\n     if TYPE_CHECKING:\n \n         @property\n-        def size(self) -> int:\n-            ...\n+        def size(self) -> int: ...\n \n         @property\n-        def mtime(self) -> float:\n-            ...\n+        def mtime(self) -> float: ...\n \n     def __getattr__(self, name: str) -> Any:\n         return getattr(self._osstatresult, \"st_\" + name)\n@@ -962,12 +960,10 @@ def ensure(self, *args, **kwargs):\n             return p\n \n     @overload\n-    def stat(self, raising: Literal[True] = ...) -> Stat:\n-        ...\n+    def stat(self, raising: Literal[True] = ...) -> Stat: ...\n \n     @overload\n-    def stat(self, raising: Literal[False]) -> Stat | None:\n-        ...\n+    def stat(self, raising: Literal[False]) -> Stat | None: ...\n \n     def stat(self, raising: bool = True) -> Stat | None:\n         \"\"\"Return an os.stat() tuple.\"\"\"\n@@ -1168,7 +1164,8 @@ def sysexec(self, *argv: os.PathLike[str], **popen_opts: Any) -> str:\n         where the 'self' path points to executable.\n         The process is directly invoked and not through a system shell.\n         \"\"\"\n-        from subprocess import Popen, PIPE\n+        from subprocess import PIPE\n+        from subprocess import Popen\n \n         popen_opts.pop(\"stdout\", None)\n         popen_opts.pop(\"stderr\", None)\ndiff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 149101e716f..c24263e0663 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -1,4 +1,5 @@\n \"\"\"Rewrite assertion AST to produce nice error messages.\"\"\"\n+\n import ast\n import errno\n import functools\n@@ -33,15 +34,16 @@\n from _pytest._io.saferepr import saferepr\n from _pytest._version import version\n from _pytest.assertion import util\n-from _pytest.assertion.util import (  # noqa: F401\n-    format_explanation as _format_explanation,\n-)\n from _pytest.config import Config\n from _pytest.main import Session\n from _pytest.pathlib import absolutepath\n from _pytest.pathlib import fnmatch_ex\n from _pytest.stash import StashKey\n \n+# fmt: off\n+from _pytest.assertion.util import format_explanation as _format_explanation  # noqa:F401, isort:skip\n+# fmt:on\n+\n if TYPE_CHECKING:\n     from _pytest.assertion import AssertionState\n \n@@ -669,9 +671,9 @@ def __init__(\n             self.enable_assertion_pass_hook = False\n         self.source = source\n         self.scope: tuple[ast.AST, ...] = ()\n-        self.variables_overwrite: defaultdict[\n-            tuple[ast.AST, ...], Dict[str, str]\n-        ] = defaultdict(dict)\n+        self.variables_overwrite: defaultdict[tuple[ast.AST, ...], Dict[str, str]] = (\n+            defaultdict(dict)\n+        )\n \n     def run(self, mod: ast.Module) -> None:\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n@@ -858,9 +860,10 @@ def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n         the expression is false.\n         \"\"\"\n         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n-            from _pytest.warning_types import PytestAssertRewriteWarning\n             import warnings\n \n+            from _pytest.warning_types import PytestAssertRewriteWarning\n+\n             # TODO: This assert should not be needed.\n             assert self.module_path is not None\n             warnings.warn_explicit(\ndiff --git a/src/_pytest/assertion/truncate.py b/src/_pytest/assertion/truncate.py\nindex 16de27f256e..1e586567240 100644\n--- a/src/_pytest/assertion/truncate.py\n+++ b/src/_pytest/assertion/truncate.py\n@@ -3,6 +3,7 @@\n Current default behaviour is to truncate assertion explanations at\n terminal lines, unless running with an assertions verbosity level of at least 2 or running on CI.\n \"\"\"\n+\n from typing import List\n from typing import Optional\n \n@@ -10,7 +11,6 @@\n from _pytest.config import Config\n from _pytest.nodes import Item\n \n-\n DEFAULT_MAX_LINES = 8\n DEFAULT_MAX_CHARS = 8 * 80\n USAGE_MSG = \"use '-vv' to show\"\ndiff --git a/src/_pytest/cacheprovider.py b/src/_pytest/cacheprovider.py\nindex ee68cc38c79..87ef38b5e43 100755\n--- a/src/_pytest/cacheprovider.py\n+++ b/src/_pytest/cacheprovider.py\n@@ -112,6 +112,7 @@ def warn(self, fmt: str, *, _ispytest: bool = False, **args: object) -> None:\n         \"\"\"\n         check_ispytest(_ispytest)\n         import warnings\n+\n         from _pytest.warning_types import PytestCacheWarning\n \n         warnings.warn(\ndiff --git a/src/_pytest/compat.py b/src/_pytest/compat.py\nindex ad8558b1f51..821b422f39f 100644\n--- a/src/_pytest/compat.py\n+++ b/src/_pytest/compat.py\n@@ -17,7 +17,6 @@\n from typing import NoReturn\n from typing import TypeVar\n \n-\n _T = TypeVar(\"_T\")\n _S = TypeVar(\"_S\")\n \ndiff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex c0e1e195f0d..7bab69b7abf 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -66,9 +66,10 @@\n from _pytest.warning_types import warn_explicit_for\n \n if TYPE_CHECKING:\n+    from .argparsing import Argument\n+    from .argparsing import Parser\n     from _pytest._code.code import _TracebackStyle\n     from _pytest.terminal import TerminalReporter\n-    from .argparsing import Argument, Parser\n \n \n _PluggyPlugin = object\n@@ -973,7 +974,8 @@ def __init__(\n         *,\n         invocation_params: Optional[InvocationParams] = None,\n     ) -> None:\n-        from .argparsing import Parser, FILE_OR_DIR\n+        from .argparsing import FILE_OR_DIR\n+        from .argparsing import Parser\n \n         if invocation_params is None:\n             invocation_params = self.InvocationParams(\n@@ -1390,8 +1392,9 @@ def _validate_plugins(self) -> None:\n             return\n \n         # Imported lazily to improve start-up time.\n+        from packaging.requirements import InvalidRequirement\n+        from packaging.requirements import Requirement\n         from packaging.version import Version\n-        from packaging.requirements import InvalidRequirement, Requirement\n \n         plugin_info = self.pluginmanager.list_plugin_distinfo()\n         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\ndiff --git a/src/_pytest/deprecated.py b/src/_pytest/deprecated.py\nindex 1bc2cf57e80..0f611aa5ce4 100644\n--- a/src/_pytest/deprecated.py\n+++ b/src/_pytest/deprecated.py\n@@ -8,6 +8,7 @@\n :class:`PytestWarning`, or :class:`UnformattedWarning`\n in case of warnings which need to format their messages.\n \"\"\"\n+\n from warnings import warn\n \n from _pytest.warning_types import PytestDeprecationWarning\ndiff --git a/src/_pytest/faulthandler.py b/src/_pytest/faulthandler.py\nindex 1bccd18c636..824aec58eea 100644\n--- a/src/_pytest/faulthandler.py\n+++ b/src/_pytest/faulthandler.py\n@@ -8,7 +8,6 @@\n from _pytest.nodes import Item\n from _pytest.stash import StashKey\n \n-\n fault_handler_original_stderr_fd_key = StashKey[int]()\n fault_handler_stderr_fd_key = StashKey[int]()\n \ndiff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex d7d8a720bc5..7000cdab82d 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -67,7 +67,6 @@\n from _pytest.scope import HIGH_SCOPES\n from _pytest.scope import Scope\n \n-\n if TYPE_CHECKING:\n     from typing import Deque\n \n@@ -1231,8 +1230,7 @@ def fixture(\n         Union[Sequence[Optional[object]], Callable[[Any], Optional[object]]]\n     ] = ...,\n     name: Optional[str] = ...,\n-) -> FixtureFunction:\n-    ...\n+) -> FixtureFunction: ...\n \n \n @overload\n@@ -1246,8 +1244,7 @@ def fixture(  # noqa: F811\n         Union[Sequence[Optional[object]], Callable[[Any], Optional[object]]]\n     ] = ...,\n     name: Optional[str] = None,\n-) -> FixtureFunctionMarker:\n-    ...\n+) -> FixtureFunctionMarker: ...\n \n \n def fixture(  # noqa: F811\ndiff --git a/src/_pytest/freeze_support.py b/src/_pytest/freeze_support.py\nindex 9f8ea231fed..d028058e365 100644\n--- a/src/_pytest/freeze_support.py\n+++ b/src/_pytest/freeze_support.py\n@@ -1,5 +1,6 @@\n \"\"\"Provides a function to report all internal modules for using freezing\n tools.\"\"\"\n+\n import types\n from typing import Iterator\n from typing import List\ndiff --git a/src/_pytest/hookspec.py b/src/_pytest/hookspec.py\nindex 3c27dcf911a..0aace8c3493 100644\n--- a/src/_pytest/hookspec.py\n+++ b/src/_pytest/hookspec.py\n@@ -19,12 +19,12 @@\n     import warnings\n     from typing import Literal\n \n-    from _pytest._code.code import ExceptionRepr\n     from _pytest._code.code import ExceptionInfo\n+    from _pytest._code.code import ExceptionRepr\n+    from _pytest.config import _PluggyPlugin\n     from _pytest.config import Config\n     from _pytest.config import ExitCode\n     from _pytest.config import PytestPluginManager\n-    from _pytest.config import _PluggyPlugin\n     from _pytest.config.argparsing import Parser\n     from _pytest.fixtures import FixtureDef\n     from _pytest.fixtures import SubRequest\ndiff --git a/src/_pytest/junitxml.py b/src/_pytest/junitxml.py\nindex f01afd91578..a198e1d2363 100644\n--- a/src/_pytest/junitxml.py\n+++ b/src/_pytest/junitxml.py\n@@ -34,7 +34,6 @@\n from _pytest.stash import StashKey\n from _pytest.terminal import TerminalReporter\n \n-\n xml_key = StashKey[\"LogXML\"]()\n \n \ndiff --git a/src/_pytest/legacypath.py b/src/_pytest/legacypath.py\nindex cb9a3624392..5dafea402b3 100644\n--- a/src/_pytest/legacypath.py\n+++ b/src/_pytest/legacypath.py\n@@ -15,6 +15,7 @@\n from iniconfig import SectionWrapper\n \n import py\n+\n from _pytest.cacheprovider import Cache\n from _pytest.config import Config\n from _pytest.config import hookimpl\ndiff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex f7e47cece1e..a75e53a0cd7 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -1,4 +1,5 @@\n \"\"\"Core implementation of the testing process: init, session, runtest loop.\"\"\"\n+\n import argparse\n import dataclasses\n import fnmatch\n@@ -721,14 +722,12 @@ def _collect_path(\n     @overload\n     def perform_collect(\n         self, args: Optional[Sequence[str]] = ..., genitems: \"Literal[True]\" = ...\n-    ) -> Sequence[nodes.Item]:\n-        ...\n+    ) -> Sequence[nodes.Item]: ...\n \n     @overload\n     def perform_collect(  # noqa: F811\n         self, args: Optional[Sequence[str]] = ..., genitems: bool = ...\n-    ) -> Sequence[Union[nodes.Item, nodes.Collector]]:\n-        ...\n+    ) -> Sequence[Union[nodes.Item, nodes.Collector]]: ...\n \n     def perform_collect(  # noqa: F811\n         self, args: Optional[Sequence[str]] = None, genitems: bool = True\ndiff --git a/src/_pytest/mark/__init__.py b/src/_pytest/mark/__init__.py\nindex bcee802f3b1..ec5023c9173 100644\n--- a/src/_pytest/mark/__init__.py\n+++ b/src/_pytest/mark/__init__.py\n@@ -1,4 +1,5 @@\n \"\"\"Generic mechanism for marking and selecting python functions.\"\"\"\n+\n import dataclasses\n from typing import AbstractSet\n from typing import Collection\ndiff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex b995518bf92..5fa0ccaa7b5 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -14,6 +14,7 @@\n - ident evaluates to True of False according to a provided matcher function.\n - or/and/not evaluate according to the usual boolean semantics.\n \"\"\"\n+\n import ast\n import dataclasses\n import enum\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex e3580cf6fca..544e1dccf97 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -434,12 +434,10 @@ def store_mark(obj, mark: Mark) -> None:\n \n     class _SkipMarkDecorator(MarkDecorator):\n         @overload  # type: ignore[override,misc,no-overload-impl]\n-        def __call__(self, arg: Markable) -> Markable:\n-            ...\n+        def __call__(self, arg: Markable) -> Markable: ...\n \n         @overload\n-        def __call__(self, reason: str = ...) -> \"MarkDecorator\":\n-            ...\n+        def __call__(self, reason: str = ...) -> \"MarkDecorator\": ...\n \n     class _SkipifMarkDecorator(MarkDecorator):\n         def __call__(  # type: ignore[override]\n@@ -447,13 +445,11 @@ def __call__(  # type: ignore[override]\n             condition: Union[str, bool] = ...,\n             *conditions: Union[str, bool],\n             reason: str = ...,\n-        ) -> MarkDecorator:\n-            ...\n+        ) -> MarkDecorator: ...\n \n     class _XfailMarkDecorator(MarkDecorator):\n         @overload  # type: ignore[override,misc,no-overload-impl]\n-        def __call__(self, arg: Markable) -> Markable:\n-            ...\n+        def __call__(self, arg: Markable) -> Markable: ...\n \n         @overload\n         def __call__(\n@@ -466,8 +462,7 @@ def __call__(\n                 None, Type[BaseException], Tuple[Type[BaseException], ...]\n             ] = ...,\n             strict: bool = ...,\n-        ) -> MarkDecorator:\n-            ...\n+        ) -> MarkDecorator: ...\n \n     class _ParametrizeMarkDecorator(MarkDecorator):\n         def __call__(  # type: ignore[override]\n@@ -483,8 +478,7 @@ def __call__(  # type: ignore[override]\n                 ]\n             ] = ...,\n             scope: Optional[_ScopeName] = ...,\n-        ) -> MarkDecorator:\n-            ...\n+        ) -> MarkDecorator: ...\n \n     class _UsefixturesMarkDecorator(MarkDecorator):\n         def __call__(self, *fixtures: str) -> MarkDecorator:  # type: ignore[override]\ndiff --git a/src/_pytest/monkeypatch.py b/src/_pytest/monkeypatch.py\nindex 01c74d6eb43..7b678017f0f 100644\n--- a/src/_pytest/monkeypatch.py\n+++ b/src/_pytest/monkeypatch.py\n@@ -169,8 +169,7 @@ def setattr(\n         name: object,\n         value: Notset = ...,\n         raising: bool = ...,\n-    ) -> None:\n-        ...\n+    ) -> None: ...\n \n     @overload\n     def setattr(\n@@ -179,8 +178,7 @@ def setattr(\n         name: str,\n         value: object,\n         raising: bool = ...,\n-    ) -> None:\n-        ...\n+    ) -> None: ...\n \n     def setattr(\n         self,\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 2d6ad7b8fff..5260b003f84 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -41,8 +41,8 @@\n \n if TYPE_CHECKING:\n     # Imported here due to circular import.\n-    from _pytest.main import Session\n     from _pytest._code.code import _TracebackStyle\n+    from _pytest.main import Session\n \n \n SEP = \"/\"\n@@ -104,6 +104,7 @@ class Node(abc.ABC, metaclass=NodeMeta):\n     ``Collector``\\'s are the internal nodes of the tree, and ``Item``\\'s are the\n     leaf nodes.\n     \"\"\"\n+\n     # Use __slots__ to make attribute access faster.\n     # Note that __dict__ is still available.\n     __slots__ = (\n@@ -325,12 +326,10 @@ def iter_markers_with_node(\n                     yield node, mark\n \n     @overload\n-    def get_closest_marker(self, name: str) -> Optional[Mark]:\n-        ...\n+    def get_closest_marker(self, name: str) -> Optional[Mark]: ...\n \n     @overload\n-    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n-        ...\n+    def get_closest_marker(self, name: str, default: Mark) -> Mark: ...\n \n     def get_closest_marker(\n         self, name: str, default: Optional[Mark] = None\ndiff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 8710ba3e85d..eb51e7f7e87 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,5 +1,6 @@\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n+\n import sys\n from typing import Any\n from typing import Callable\ndiff --git a/src/_pytest/pastebin.py b/src/_pytest/pastebin.py\nindex 48470337468..440d6ec5f1f 100644\n--- a/src/_pytest/pastebin.py\n+++ b/src/_pytest/pastebin.py\n@@ -12,7 +12,6 @@\n from _pytest.stash import StashKey\n from _pytest.terminal import TerminalReporter\n \n-\n pastebinfile_key = StashKey[IO[bytes]]()\n \n \n@@ -74,8 +73,8 @@ def create_new_paste(contents: Union[str, bytes]) -> str:\n     :returns: URL to the pasted contents, or an error message.\n     \"\"\"\n     import re\n-    from urllib.request import urlopen\n     from urllib.parse import urlencode\n+    from urllib.request import urlopen\n \n     params = {\"code\": contents, \"lexer\": \"text\", \"expiry\": \"1week\"}\n     url = \"https://bpa.st\"\ndiff --git a/src/_pytest/pytester.py b/src/_pytest/pytester.py\nindex 69a24c7c90b..ae8709e5ed6 100644\n--- a/src/_pytest/pytester.py\n+++ b/src/_pytest/pytester.py\n@@ -244,8 +244,7 @@ def __repr__(self) -> str:\n \n     if TYPE_CHECKING:\n         # The class has undetermined attributes, this tells mypy about it.\n-        def __getattr__(self, key: str):\n-            ...\n+        def __getattr__(self, key: str): ...\n \n \n @final\n@@ -326,15 +325,13 @@ def getcall(self, name: str) -> RecordedHookCall:\n     def getreports(\n         self,\n         names: \"Literal['pytest_collectreport']\",\n-    ) -> Sequence[CollectReport]:\n-        ...\n+    ) -> Sequence[CollectReport]: ...\n \n     @overload\n     def getreports(\n         self,\n         names: \"Literal['pytest_runtest_logreport']\",\n-    ) -> Sequence[TestReport]:\n-        ...\n+    ) -> Sequence[TestReport]: ...\n \n     @overload\n     def getreports(\n@@ -343,8 +340,7 @@ def getreports(\n             \"pytest_collectreport\",\n             \"pytest_runtest_logreport\",\n         ),\n-    ) -> Sequence[Union[CollectReport, TestReport]]:\n-        ...\n+    ) -> Sequence[Union[CollectReport, TestReport]]: ...\n \n     def getreports(\n         self,\n@@ -391,15 +387,13 @@ def matchreport(\n     def getfailures(\n         self,\n         names: \"Literal['pytest_collectreport']\",\n-    ) -> Sequence[CollectReport]:\n-        ...\n+    ) -> Sequence[CollectReport]: ...\n \n     @overload\n     def getfailures(\n         self,\n         names: \"Literal['pytest_runtest_logreport']\",\n-    ) -> Sequence[TestReport]:\n-        ...\n+    ) -> Sequence[TestReport]: ...\n \n     @overload\n     def getfailures(\n@@ -408,8 +402,7 @@ def getfailures(\n             \"pytest_collectreport\",\n             \"pytest_runtest_logreport\",\n         ),\n-    ) -> Sequence[Union[CollectReport, TestReport]]:\n-        ...\n+    ) -> Sequence[Union[CollectReport, TestReport]]: ...\n \n     def getfailures(\n         self,\ndiff --git a/src/_pytest/pytester_assertions.py b/src/_pytest/pytester_assertions.py\nindex 657e4db5fc3..d20c2bb5999 100644\n--- a/src/_pytest/pytester_assertions.py\n+++ b/src/_pytest/pytester_assertions.py\n@@ -1,4 +1,5 @@\n \"\"\"Helper plugin for pytester; should not be loaded on its own.\"\"\"\n+\n # This plugin contains assertions used by pytester. pytester cannot\n # contain them itself, since it is imported by the `pytest` module,\n # hence cannot be subject to assertion rewriting, which requires a\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 5fa32260b78..d069d7038a6 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -81,7 +81,6 @@\n from _pytest.warning_types import PytestReturnNotNoneWarning\n from _pytest.warning_types import PytestUnhandledCoroutineWarning\n \n-\n _PYTEST_DIR = Path(_pytest.__file__).parent\n \n \n@@ -1793,9 +1792,11 @@ def _traceback_filter(self, excinfo: ExceptionInfo[BaseException]) -> Traceback:\n             if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                 if len(ntraceback) > 2:\n                     ntraceback = Traceback(\n-                        entry\n-                        if i == 0 or i == len(ntraceback) - 1\n-                        else entry.with_repr_style(\"short\")\n+                        (\n+                            entry\n+                            if i == 0 or i == len(ntraceback) - 1\n+                            else entry.with_repr_style(\"short\")\n+                        )\n                         for i, entry in enumerate(ntraceback)\n                     )\n \ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex c32d75b44b7..f398902ffe0 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -779,8 +779,7 @@ def raises(\n     expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n     *,\n     match: Optional[Union[str, Pattern[str]]] = ...,\n-) -> \"RaisesContext[E]\":\n-    ...\n+) -> \"RaisesContext[E]\": ...\n \n \n @overload\n@@ -789,8 +788,7 @@ def raises(  # noqa: F811\n     func: Callable[..., Any],\n     *args: Any,\n     **kwargs: Any,\n-) -> _pytest._code.ExceptionInfo[E]:\n-    ...\n+) -> _pytest._code.ExceptionInfo[E]: ...\n \n \n def raises(  # noqa: F811\ndiff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\nindex 57d4bb47ccc..e8c8aff8baf 100644\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -22,7 +22,6 @@\n from _pytest.fixtures import fixture\n from _pytest.outcomes import fail\n \n-\n T = TypeVar(\"T\")\n \n \n@@ -42,15 +41,13 @@ def recwarn() -> Generator[\"WarningsRecorder\", None, None]:\n @overload\n def deprecated_call(\n     *, match: Optional[Union[str, Pattern[str]]] = ...\n-) -> \"WarningsRecorder\":\n-    ...\n+) -> \"WarningsRecorder\": ...\n \n \n @overload\n def deprecated_call(  # noqa: F811\n     func: Callable[..., T], *args: Any, **kwargs: Any\n-) -> T:\n-    ...\n+) -> T: ...\n \n \n def deprecated_call(  # noqa: F811\n@@ -92,8 +89,7 @@ def warns(\n     expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = ...,\n     *,\n     match: Optional[Union[str, Pattern[str]]] = ...,\n-) -> \"WarningsChecker\":\n-    ...\n+) -> \"WarningsChecker\": ...\n \n \n @overload\n@@ -102,8 +98,7 @@ def warns(  # noqa: F811\n     func: Callable[..., T],\n     *args: Any,\n     **kwargs: Any,\n-) -> T:\n-    ...\n+) -> T: ...\n \n \n def warns(  # noqa: F811\ndiff --git a/src/_pytest/reports.py b/src/_pytest/reports.py\nindex ddf7f298321..44eaec90854 100644\n--- a/src/_pytest/reports.py\n+++ b/src/_pytest/reports.py\n@@ -71,8 +71,7 @@ def __init__(self, **kw: Any) -> None:\n \n     if TYPE_CHECKING:\n         # Can have arbitrary fields given to __init__().\n-        def __getattr__(self, key: str) -> Any:\n-            ...\n+        def __getattr__(self, key: str) -> Any: ...\n \n     def toterminal(self, out: TerminalWriter) -> None:\n         if hasattr(self, \"node\"):\n@@ -609,9 +608,9 @@ def deserialize_repr_crash(repr_crash_dict: Optional[Dict[str, Any]]):\n                         description,\n                     )\n                 )\n-            exception_info: Union[\n-                ExceptionChainRepr, ReprExceptionInfo\n-            ] = ExceptionChainRepr(chain)\n+            exception_info: Union[ExceptionChainRepr, ReprExceptionInfo] = (\n+                ExceptionChainRepr(chain)\n+            )\n         else:\n             exception_info = ReprExceptionInfo(\n                 reprtraceback=reprtraceback,\ndiff --git a/src/_pytest/scope.py b/src/_pytest/scope.py\nindex 98edaf40225..d15c12705cd 100644\n--- a/src/_pytest/scope.py\n+++ b/src/_pytest/scope.py\n@@ -7,12 +7,12 @@\n \n Also this makes the module light to import, as it should.\n \"\"\"\n+\n from enum import Enum\n from functools import total_ordering\n from typing import Literal\n from typing import Optional\n \n-\n _ScopeName = Literal[\"session\", \"package\", \"module\", \"class\", \"function\"]\n \n \ndiff --git a/src/_pytest/stash.py b/src/_pytest/stash.py\nindex e61d75b95f7..7b111981bb0 100644\n--- a/src/_pytest/stash.py\n+++ b/src/_pytest/stash.py\n@@ -5,7 +5,6 @@\n from typing import TypeVar\n from typing import Union\n \n-\n __all__ = [\"Stash\", \"StashKey\"]\n \n \ndiff --git a/src/_pytest/timing.py b/src/_pytest/timing.py\nindex 925163a5858..096a6776873 100644\n--- a/src/_pytest/timing.py\n+++ b/src/_pytest/timing.py\n@@ -5,6 +5,7 @@\n \n Fixture \"mock_timing\" also interacts with this module for pytest's own tests.\n \"\"\"\n+\n from time import perf_counter\n from time import sleep\n from time import time\ndiff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex ce06b7d9bc4..3bdb0610e74 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -33,6 +33,7 @@\n \n if TYPE_CHECKING:\n     import unittest\n+\n     import twisted.trial.unittest\n \n     _SysExcInfoType = Union[\n@@ -397,8 +398,8 @@ def excstore(\n def check_testcase_implements_trial_reporter(done: List[int] = []) -> None:\n     if done:\n         return\n-    from zope.interface import classImplements\n     from twisted.trial.itrial import IReporter\n+    from zope.interface import classImplements\n \n     classImplements(TestCaseFunction, IReporter)\n     done.append(1)\ndiff --git a/src/pytest/__main__.py b/src/pytest/__main__.py\nindex b170152937b..9e08e3ebc20 100644\n--- a/src/pytest/__main__.py\n+++ b/src/pytest/__main__.py\n@@ -1,4 +1,5 @@\n \"\"\"The pytest entry point.\"\"\"\n+\n import pytest\n \n if __name__ == \"__main__\":\ndiff --git a/testing/_py/test_local.py b/testing/_py/test_local.py\nindex ba19aef38ae..b97080ed007 100644\n--- a/testing/_py/test_local.py\n+++ b/testing/_py/test_local.py\n@@ -7,10 +7,11 @@\n import warnings\n from unittest import mock\n \n-import pytest\n from py import error\n from py.path import local\n \n+import pytest\n+\n \n @contextlib.contextmanager\n def ignore_encoding_warning():\n@@ -1367,8 +1368,8 @@ def test_realpath_file(self, tmpdir):\n         assert realpath.basename == \"file\"\n \n     def test_owner(self, path1, tmpdir):\n-        from pwd import getpwuid  # type:ignore[attr-defined]\n         from grp import getgrgid  # type:ignore[attr-defined]\n+        from pwd import getpwuid  # type:ignore[attr-defined]\n \n         stat = path1.stat()\n         assert stat.path == path1\ndiff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex a9982b4f323..36625cfb5ae 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -24,7 +24,6 @@\n from _pytest.pytester import LineMatcher\n from _pytest.pytester import Pytester\n \n-\n if TYPE_CHECKING:\n     from _pytest._code.code import _TracebackStyle\n \ndiff --git a/testing/example_scripts/unittest/test_unittest_asyncio.py b/testing/example_scripts/unittest/test_unittest_asyncio.py\nindex a82ddaebcc3..f0c394ee36e 100644\n--- a/testing/example_scripts/unittest/test_unittest_asyncio.py\n+++ b/testing/example_scripts/unittest/test_unittest_asyncio.py\n@@ -2,7 +2,6 @@\n from typing import List\n from unittest import IsolatedAsyncioTestCase\n \n-\n teardowns: List[None] = []\n \n \ndiff --git a/testing/example_scripts/unittest/test_unittest_asynctest.py b/testing/example_scripts/unittest/test_unittest_asynctest.py\nindex b3f03e3256b..a5a0ec22c09 100644\n--- a/testing/example_scripts/unittest/test_unittest_asynctest.py\n+++ b/testing/example_scripts/unittest/test_unittest_asynctest.py\n@@ -5,7 +5,6 @@\n \n import asynctest\n \n-\n teardowns: List[None] = []\n \n \ndiff --git a/testing/freeze/create_executable.py b/testing/freeze/create_executable.py\nindex 998df7b1ca7..3803b3b24ec 100644\n--- a/testing/freeze/create_executable.py\n+++ b/testing/freeze/create_executable.py\n@@ -1,8 +1,10 @@\n \"\"\"Generate an executable with pytest runner embedded using PyInstaller.\"\"\"\n+\n if __name__ == \"__main__\":\n-    import pytest\n     import subprocess\n \n+    import pytest\n+\n     hidden = []\n     for x in pytest.freeze_includes():\n         hidden.extend([\"--hidden-import\", x])\ndiff --git a/testing/freeze/runtests_script.py b/testing/freeze/runtests_script.py\nindex 591863016ac..ef63a2d15b9 100644\n--- a/testing/freeze/runtests_script.py\n+++ b/testing/freeze/runtests_script.py\n@@ -5,6 +5,7 @@\n \n if __name__ == \"__main__\":\n     import sys\n+\n     import pytest\n \n     sys.exit(pytest.main())\ndiff --git a/testing/freeze/tox_run.py b/testing/freeze/tox_run.py\nindex 678a69c858a..7fd63cf1218 100644\n--- a/testing/freeze/tox_run.py\n+++ b/testing/freeze/tox_run.py\n@@ -2,6 +2,7 @@\n Called by tox.ini: uses the generated executable to run the tests in ./tests/\n directory.\n \"\"\"\n+\n if __name__ == \"__main__\":\n     import os\n     import sys\ndiff --git a/testing/io/test_terminalwriter.py b/testing/io/test_terminalwriter.py\nindex a13f9a4bcd9..0b83b5531df 100644\n--- a/testing/io/test_terminalwriter.py\n+++ b/testing/io/test_terminalwriter.py\n@@ -13,7 +13,6 @@\n from _pytest._io import terminalwriter\n from _pytest.monkeypatch import MonkeyPatch\n \n-\n # These tests were initially copied from py 1.8.1.\n \n \ndiff --git a/testing/logging/test_reporting.py b/testing/logging/test_reporting.py\nindex 92fd72300f4..f6ac9c3b213 100644\n--- a/testing/logging/test_reporting.py\n+++ b/testing/logging/test_reporting.py\n@@ -831,9 +831,10 @@ def test_live_logging_suspends_capture(\n     We parametrize the test to also make sure _LiveLoggingStreamHandler works correctly if no capture manager plugin\n     is installed.\n     \"\"\"\n-    import logging\n     import contextlib\n+    import logging\n     from functools import partial\n+\n     from _pytest.logging import _LiveLoggingStreamHandler\n \n     class MockCaptureManager:\ndiff --git a/testing/python/integration.py b/testing/python/integration.py\nindex dbe1b1a00f5..3ff92d92f9a 100644\n--- a/testing/python/integration.py\n+++ b/testing/python/integration.py\n@@ -43,9 +43,10 @@ def f(x):\n         assert values == (\"x\",)\n \n     def test_getfuncargnames_patching(self):\n-        from _pytest.compat import getfuncargnames\n         from unittest.mock import patch\n \n+        from _pytest.compat import getfuncargnames\n+\n         class T:\n             def original(self, x, y, z):\n                 pass\ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex a4386b3a8fa..0d1f9854bec 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1037,8 +1037,8 @@ def test_meta_path():\n         assert pytester.runpytest().ret == 0\n \n     def test_write_pyc(self, pytester: Pytester, tmp_path) -> None:\n-        from _pytest.assertion.rewrite import _write_pyc\n         from _pytest.assertion import AssertionState\n+        from _pytest.assertion.rewrite import _write_pyc\n \n         config = pytester.parseconfig()\n         state = AssertionState(config, \"rewrite\")\n@@ -1088,6 +1088,7 @@ def test_read_pyc(self, tmp_path: Path) -> None:\n         an exception that is propagated to the caller.\n         \"\"\"\n         import py_compile\n+\n         from _pytest.assertion.rewrite import _read_pyc\n \n         source = tmp_path / \"source.py\"\ndiff --git a/testing/test_config.py b/testing/test_config.py\nindex 45bcce4ea7f..5a18b9e419f 100644\n--- a/testing/test_config.py\n+++ b/testing/test_config.py\n@@ -2109,9 +2109,9 @@ def test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs(\n         args = (\"--pyargs\", \"pkg\") if use_pyargs else ()\n         res = pytester.runpytest(*args)\n         assert res.ret == (0 if use_pyargs else 2)\n-        msg = (\n-            msg\n-        ) = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n+        msg = msg = (\n+            \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n+        )\n         if use_pyargs:\n             assert msg not in res.stdout.str()\n         else:\ndiff --git a/testing/test_debugging.py b/testing/test_debugging.py\nindex 1cd46ae487a..c0b99797b4e 100644\n--- a/testing/test_debugging.py\n+++ b/testing/test_debugging.py\n@@ -9,7 +9,6 @@\n from _pytest.monkeypatch import MonkeyPatch\n from _pytest.pytester import Pytester\n \n-\n _ENVIRON_PYTHONBREAKPOINT = os.environ.get(\"PYTHONBREAKPOINT\", \"\")\n \n \ndiff --git a/testing/test_error_diffs.py b/testing/test_error_diffs.py\nindex cad7a17c047..6494a44fb12 100644\n--- a/testing/test_error_diffs.py\n+++ b/testing/test_error_diffs.py\n@@ -4,10 +4,10 @@\n See https://github.com/pytest-dev/pytest/issues/3333 for details.\n \n \"\"\"\n+\n import pytest\n from _pytest.pytester import Pytester\n \n-\n TESTCASES = [\n     pytest.param(\n         \"\"\"\ndiff --git a/testing/test_faulthandler.py b/testing/test_faulthandler.py\nindex 22545ea214c..b7142835dea 100644\n--- a/testing/test_faulthandler.py\n+++ b/testing/test_faulthandler.py\n@@ -114,6 +114,7 @@ def test_cancel_timeout_on_hook(monkeypatch, hook_name) -> None:\n     to timeout before entering pdb (pytest-dev/pytest-faulthandler#12) or any\n     other interactive exception (pytest-dev/pytest-faulthandler#14).\"\"\"\n     import faulthandler\n+\n     from _pytest import faulthandler as faulthandler_plugin\n \n     called = []\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 45acf050486..e37fc6c5339 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -943,7 +943,8 @@ def test_parameterset_for_parametrize_marks(\n         )\n \n     config = pytester.parseconfig()\n-    from _pytest.mark import pytest_configure, get_empty_parameterset_mark\n+    from _pytest.mark import get_empty_parameterset_mark\n+    from _pytest.mark import pytest_configure\n \n     pytest_configure(config)\n     result_mark = get_empty_parameterset_mark(config, [\"a\"], all)\n@@ -967,7 +968,8 @@ def test_parameterset_for_fail_at_collect(pytester: Pytester) -> None:\n     )\n \n     config = pytester.parseconfig()\n-    from _pytest.mark import pytest_configure, get_empty_parameterset_mark\n+    from _pytest.mark import get_empty_parameterset_mark\n+    from _pytest.mark import pytest_configure\n \n     pytest_configure(config)\n \ndiff --git a/testing/test_meta.py b/testing/test_meta.py\nindex 9201bd21611..40ed95d6b47 100644\n--- a/testing/test_meta.py\n+++ b/testing/test_meta.py\n@@ -3,6 +3,7 @@\n This ensures all internal packages can be imported without needing the pytest\n namespace being set, which is critical for the initialization of xdist.\n \"\"\"\n+\n import pkgutil\n import subprocess\n import sys\ndiff --git a/testing/test_reports.py b/testing/test_reports.py\nindex ae2b68cdb7e..d65358a8fe6 100644\n--- a/testing/test_reports.py\n+++ b/testing/test_reports.py\n@@ -296,9 +296,9 @@ def test_a():\n \n         reprec = pytester.inline_run()\n         if report_class is TestReport:\n-            reports: Union[\n-                Sequence[TestReport], Sequence[CollectReport]\n-            ] = reprec.getreports(\"pytest_runtest_logreport\")\n+            reports: Union[Sequence[TestReport], Sequence[CollectReport]] = (\n+                reprec.getreports(\"pytest_runtest_logreport\")\n+            )\n             # we have 3 reports: setup/call/teardown\n             assert len(reports) == 3\n             # get the call report\n", "problem_statement": "[pre-commit.ci] pre-commit autoupdate\n<!--pre-commit.ci start-->\nupdates:\n- [github.com/psf/black: 23.12.1 \u2192 24.1.1](https://github.com/psf/black/compare/23.12.1...24.1.1)\n<!--pre-commit.ci end-->\n", "hints_text": "Unfortunately black and reorder-python-imports are no longer compatible, and from the looks of it probably will not be compatible anytime soon:\r\n\r\nhttps://github.com/asottile/reorder-python-imports/issues/367\r\nhttps://github.com/asottile/reorder-python-imports/issues/366\r\nhttps://github.com/psf/black/issues/4175\r\n\r\nI'm trying out `ruff` in a few repos:\r\n\r\nhttps://github.com/pytest-dev/pytest-mock/pull/406\r\nhttps://github.com/pytest-dev/execnet/pull/239\r\n\r\n\r\n\r\n", "created_at": "2024-01-30T19:37:47Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11879, "instance_id": "pytest-dev__pytest-11879", "issue_numbers": ["11872"], "base_commit": "21bec6cfbed7ae36478aeff956919727c2bb8641", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex bea58204686..87909762263 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -93,6 +93,7 @@ Christopher Dignam\n Christopher Gilling\n Claire Cecil\n Claudio Madotto\n+Cl\u00e9ment M.T. Robert\n CrazyMerlyn\n Cristian Vera\n Cyrus Maden\ndiff --git a/changelog/11879.bugfix.rst b/changelog/11879.bugfix.rst\nnew file mode 100644\nindex 00000000000..70b6cce72e7\n--- /dev/null\n+++ b/changelog/11879.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix an edge case where ``ExceptionInfo._stringify_exception`` could crash :func:`pytest.raises`.\n", "test_patch": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex d99b5236661..39bbc3c140a 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -699,10 +699,21 @@ def getrepr(\n         return fmt.repr_excinfo(self)\n \n     def _stringify_exception(self, exc: BaseException) -> str:\n+        try:\n+            notes = getattr(exc, \"__notes__\", [])\n+        except KeyError:\n+            # Workaround for https://github.com/python/cpython/issues/98778 on\n+            # Python <= 3.9, and some 3.10 and 3.11 patch versions.\n+            HTTPError = getattr(sys.modules.get(\"urllib.error\", None), \"HTTPError\", ())\n+            if sys.version_info[:2] <= (3, 11) and isinstance(exc, HTTPError):\n+                notes = []\n+            else:\n+                raise\n+\n         return \"\\n\".join(\n             [\n                 str(exc),\n-                *getattr(exc, \"__notes__\", []),\n+                *notes,\n             ]\n         )\n \ndiff --git a/testing/python/raises.py b/testing/python/raises.py\nindex 47b22f28a92..369a66a9f50 100644\n--- a/testing/python/raises.py\n+++ b/testing/python/raises.py\n@@ -302,3 +302,16 @@ class NotAnException:\n             with pytest.raises((\"hello\", NotAnException)):  # type: ignore[arg-type]\n                 pass  # pragma: no cover\n         assert \"must be a BaseException type, not str\" in str(excinfo.value)\n+\n+    def test_issue_11872(self) -> None:\n+        \"\"\"Regression test for #11872.\n+\n+        urllib.error.HTTPError on Python<=3.9 raises KeyError instead of\n+        AttributeError on invalid attribute access.\n+\n+        https://github.com/python/cpython/issues/98778\n+        \"\"\"\n+        from urllib.error import HTTPError\n+\n+        with pytest.raises(HTTPError, match=\"Not Found\"):\n+            raise HTTPError(code=404, msg=\"Not Found\", fp=None, hdrs=None, url=\"\")  # type: ignore [arg-type]\n", "problem_statement": "BUG: pytest.raises(HTTPError, match=\"...\") breaks on Python 3.9 + pytest 8.0\n```python\r\nimport pytest\r\nfrom urllib.error import HTTPError\r\n\r\ndef test_foo():\r\n    with pytest.raises(HTTPError, match=\"Not Found\"):\r\n        raise HTTPError(code=404, msg=\"Not Found\", fp=None, hdrs=None, url=\"\")\r\n```\r\nthis test pass with Python 3.9 + pytest 7.4.4, but fails if I upgrade to pytest 8.0.0\r\nHere's the short traceback (simply running `pytest t.py`)\r\n```\r\n========================================= test session starts ==========================================\r\nplatform darwin -- Python 3.9.18, pytest-8.0.0, pluggy-1.4.0\r\nrootdir: /private/tmp\r\ncollected 1 item\r\n\r\nt.py F                                                                                           [100%]\r\n\r\n=============================================== FAILURES ===============================================\r\n_______________________________________________ test_foo _______________________________________________\r\n\r\n    def test_foo():\r\n        with pytest.raises(HTTPError, match=\"Not Found\"):\r\n>           raise HTTPError(code=404, msg=\"Not Found\", fp=None, hdrs=None, url=\"\")\r\nE           urllib.error.HTTPError: HTTP Error 404: Not Found\r\n\r\nt.py:5: HTTPError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\n    def test_foo():\r\n        with pytest.raises(HTTPError, match=\"Not Found\"):\r\n>           raise HTTPError(code=404, msg=\"Not Found\", fp=None, hdrs=None, url=\"\")\r\n\r\nt.py:5:\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n.venv/lib/python3.9/site-packages/_pytest/_code/code.py:704: in _stringify_exception\r\n    *getattr(exc, \"__notes__\", []),\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = <HTTPError 404: 'Not Found'>, name = '__notes__'\r\n\r\n    def __getattr__(self, name):\r\n        # Attribute lookups are delegated to the underlying file\r\n        # and cached for non-numeric results\r\n        # (i.e. methods are cached, closed and friends are not)\r\n>       file = self.__dict__['file']\r\nE       KeyError: 'file'\r\n\r\n/Users/clm/.pyenv/versions/3.9.18/lib/python3.9/tempfile.py:473: KeyError\r\n======================================= short test summary info ========================================\r\nFAILED t.py::test_foo - KeyError: 'file'\r\n========================================== 1 failed in 0.03s ===========================================\r\n```\r\n\r\nAnd attached, the [full-trace](https://github.com/pytest-dev/pytest/files/14076585/log.txt) (`pytest t.py --full-trace`)\r\n\r\nI haven't bisected yet, but git blame seems to indicate that #11424 is probably the breaking patch\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n```\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            23.0.1\r\npluggy         1.4.0\r\npytest         8.0.0\r\nsetuptools     58.1.0\r\ntomli          2.0.1\r\n```\r\n- [x] pytest and operating system versions:\r\nsee on MacOS 14.3 and Ubuntu 22.04.3, but I don't think that's relevant\r\n- [x] minimal example if possible\r\n\n", "hints_text": "given that the exception is raised from `tempfile`, I suspect this could be an actual CPython bug.\nLooks like `getattr(exc, \"__notes__\", [])` is causing issues on this particular exception on Python 3.9 (I verified that this doesn't happen on 3.10 and 3.11). I haven't haven't checked how tempfile is involved yet, probably a urllib thing. The most likely fix is to change this getattr to a safe getattr, but if you're able to analyze the cause more precisely that'd be helpful :)\nwhat do you mean by \"safe getattr\" ?\nhttps://github.com/pytest-dev/pytest/blob/8853a57532899b124578af7baa217acc26061070/src/_pytest/compat.py#L277", "created_at": "2024-01-29T08:29:17Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11875, "instance_id": "pytest-dev__pytest-11875", "issue_numbers": ["11874"], "base_commit": "8853a57532899b124578af7baa217acc26061070", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 803bb2b183f..bea58204686 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -340,6 +340,7 @@ Ronny Pfannschmidt\n Ross Lawley\n Ruaridh Williamson\n Russel Winder\n+Russell Martin\n Ryan Puddephatt\n Ryan Wooden\n Sadra Barikbin\ndiff --git a/changelog/11875.bugfix.rst b/changelog/11875.bugfix.rst\nnew file mode 100644\nindex 00000000000..d646be6314f\n--- /dev/null\n+++ b/changelog/11875.bugfix.rst\n@@ -0,0 +1,1 @@\n+Correctly handle errors from :func:`getpass.getuser` in Python 3.13.\n", "test_patch": "diff --git a/src/_pytest/tmpdir.py b/src/_pytest/tmpdir.py\nindex 937b1687ab8..75391adbcf8 100644\n--- a/src/_pytest/tmpdir.py\n+++ b/src/_pytest/tmpdir.py\n@@ -204,7 +204,7 @@ def get_user() -> Optional[str]:\n         import getpass\n \n         return getpass.getuser()\n-    except (ImportError, KeyError):\n+    except (ImportError, OSError, KeyError):\n         return None\n \n \n", "problem_statement": "Using Python 3.13.0a3+ on Windows when `USERNAME` env var is masked/unset, `get_user()` leaks `OSError` and breaks (at least) `tmp_path` usage\nFetching the username for temporary paths is failing for Windows on Python 3.13a3 when the `USERNAME` is not set. This is a common situation with `tox`, for instance, since it masks all the env vars.\r\n\r\n`getpass.getuser()` was [updated](https://github.com/python/cpython/pull/29739) to always raise `OSError` instead of the `ImportError` it was leaking before.\r\n\r\nAdditionally [catching](https://github.com/pytest-dev/pytest/blob/8853a57532899b124578af7baa217acc26061070/src/_pytest/tmpdir.py#L207) `OSError` would presumably resolve this.\r\n\r\nExample:\r\n```\r\n_______________ ERROR at setup of test_bundle_path[debian-bullseye] _______________\r\n\r\n    def getuser():\r\n        \"\"\"Get the username from the environment or password database.\r\n\r\n        First try various environment variables, then the password\r\n        database.  This works on Windows as long as USERNAME is set.\r\n        Any failure to find a username raises OSError.\r\n\r\n        .. versionchanged:: 3.13\r\n            Previously, various exceptions beyond just :exc:`OSError`\r\n            were raised.\r\n        \"\"\"\r\n\r\n        for name in ('LOGNAME', 'USER', 'LNAME', 'USERNAME'):\r\n            user = os.environ.get(name)\r\n            if user:\r\n                return user\r\n\r\n        try:\r\n>           import pwd\r\nE           ModuleNotFoundError: No module named 'pwd'\r\n\r\n..\\..\\..\\.pyenv\\pyenv-win\\versions\\3.13.0a3\\Lib\\getpass.py:172: ModuleNotFoundError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\n    def getuser():\r\n        \"\"\"Get the username from the environment or password database.\r\n\r\n        First try various environment variables, then the password\r\n        database.  This works on Windows as long as USERNAME is set.\r\n        Any failure to find a username raises OSError.\r\n\r\n        .. versionchanged:: 3.13\r\n            Previously, various exceptions beyond just :exc:`OSError`\r\n            were raised.\r\n        \"\"\"\r\n\r\n        for name in ('LOGNAME', 'USER', 'LNAME', 'USERNAME'):\r\n            user = os.environ.get(name)\r\n            if user:\r\n                return user\r\n\r\n        try:\r\n            import pwd\r\n            return pwd.getpwuid(os.getuid())[0]\r\n        except (ImportError, KeyError) as e:\r\n>           raise OSError('No username set in the environment') from e\r\nE           OSError: No username set in the environment\r\n\r\n..\\..\\..\\.pyenv\\pyenv-win\\versions\\3.13.0a3\\Lib\\getpass.py:175: OSError\r\n```\r\nCI example: https://github.com/beeware/briefcase/actions/runs/7688404294/job/20949599385\r\n\r\n<details>\r\n<summary>python -m pip list</summary>\r\n\r\n```\r\n\u276f python -m pip list\r\nPackage                     Version                 Editable project location\r\n--------------------------- ----------------------- -------------------------------------------------\r\narrow                       1.3.0\r\nbinaryornot                 0.4.4\r\nbriefcase                   0.3.17.dev246+g22bc0a0b C:\\Users\\user\\github\\beeware\\briefcase\r\nbriefcase-automation        0.3.17.dev117+gd2187c76\r\nbuild                       1.0.3\r\ncachetools                  5.3.2\r\ncertifi                     2023.11.17\r\ncfgv                        3.4.0\r\nchardet                     5.2.0\r\ncharset-normalizer          3.3.2\r\nclick                       8.1.7\r\ncolorama                    0.4.6\r\ncookiecutter                2.5.0\r\ncoverage                    7.4.1\r\ncoverage-conditional-plugin 0.9.0\r\ndistlib                     0.3.8\r\nexecnet                     2.0.2\r\nfilelock                    3.13.1\r\ngitdb                       4.0.11\r\nGitPython                   3.1.41\r\nidentify                    2.5.33\r\nidna                        3.6\r\niniconfig                   2.0.0\r\nJinja2                      3.1.3\r\nmarkdown-it-py              3.0.0\r\nMarkupSafe                  2.1.4\r\nmdurl                       0.1.2\r\nnodeenv                     1.8.0\r\npackaging                   23.2\r\npip                         23.3.2\r\nplatformdirs                4.1.0\r\npluggy                      1.4.0\r\npre-commit                  3.6.0\r\npsutil                      5.9.8\r\nPygments                    2.17.2\r\npyproject-api               1.6.1\r\npyproject_hooks             1.0.0\r\npytest                      8.0.0\r\npytest-xdist                3.5.0\r\npython-dateutil             2.8.2\r\npython-slugify              8.0.2\r\nPyYAML                      6.0.1\r\nrequests                    2.31.0\r\nrich                        13.7.0\r\nsetuptools                  69.0.3\r\nsetuptools-scm              8.0.4\r\nsix                         1.16.0\r\nsmmap                       5.0.1\r\ntext-unidecode              1.3\r\ntomli_w                     1.0.0\r\ntox                         4.12.1\r\ntypes-python-dateutil       2.8.19.20240106\r\ntyping_extensions           4.9.0\r\nurllib3                     2.1.0\r\nvirtualenv                  20.25.0\r\nwheel                       0.42.0\r\nx-briefcase-automation      0.3.17.dev246+g22bc0a0b C:\\Users\\user\\github\\beeware\\briefcase\\automation\r\n```\r\n\r\n</details>\r\n\r\nOS: Windows 11, Server 2022\r\nPython: 3.13.0a3\r\npytest: 8.0.0\r\n\r\n- [X] a detailed description of the bug or problem you are having\r\n- [X] output of `pip list` from the virtual environment you are using\r\n- [X] pytest and operating system versions\r\n- [X] minimal example if possible\r\n\n", "hints_text": "", "created_at": "2024-01-28T22:49:28Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11833, "instance_id": "pytest-dev__pytest-11833", "issue_numbers": ["1489"], "base_commit": "c203f1615cb2bc3f80d973333d3af9005894abd9", "patch": "diff --git a/changelog/1489.bugfix.rst b/changelog/1489.bugfix.rst\nnew file mode 100644\nindex 00000000000..70c5dd1252e\n--- /dev/null\n+++ b/changelog/1489.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix some instances where teardown of higher-scoped fixtures was not happening in the reverse order they were initialized in.\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 8b25d743ca4..48429a023ac 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -543,6 +543,11 @@ def getfixturevalue(self, argname: str) -> Any:\n         :raises pytest.FixtureLookupError:\n             If the given fixture could not be found.\n         \"\"\"\n+        # Note that in addition to the use case described in the docstring,\n+        # getfixturevalue() is also called by pytest itself during item and fixture\n+        # setup to evaluate the fixtures that are requested statically\n+        # (using function parameters, autouse, etc).\n+\n         fixturedef = self._get_active_fixturedef(argname)\n         assert fixturedef.cached_result is not None, (\n             f'The fixture value for \"{argname}\" is not available.  '\n@@ -587,9 +592,8 @@ def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n         \"\"\"Create a SubRequest based on \"self\" and call the execute method\n         of the given FixtureDef object.\n \n-        This will force the FixtureDef object to throw away any previous\n-        results and compute a new fixture value, which will be stored into\n-        the FixtureDef object itself.\n+        If the FixtureDef has cached the result it will do nothing, otherwise it will\n+        setup and run the fixture, cache the value, and schedule a finalizer for it.\n         \"\"\"\n         # prepare a subrequest object before calling fixture function\n         # (latter managed by fixturedef)\n@@ -646,18 +650,9 @@ def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n         subrequest = SubRequest(\n             self, scope, param, param_index, fixturedef, _ispytest=True\n         )\n-        try:\n-            # Call the fixture function.\n-            fixturedef.execute(request=subrequest)\n-        finally:\n-            self._schedule_finalizers(fixturedef, subrequest)\n \n-    def _schedule_finalizers(\n-        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n-    ) -> None:\n-        # If fixture function failed it might have registered finalizers.\n-        finalizer = functools.partial(fixturedef.finish, request=subrequest)\n-        subrequest.node.addfinalizer(finalizer)\n+        # Make sure the fixture value is cached, running it if it isn't\n+        fixturedef.execute(request=subrequest)\n \n \n @final\n@@ -788,21 +783,6 @@ def _format_fixturedef_line(self, fixturedef: \"FixtureDef[object]\") -> str:\n     def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n         self._fixturedef.addfinalizer(finalizer)\n \n-    def _schedule_finalizers(\n-        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n-    ) -> None:\n-        # If the executing fixturedef was not explicitly requested in the argument list (via\n-        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n-        # first.\n-        if (\n-            fixturedef.argname not in self._fixture_defs\n-            and fixturedef.argname not in self._pyfuncitem.fixturenames\n-        ):\n-            fixturedef.addfinalizer(\n-                functools.partial(self._fixturedef.finish, request=self)\n-            )\n-        super()._schedule_finalizers(fixturedef, subrequest)\n-\n \n @final\n class FixtureLookupError(LookupError):\n@@ -1055,12 +1035,13 @@ def finish(self, request: SubRequest) -> None:\n             raise BaseExceptionGroup(msg, exceptions[::-1])\n \n     def execute(self, request: SubRequest) -> FixtureValue:\n+        finalizer = functools.partial(self.finish, request=request)\n         # Get required arguments and register our own finish()\n         # with their finalization.\n         for argname in self.argnames:\n             fixturedef = request._get_active_fixturedef(argname)\n             if not isinstance(fixturedef, PseudoFixtureDef):\n-                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n+                fixturedef.addfinalizer(finalizer)\n \n         my_cache_key = self.cache_key(request)\n         if self.cached_result is not None:\n@@ -1080,7 +1061,14 @@ def execute(self, request: SubRequest) -> FixtureValue:\n             assert self.cached_result is None\n \n         ihook = request.node.ihook\n-        result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\n+        try:\n+            # Setup the fixture, run the code in it, and cache the value\n+            # in self.cached_result\n+            result = ihook.pytest_fixture_setup(fixturedef=self, request=request)\n+        finally:\n+            # schedule our finalizer, even if the setup failed\n+            request.node.addfinalizer(finalizer)\n+\n         return result\n \n     def cache_key(self, request: SubRequest) -> object:\ndiff --git a/testing/python/fixtures.py b/testing/python/fixtures.py\nindex 6051ab18fd8..1e22270e51b 100644\n--- a/testing/python/fixtures.py\n+++ b/testing/python/fixtures.py\n@@ -4696,3 +4696,58 @@ def test_crash_expected_setup_and_teardown() -> None:\n     )\n     result = pytester.runpytest()\n     assert result.ret == 0\n+\n+\n+def test_scoped_fixture_teardown_order(pytester: Pytester) -> None:\n+    \"\"\"\n+    Make sure teardowns happen in reverse order of setup with scoped fixtures, when\n+    a later test only depends on a subset of scoped fixtures.\n+\n+    Regression test for https://github.com/pytest-dev/pytest/issues/1489\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        from typing import Generator\n+\n+        import pytest\n+\n+\n+        last_executed = \"\"\n+\n+\n+        @pytest.fixture(scope=\"module\")\n+        def fixture_1() -> Generator[None, None, None]:\n+            global last_executed\n+            assert last_executed == \"\"\n+            last_executed = \"fixture_1_setup\"\n+            yield\n+            assert last_executed == \"fixture_2_teardown\"\n+            last_executed = \"fixture_1_teardown\"\n+\n+\n+        @pytest.fixture(scope=\"module\")\n+        def fixture_2() -> Generator[None, None, None]:\n+            global last_executed\n+            assert last_executed == \"fixture_1_setup\"\n+            last_executed = \"fixture_2_setup\"\n+            yield\n+            assert last_executed == \"run_test\"\n+            last_executed = \"fixture_2_teardown\"\n+\n+\n+        def test_fixture_teardown_order(fixture_1: None, fixture_2: None) -> None:\n+            global last_executed\n+            assert last_executed == \"fixture_2_setup\"\n+            last_executed = \"run_test\"\n+\n+\n+        def test_2(fixture_1: None) -> None:\n+            # This would previously queue an additional teardown of fixture_1,\n+            # despite fixture_1's value being cached, which caused fixture_1 to be\n+            # torn down before fixture_2 - violating the rule that teardowns should\n+            # happen in reverse order of setup.\n+            pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest()\n+    assert result.ret == 0\n", "problem_statement": "fixture finalizer dependency incorrect when using autouse or getfuncargvalue\nCalling fixture finalizers in the correct order works by dependent fixtures registering their finalizer in their dependency (see python.FixtureDef.execute+10).\r\nHowever, this only happens for fixtures explicitly requested in args, not for autouse or getfuncargvalue fixtures.\r\nThis code:\r\n\r\n``` python\r\nimport pytest\r\n\r\n@pytest.fixture(scope=\"session\")\r\ndef global_dict():\r\n    return {}\r\n\r\n@pytest.fixture(scope=\"session\", autouse=True)\r\ndef add_1(global_dict):\r\n    global_dict[1] = \"a\"\r\n    print(\"add_1 setup\", global_dict)\r\n    yield global_dict\r\n    print(\"add_1 teardown\", global_dict)\r\n    del global_dict[1]\r\n\r\n@pytest.fixture(scope=\"session\")\r\ndef change_1_to_2(global_dict):\r\n    global_dict[2] = global_dict.pop(1)\r\n    print(\"change_1_to_2 setup\", global_dict)\r\n    yield global_dict\r\n    print(\"change_1_to_2 teardown\", global_dict)\r\n    global_dict[1] = global_dict.pop(2)\r\n\r\ndef test1(change_1_to_2):\r\n    assert change_1_to_2[2] == \"a\"\r\n\r\ndef test2(global_dict):\r\n    assert global_dict[2] == \"a\"\r\n```\r\n\r\ngives with `py.test --capture=no test.py`:\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform linux2 -- Python 2.7.11, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\r\nrootdir: /home/amos/git/test_py, inifile: \r\ncollected 2 items \r\n\r\ntest.py add_1 setup {1: 'a'}\r\nchange_1_to_2 setup {2: 'a'}\r\n..add_1 teardown {2: 'a'}\r\nchange_1_to_2 teardown {2: 'a'}\r\nE\r\n\r\n==================================== ERRORS ====================================\r\n__________________________ ERROR at teardown of test2 __________________________\r\n\r\nglobal_dict = {1: 'a'}\r\n\r\n    @pytest.yield_fixture(scope=\"session\", autouse=True)\r\n    def add_1(global_dict):\r\n        global_dict[1] = \"a\"\r\n        print \"add_1 setup\", global_dict\r\n        yield global_dict\r\n        print \"add_1 teardown\", global_dict\r\n>       del global_dict[1]\r\nE       KeyError: 1\r\n\r\ntest.py:14: KeyError\r\n====================== 2 passed, 1 error in 0.01 seconds =======================\r\n```\r\n\r\nas does this code:\r\n\r\n``` python\r\nimport pytest\r\n\r\n@pytest.fixture(scope=\"session\")\r\ndef global_dict():\r\n    return {}\r\n\r\n@pytest.yield_fixture(scope=\"session\")\r\ndef add_1(global_dict):\r\n    global_dict[1] = \"a\"\r\n    print \"add_1 setup\", global_dict\r\n    yield global_dict\r\n    print \"add_1 teardown\", global_dict\r\n    del global_dict[1]\r\n\r\n@pytest.yield_fixture(scope=\"session\")\r\ndef change_1_to_2(request):\r\n    add_1 = request.getfuncargvalue(\"add_1\")\r\n    add_1[2] = add_1.pop(1)\r\n    print \"change_1_to_2 setup\", add_1\r\n    yield add_1\r\n    print \"change_1_to_2 teardown\", add_1\r\n    add_1[1] = add_1.pop(2)\r\n\r\ndef test1(change_1_to_2):\r\n    assert change_1_to_2[2] == \"a\"\r\n\r\ndef test2(global_dict):\r\n    assert global_dict[2] == \"a\"\r\n```\r\n\n", "hints_text": "Hi @amosonn,\n\nThanks for taking the time to write down this report. \n\n(I edited your post to add syntax highlight to your examples to make them easier to read, hope you don't mind).\n\nI thought I could use autouse fixtures to do some setup and teardown, but since the teardown part is not garanteed to come after the teardown of non-autouse fixtures, it's not straightforward. Here is a more compact and modern test case that shows the problem (the scope could also be set to package or session):\r\n```python\r\nimport pytest\r\n\r\n@pytest.fixture(scope='module', autouse=True)\r\ndef fixture_autouse():\r\n    print('\\nSETUP FIXTURE AUTOUSE')\r\n    yield\r\n    print('\\nTEARDOWN FIXTURE AUTOUSE')\r\n\r\n@pytest.fixture(scope='module')\r\ndef fixture_test():\r\n    print('\\nSETUP FIXTURE TEST')\r\n    yield\r\n    print('\\nTEARDOWN FIXTURE TEST')\r\n\r\ndef test_1(fixture_test):\r\n    pass\r\n\r\ndef test_2():\r\n    pass\r\n```\r\nrunning the test gives:\r\n```\r\n============================== 2 passed in 0.00s ===============================\r\n(venv) (base) 22) lilla:~/work/bug_pytest> pytest -s tests/\r\n============================= test session starts ==============================\r\nplatform linux -- Python 3.8.3, pytest-6.3.0.dev454+gb8f1b7cdc, py-1.10.0, pluggy-0.13.1\r\nrootdir: /home/chanial/work/bug_pytest\r\ncollected 2 items                                                              \r\n\r\ntests/test_fixture.py \r\nSETUP FIXTURE AUTOUSE\r\n\r\nSETUP FIXTURE TEST\r\n..\r\nTEARDOWN FIXTURE AUTOUSE\r\n\r\nTEARDOWN FIXTURE TEST\r\n\r\n\r\n============================== 2 passed in 0.01s ===============================\r\n```\r\nwhich shows that the autouse fixture teardown does not come after that of the non-autouse fixture. Since the autouse fixture setup comes first wrt non-autouse setups, it is expected that their teardowns come last.\n+1 ran into this bug. This behavior is different from the documented expected behavior that finalizers will run in reverse order to the order the fixtures were initialized. From https://docs.pytest.org/en/6.2.x/fixture.html#yield-fixtures-recommended :\r\n\r\n> Once the test is finished, pytest will go back down the list of fixtures, but in the reverse order, taking each one that yielded, and running the code inside it that was after the yield statement.\r\n\r\nPerhaps adding a caveat to the documentation would be good until this is fixed?\nStarted looking into this, and it's actually not `autouse` that is the problem. We can modify pchanial's example to not have autouse and get the same behaviour:\r\n\r\n```python\r\nimport pytest\r\n\r\n@pytest.fixture(scope='module')\r\ndef fixture_1():\r\n    print('\\nSETUP FIXTURE 1')\r\n    yield\r\n    print('\\nTEARDOWN FIXTURE 1')\r\n\r\n@pytest.fixture(scope='module')\r\ndef fixture_2():\r\n    print('\\nSETUP FIXTURE 2')\r\n    yield\r\n    print('\\nTEARDOWN FIXTURE 2')\r\n\r\ndef test_1(fixture_1, fixture_2):\r\n    pass\r\n\r\ndef test_2(fixture_1):\r\n    pass\r\n```\r\n\r\n```\r\nSETUP FIXTURE 1\r\n\r\nSETUP FIXTURE 2\r\n..\r\nTEARDOWN FIXTURE 1\r\n\r\nTEARDOWN FIXTURE 2\r\n```\r\n\r\nif the test order is reversed, or `test_2` is removed, it does not occur. What seems to be happening is that the teardown for fixtures are queued each time they're called, so we get the following finalizer stack:\r\n```python\r\n[<bound method Node.teardown of <Module mytest2.py>>,\r\n functools.partial(<bound method FixtureDef.finish of <FixtureDef argname='fixture_1' scope='module' baseid='testing/python/mytest2.py'>>, request=<SubRequest 'fixture_1' for <Function test_1>>),\r\n functools.partial(<bound method FixtureDef.finish of <FixtureDef argname='fixture_2' scope='module' baseid='testing/python/mytest2.py'>>, request=<SubRequest 'fixture_2' for <Function test_1>>),\r\n functools.partial(<bound method FixtureDef.finish of <FixtureDef argname='fixture_1' scope='module' baseid='testing/python/mytest2.py'>>, request=<SubRequest 'fixture_1' for <Function test_2>>)]\r\n```\r\nit processes it from the end, tearing down `fixture_1`, then `fixture_2`, and then `fixture_1` again - but `FixtureDef.finish` ignores the second teardown of `fixture_1` since it's already been finalized.\r\n\r\n\r\nMy current best-guess on how to fix it is to add some logic to runner.py:SetupState.addfinalizer so we only add a finalizer for a given fixture once.\r\nedit: probably better to add it to fixtures.py:FixtureRequest._compute_fixture_value", "created_at": "2024-01-17T15:30:42Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11830, "instance_id": "pytest-dev__pytest-11830", "issue_numbers": ["11789"], "base_commit": "a6708b92542eb886d3ba7b809213b2068a7988a6", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 353489b6cd2..803bb2b183f 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -141,6 +141,7 @@ Evgeny Seliverstov\n Fabian Sturm\n Fabien Zarifian\n Fabio Zadrozny\n+faph\n Felix Hofst\u00e4tter\n Felix Nieuwenhuizen\n Feng Ma\ndiff --git a/changelog/11790.doc.rst b/changelog/11790.doc.rst\nnew file mode 100644\nindex 00000000000..648b20b96af\n--- /dev/null\n+++ b/changelog/11790.doc.rst\n@@ -0,0 +1,1 @@\n+Documented the retention of temporary directories created using the ``tmp_path`` fixture in more detail.\ndiff --git a/doc/en/how-to/tmp_path.rst b/doc/en/how-to/tmp_path.rst\nindex 3e680dcac76..3cc5152e992 100644\n--- a/doc/en/how-to/tmp_path.rst\n+++ b/doc/en/how-to/tmp_path.rst\n@@ -8,9 +8,8 @@ How to use temporary directories and files in tests\n The ``tmp_path`` fixture\n ------------------------\n \n-You can use the ``tmp_path`` fixture which will\n-provide a temporary directory unique to the current test,\n-created in the `base temporary directory`_.\n+You can use the ``tmp_path`` fixture which will provide a temporary directory\n+unique to each test function.\n \n ``tmp_path`` is a :class:`pathlib.Path` object. Here is an example test usage:\n \n@@ -62,6 +61,11 @@ Running this would result in a passed test except for the last\n     FAILED test_tmp_path.py::test_create_file - assert 0\n     ============================ 1 failed in 0.12s =============================\n \n+By default, ``pytest`` retains the temporary directory for the last 3 ``pytest``\n+invocations. Concurrent invocations of the same test function are supported by\n+configuring the base temporary directory to be unique for each concurrent\n+run. See `temporary directory location and retention`_ for details.\n+\n .. _`tmp_path_factory example`:\n \n The ``tmp_path_factory`` fixture\n@@ -100,7 +104,7 @@ See :ref:`tmp_path_factory API <tmp_path_factory factory api>` for details.\n .. _tmpdir:\n \n The ``tmpdir`` and ``tmpdir_factory`` fixtures\n----------------------------------------------------\n+----------------------------------------------\n \n The ``tmpdir`` and ``tmpdir_factory`` fixtures are similar to ``tmp_path``\n and ``tmp_path_factory``, but use/return legacy `py.path.local`_ objects\n@@ -124,10 +128,10 @@ See :fixture:`tmpdir <tmpdir>` :fixture:`tmpdir_factory <tmpdir_factory>`\n API for details.\n \n \n-.. _`base temporary directory`:\n+.. _`temporary directory location and retention`:\n \n-The default base temporary directory\n------------------------------------------------\n+Temporary directory location and retention\n+------------------------------------------\n \n Temporary directories are by default created as sub-directories of\n the system temporary directory.  The base name will be ``pytest-NUM`` where\n@@ -152,7 +156,7 @@ You can override the default temporary directory setting like this:\n     for that purpose only.\n \n When distributing tests on the local machine using ``pytest-xdist``, care is taken to\n-automatically configure a basetemp directory for the sub processes such that all temporary\n-data lands below a single per-test run basetemp directory.\n+automatically configure a `basetemp` directory for the sub processes such that all temporary\n+data lands below a single per-test run temporary directory.\n \n .. _`py.path.local`: https://py.readthedocs.io/en/latest/path.html\n", "test_patch": "diff --git a/src/_pytest/legacypath.py b/src/_pytest/legacypath.py\nindex b2dd87436e1..f69315b5fed 100644\n--- a/src/_pytest/legacypath.py\n+++ b/src/_pytest/legacypath.py\n@@ -326,8 +326,8 @@ def tmpdir(tmp_path: Path) -> LEGACY_PATH:\n \n         By default, a new base temporary directory is created each test session,\n         and old bases are removed after 3 sessions, to aid in debugging. If\n-        ``--basetemp`` is used then it is cleared each session. See :ref:`base\n-        temporary directory`.\n+        ``--basetemp`` is used then it is cleared each session. See\n+        :ref:`temporary directory location and retention`.\n \n         The returned object is a `legacy_path`_ object.\n \ndiff --git a/src/_pytest/tmpdir.py b/src/_pytest/tmpdir.py\nindex 6fa227760a8..21e5366a354 100644\n--- a/src/_pytest/tmpdir.py\n+++ b/src/_pytest/tmpdir.py\n@@ -262,8 +262,8 @@ def tmp_path(\n     and old bases are removed after 3 sessions, to aid in debugging.\n     This behavior can be configured with :confval:`tmp_path_retention_count` and\n     :confval:`tmp_path_retention_policy`.\n-    If ``--basetemp`` is used then it is cleared each session. See :ref:`base\n-    temporary directory`.\n+    If ``--basetemp`` is used then it is cleared each session. See\n+    :ref:`temporary directory location and retention`.\n \n     The returned object is a :class:`pathlib.Path` object.\n     \"\"\"\n", "problem_statement": "Document temp dir retention in how-to guide\nI discovered by accident Pytest's feature to retain temporary directories by default after tests complete. I feel the how-to guide \"How to use temporary directories and files in tests\" (https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html) could do with documenting this feature as this may be the first and only page a developer reads before using the `tmp_path` fixture.\r\n\r\nCurrently, the documentation simply refers to \"a temporary directory unique to the test (...)\". As an engineer, I read that as something that goes away automatically as soon as the fixture is being tore down.\r\n\r\nThis may be an issue when using large temporary files, for example, in automated pipelines. \r\n\r\nI don't mind what wording is used, but a reference to the API reference docs (e.g. https://docs.pytest.org/en/7.3.x/reference/reference.html#confval-tmp_path_retention_policy) might be extremely useful. \n", "hints_text": "", "created_at": "2024-01-17T12:06:12Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11818, "instance_id": "pytest-dev__pytest-11818", "issue_numbers": ["11797", "11797"], "base_commit": "dc65bb6a6699bdeb5ee7523245db1ee724670e29", "patch": "diff --git a/changelog/11797.bugfix.rst b/changelog/11797.bugfix.rst\nnew file mode 100644\nindex 0000000000..94b72da00f\n--- /dev/null\n+++ b/changelog/11797.bugfix.rst\n@@ -0,0 +1,1 @@\n+:func:`pytest.approx` now correctly handles :class:`Sequence <collections.abc.Sequence>`-like objects.\n", "test_patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 9b17e5cb78..bfc8dc3344 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -129,6 +129,8 @@ def _recursive_sequence_map(f, x):\n     if isinstance(x, (list, tuple)):\n         seq_type = type(x)\n         return seq_type(_recursive_sequence_map(f, xi) for xi in x)\n+    elif _is_sequence_like(x):\n+        return [_recursive_sequence_map(f, xi) for xi in x]\n     else:\n         return f(x)\n \n@@ -721,11 +723,7 @@ def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n     elif _is_numpy_array(expected):\n         expected = _as_numpy_array(expected)\n         cls = ApproxNumpy\n-    elif (\n-        hasattr(expected, \"__getitem__\")\n-        and isinstance(expected, Sized)\n-        and not isinstance(expected, (str, bytes))\n-    ):\n+    elif _is_sequence_like(expected):\n         cls = ApproxSequenceLike\n     elif isinstance(expected, Collection) and not isinstance(expected, (str, bytes)):\n         msg = f\"pytest.approx() only supports ordered sequences, but got: {expected!r}\"\n@@ -736,6 +734,14 @@ def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n     return cls(expected, rel, abs, nan_ok)\n \n \n+def _is_sequence_like(expected: object) -> bool:\n+    return (\n+        hasattr(expected, \"__getitem__\")\n+        and isinstance(expected, Sized)\n+        and not isinstance(expected, (str, bytes))\n+    )\n+\n+\n def _is_numpy_array(obj: object) -> bool:\n     \"\"\"\n     Return true if the given object is implicitly convertible to ndarray,\ndiff --git a/testing/python/approx.py b/testing/python/approx.py\nindex 968e882851..31e64c4df3 100644\n--- a/testing/python/approx.py\n+++ b/testing/python/approx.py\n@@ -954,6 +954,43 @@ def test_allow_ordered_sequences_only(self) -> None:\n         with pytest.raises(TypeError, match=\"only supports ordered sequences\"):\n             assert {1, 2, 3} == approx({1, 2, 3})\n \n+    def test_strange_sequence(self):\n+        \"\"\"https://github.com/pytest-dev/pytest/issues/11797\"\"\"\n+        a = MyVec3(1, 2, 3)\n+        b = MyVec3(0, 1, 2)\n+\n+        # this would trigger the error inside the test\n+        pytest.approx(a, abs=0.5)._repr_compare(b)\n+\n+        assert b == pytest.approx(a, abs=2)\n+        assert b != pytest.approx(a, abs=0.5)\n+\n+\n+class MyVec3:  # incomplete\n+    \"\"\"sequence like\"\"\"\n+\n+    _x: int\n+    _y: int\n+    _z: int\n+\n+    def __init__(self, x: int, y: int, z: int):\n+        self._x, self._y, self._z = x, y, z\n+\n+    def __repr__(self) -> str:\n+        return f\"<MyVec3 {self._x} {self._y} {self._z}>\"\n+\n+    def __len__(self) -> int:\n+        return 3\n+\n+    def __getitem__(self, key: int) -> int:\n+        if key == 0:\n+            return self._x\n+        if key == 1:\n+            return self._y\n+        if key == 2:\n+            return self._z\n+        raise IndexError(key)\n+\n \n class TestRecursiveSequenceMap:\n     def test_map_over_scalar(self):\n@@ -981,3 +1018,6 @@ def test_map_over_mixed_sequence(self):\n             (5, 8),\n             [(7)],\n         ]\n+\n+    def test_map_over_sequence_like(self):\n+        assert _recursive_sequence_map(int, MyVec3(1, 2, 3)) == [1, 2, 3]\n", "problem_statement": "`approx` representation of details failed when using a `ApproxSequenceLike` which is not `list` or `tuple`\n## Description\r\n\r\nWhen using a custom sequence like type then the comparison of `pytest.approx` works as expected if the assert is `True`. But in case the assertion fails, the detailed output of what went wrong is broken.\r\n\r\nGiven the following example:\r\n\r\n```python\r\nimport pytest\r\n\r\nclass MyVec3:\r\n    def __init__(self, x, y, z):\r\n        self._x, self._y, self._z = x, y, z\r\n\r\n    def __len__(self):\r\n        return 3\r\n\r\n    def __getitem__(self, key):\r\n        if key == 0:\r\n            return self._x\r\n        if key == 1:\r\n            return self._y\r\n        if key == 2:\r\n            return self._z\r\n        raise IndexError\r\n\r\n\r\ndef test_vec_approx():\r\n    assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n    assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\n```\r\n\r\nThe first assert statement is fine, as expected.\r\n\r\nIn the second assert fails, as expected.\r\n\r\nBut I get this output:\r\n\r\n```\r\n============================================ test session starts ============================================\r\nplatform linux -- Python 3.10.12, pytest-7.4.4, pluggy-1.3.0\r\nrootdir: /home/user\r\ncollected 1 item                                                                                            \r\n\r\ntest_approx.py F                                                                                      [100%]\r\n\r\n================================================= FAILURES ==================================================\r\n______________________________________________ test_vec_approx ______________________________________________\r\n\r\n    def test_vec_approx():\r\n        assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n>       assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\nE       AssertionError: assert <test_approx....x7f657f208880> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\nE         (pytest_assertion plugin: representation of details failed: /home/user/venv/lib/python3.10/site-packages/_pytest/python_api.py:342: TypeError: object of type 'ApproxScalar' has no len().\r\nE          Probably an object has a faulty __repr__.)\r\n\r\ntest_approx.py:22: AssertionError\r\n========================================== short test summary info ==========================================\r\nFAILED test_approx.py::test_vec_approx - AssertionError: assert <test_approx....x7f657f208880> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\n============================================= 1 failed in 0.01s =============================================\r\n```\r\n\r\n## Setup\r\n```\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            22.0.2\r\npluggy         1.3.0\r\npytest         7.4.4\r\nsetuptools     59.6.0\r\ntomli          2.0.1\r\n```\r\n\r\nAlso happens with pytest version 7.1.2 and 7.1.3\r\n\r\nOS is Ubuntu 22.04\r\n\n`approx` representation of details failed when using a `ApproxSequenceLike` which is not `list` or `tuple`\n## Description\r\n\r\nWhen using a custom sequence like type then the comparison of `pytest.approx` works as expected if the assert is `True`. But in case the assertion fails, the detailed output of what went wrong is broken.\r\n\r\nGiven the following example:\r\n\r\n```python\r\nimport pytest\r\n\r\nclass MyVec3:\r\n    def __init__(self, x, y, z):\r\n        self._x, self._y, self._z = x, y, z\r\n\r\n    def __len__(self):\r\n        return 3\r\n\r\n    def __getitem__(self, key):\r\n        if key == 0:\r\n            return self._x\r\n        if key == 1:\r\n            return self._y\r\n        if key == 2:\r\n            return self._z\r\n        raise IndexError\r\n\r\n\r\ndef test_vec_approx():\r\n    assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n    assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\n```\r\n\r\nThe first assert statement is fine, as expected.\r\n\r\nIn the second assert fails, as expected.\r\n\r\nBut I get this output:\r\n\r\n```\r\n============================================ test session starts ============================================\r\nplatform linux -- Python 3.10.12, pytest-7.4.4, pluggy-1.3.0\r\nrootdir: /home/user\r\ncollected 1 item                                                                                            \r\n\r\ntest_approx.py F                                                                                      [100%]\r\n\r\n================================================= FAILURES ==================================================\r\n______________________________________________ test_vec_approx ______________________________________________\r\n\r\n    def test_vec_approx():\r\n        assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n>       assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\nE       AssertionError: assert <test_approx....x7f657f208880> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\nE         (pytest_assertion plugin: representation of details failed: /home/user/venv/lib/python3.10/site-packages/_pytest/python_api.py:342: TypeError: object of type 'ApproxScalar' has no len().\r\nE          Probably an object has a faulty __repr__.)\r\n\r\ntest_approx.py:22: AssertionError\r\n========================================== short test summary info ==========================================\r\nFAILED test_approx.py::test_vec_approx - AssertionError: assert <test_approx....x7f657f208880> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\n============================================= 1 failed in 0.01s =============================================\r\n```\r\n\r\n## Setup\r\n```\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            22.0.2\r\npluggy         1.3.0\r\npytest         7.4.4\r\nsetuptools     59.6.0\r\ntomli          2.0.1\r\n```\r\n\r\nAlso happens with pytest version 7.1.2 and 7.1.3\r\n\r\nOS is Ubuntu 22.04\r\n\n", "hints_text": "I digged into it a bit. `pytest.approx(MyVec3(1, 2, 3), abs=0.5)` results in an object of type `ApproxSequenceLike` which sound right to me. This is the check that is responsible for that:\r\n\r\n```python\r\n    elif (\r\n        hasattr(expected, \"__getitem__\")\r\n        and isinstance(expected, Sized)\r\n        # Type ignored because the error is wrong -- not unreachable.\r\n        and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]\r\n    ):\r\n        cls = ApproxSequenceLike\r\n```\r\n\r\nWhen generating the detailed output the `MyVec3` is wrapped in a `ApproxScalar`. When doing the same with a list `[1,2,3]`, then it is transformed into `[ApproxScalar(1), ApproxScalar(2), ApproxScalar(3)]`. This happens in `python_api.py::_recursive_sequence_map`:\r\n\r\n```python\r\n    if isinstance(x, (list, tuple)):\r\n        seq_type = type(x)\r\n        return seq_type(_recursive_sequence_map(f, xi) for xi in x)\r\n    else:\r\n        return f(x)\r\n```\r\n\r\nThis `isinstance(x, (list, tuple)` is much more narrow as `hasattr(expected, \"__getitem__\") and isinstance(expected, Sized) and not isinstance(expected, STRING_TYPES)` from above.\nReplacing `_recursive_sequence_map` with\r\n\r\n```python\r\ndef _recursive_sequence_map(f, x):\r\n    \"\"\"Recursively map a function over a sequence of arbitrary depth\"\"\"\r\n    if (\r\n        hasattr(x, \"__getitem__\")\r\n        and isinstance(x, Sized)\r\n        # Type ignored because the error is wrong -- not unreachable.\r\n        and not isinstance(x, STRING_TYPES)  # type: ignore[unreachable]\r\n    ):\r\n        if isinstance(x, (list, tuple)):\r\n            seq_type = type(x)\r\n        else:\r\n            seq_type = list\r\n        return seq_type(_recursive_sequence_map(f, xi) for xi in x)\r\n    else:\r\n        return f(x)\r\n```\r\n\r\nwould result in\r\n\r\n```\r\n    def test_vec_approx():\r\n        assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n>       assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\nE       assert <test_approx....x7f9c09e6ca60> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\nE         comparison failed. Mismatched elements: 3 / 3:\r\nE         Max absolute difference: 1\r\nE         Max relative difference: inf\r\nE         Index | Obtained | Expected   \r\nE         0     | 0        | 1 \u00b1 5.0e-01\r\nE         1     | 1        | 2 \u00b1 5.0e-01\r\nE         2     | 2        | 3 \u00b1 5.0e-01\r\n```\r\n\nApprox is not general,the support for lists as is, is already a stretch\n\n\nCustom collection objects are not easily supportable \nHi @RonnyPfannschmidt, I see your point and I'm of course totally fine with not changing code for a stretch use case! We would then just implement our own `MyVec` approx type.\r\n\r\nOn the other hand, `approx` accepts as input (`hasattr(x, \"__getitem__\") and isinstance(x, Sized)`) and also works as expected in terms of the comparison it performs. My idea would be to just make sure the `__repr__` of `ApproxSequenceLike` is on the same level.\r\n\r\nIf applying such a change would be considered, I would be happy to work on a proper MR.\nI need to do a little digging today,but it seems like a Good idea, I'll try to get it together soon \ni'm slightly hesitant to transform any custom collection into a list\r\nhowever since its only happen on the internal part of the compare we might be fine\r\n\r\n \r\nthat being said, the rep traceback shouldn't happen as well, i'll try to figure the exact exception\r\n\n```\r\nself = approx([1 \u00b1 5.0e-01, 2 \u00b1 5.0e-01, 3 \u00b1 5.0e-01])\r\nother_side = <approx.TestApprox.test_strange_sequence.<locals>.MyVec3 object at 0x7f8237a32d50>\r\n\r\n    def _repr_compare(self, other_side: Sequence[float]) -> List[str]:\r\n        import math\r\n    \r\n        if len(self.expected) != len(other_side):\r\n            return [\r\n                \"Impossible to compare lists with different sizes.\",\r\n                f\"Lengths: {len(self.expected)} and {len(other_side)}\",\r\n            ]\r\n    \r\n        approx_side_as_map = _recursive_sequence_map(self._approx_scalar, self.expected)\r\n    \r\n>       number_of_elements = len(approx_side_as_map)\r\nE       TypeError: object of type 'ApproxScalar' has no len()\r\n\r\n../../src/_pytest/python_api.py:332: TypeError\r\n```\r\n\r\ni have a error indicating reproducer i'll extract a is_sequencelike and use that\nI digged into it a bit. `pytest.approx(MyVec3(1, 2, 3), abs=0.5)` results in an object of type `ApproxSequenceLike` which sound right to me. This is the check that is responsible for that:\r\n\r\n```python\r\n    elif (\r\n        hasattr(expected, \"__getitem__\")\r\n        and isinstance(expected, Sized)\r\n        # Type ignored because the error is wrong -- not unreachable.\r\n        and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]\r\n    ):\r\n        cls = ApproxSequenceLike\r\n```\r\n\r\nWhen generating the detailed output the `MyVec3` is wrapped in a `ApproxScalar`. When doing the same with a list `[1,2,3]`, then it is transformed into `[ApproxScalar(1), ApproxScalar(2), ApproxScalar(3)]`. This happens in `python_api.py::_recursive_sequence_map`:\r\n\r\n```python\r\n    if isinstance(x, (list, tuple)):\r\n        seq_type = type(x)\r\n        return seq_type(_recursive_sequence_map(f, xi) for xi in x)\r\n    else:\r\n        return f(x)\r\n```\r\n\r\nThis `isinstance(x, (list, tuple)` is much more narrow as `hasattr(expected, \"__getitem__\") and isinstance(expected, Sized) and not isinstance(expected, STRING_TYPES)` from above.\nReplacing `_recursive_sequence_map` with\r\n\r\n```python\r\ndef _recursive_sequence_map(f, x):\r\n    \"\"\"Recursively map a function over a sequence of arbitrary depth\"\"\"\r\n    if (\r\n        hasattr(x, \"__getitem__\")\r\n        and isinstance(x, Sized)\r\n        # Type ignored because the error is wrong -- not unreachable.\r\n        and not isinstance(x, STRING_TYPES)  # type: ignore[unreachable]\r\n    ):\r\n        if isinstance(x, (list, tuple)):\r\n            seq_type = type(x)\r\n        else:\r\n            seq_type = list\r\n        return seq_type(_recursive_sequence_map(f, xi) for xi in x)\r\n    else:\r\n        return f(x)\r\n```\r\n\r\nwould result in\r\n\r\n```\r\n    def test_vec_approx():\r\n        assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=2)\r\n>       assert MyVec3(0, 1, 2) == pytest.approx(MyVec3(1, 2, 3), abs=0.5)\r\nE       assert <test_approx....x7f9c09e6ca60> == approx([1 \u00b1 5... 3 \u00b1 5.0e-01])\r\nE         comparison failed. Mismatched elements: 3 / 3:\r\nE         Max absolute difference: 1\r\nE         Max relative difference: inf\r\nE         Index | Obtained | Expected   \r\nE         0     | 0        | 1 \u00b1 5.0e-01\r\nE         1     | 1        | 2 \u00b1 5.0e-01\r\nE         2     | 2        | 3 \u00b1 5.0e-01\r\n```\r\n\nApprox is not general,the support for lists as is, is already a stretch\n\n\nCustom collection objects are not easily supportable \nHi @RonnyPfannschmidt, I see your point and I'm of course totally fine with not changing code for a stretch use case! We would then just implement our own `MyVec` approx type.\r\n\r\nOn the other hand, `approx` accepts as input (`hasattr(x, \"__getitem__\") and isinstance(x, Sized)`) and also works as expected in terms of the comparison it performs. My idea would be to just make sure the `__repr__` of `ApproxSequenceLike` is on the same level.\r\n\r\nIf applying such a change would be considered, I would be happy to work on a proper MR.\nI need to do a little digging today,but it seems like a Good idea, I'll try to get it together soon \ni'm slightly hesitant to transform any custom collection into a list\r\nhowever since its only happen on the internal part of the compare we might be fine\r\n\r\n \r\nthat being said, the rep traceback shouldn't happen as well, i'll try to figure the exact exception\r\n\n```\r\nself = approx([1 \u00b1 5.0e-01, 2 \u00b1 5.0e-01, 3 \u00b1 5.0e-01])\r\nother_side = <approx.TestApprox.test_strange_sequence.<locals>.MyVec3 object at 0x7f8237a32d50>\r\n\r\n    def _repr_compare(self, other_side: Sequence[float]) -> List[str]:\r\n        import math\r\n    \r\n        if len(self.expected) != len(other_side):\r\n            return [\r\n                \"Impossible to compare lists with different sizes.\",\r\n                f\"Lengths: {len(self.expected)} and {len(other_side)}\",\r\n            ]\r\n    \r\n        approx_side_as_map = _recursive_sequence_map(self._approx_scalar, self.expected)\r\n    \r\n>       number_of_elements = len(approx_side_as_map)\r\nE       TypeError: object of type 'ApproxScalar' has no len()\r\n\r\n../../src/_pytest/python_api.py:332: TypeError\r\n```\r\n\r\ni have a error indicating reproducer i'll extract a is_sequencelike and use that", "created_at": "2024-01-15T11:24:29Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11804, "instance_id": "pytest-dev__pytest-11804", "issue_numbers": ["10865"], "base_commit": "aaa9ca7327de16ca07e5d169e4cf1ad5d810d1da", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 87909762263..25159b8b07f 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -416,6 +416,7 @@ Vivaan Verma\n Vlad Dragos\n Vlad Radziuk\n Vladyslav Rachek\n+Volodymyr Kochetkov\n Volodymyr Piskun\n Wei Lin\n Wil Cooley\ndiff --git a/changelog/10865.improvement.rst b/changelog/10865.improvement.rst\nnew file mode 100644\nindex 00000000000..2c2856dfe96\n--- /dev/null\n+++ b/changelog/10865.improvement.rst\n@@ -0,0 +1,2 @@\n+:func:`pytest.warns` now validates that warning object's ``message`` is of type  `str` -- currently in Python it is possible to pass other types than `str` when creating `Warning` instances, however this causes an exception when :func:`warnings.filterwarnings` is used to filter those warnings. See `CPython #103577 <https://github.com/python/cpython/issues/103577>`__ for a discussion.\n+While this can be considered a bug in CPython, we decided to put guards in pytest as the error message produced without this check in place is confusing.\n", "test_patch": "diff --git a/src/_pytest/recwarn.py b/src/_pytest/recwarn.py\nindex aa58d43b405..62df274bd37 100644\n--- a/src/_pytest/recwarn.py\n+++ b/src/_pytest/recwarn.py\n@@ -329,3 +329,14 @@ def found_str():\n                         module=w.__module__,\n                         source=w.source,\n                     )\n+            # Check warnings has valid argument type (#10865).\n+            wrn: warnings.WarningMessage\n+            for wrn in self:\n+                self._validate_message(wrn)\n+\n+    @staticmethod\n+    def _validate_message(wrn: Any) -> None:\n+        if not isinstance(msg := wrn.message.args[0], str):\n+            raise TypeError(\n+                f\"Warning message must be str, got {msg!r} (type {type(msg).__name__})\"\n+            )\ndiff --git a/testing/test_recwarn.py b/testing/test_recwarn.py\nindex 5045c781e1f..e269bd7ddc9 100644\n--- a/testing/test_recwarn.py\n+++ b/testing/test_recwarn.py\n@@ -1,4 +1,5 @@\n # mypy: allow-untyped-defs\n+import sys\n from typing import List\n from typing import Optional\n from typing import Type\n@@ -477,3 +478,29 @@ def test_catch_warning_within_raise(self) -> None:\n             with pytest.raises(ValueError, match=\"some exception\"):\n                 warnings.warn(\"some warning\", category=FutureWarning)\n                 raise ValueError(\"some exception\")\n+\n+\n+def test_raise_type_error_on_non_string_warning() -> None:\n+    \"\"\"Check pytest.warns validates warning messages are strings (#10865).\"\"\"\n+    with pytest.raises(TypeError, match=\"Warning message must be str\"):\n+        with pytest.warns(UserWarning):\n+            warnings.warn(1)  # type: ignore\n+\n+\n+def test_no_raise_type_error_on_string_warning() -> None:\n+    \"\"\"Check pytest.warns validates warning messages are strings (#10865).\"\"\"\n+    with pytest.warns(UserWarning):\n+        warnings.warn(\"Warning\")\n+\n+\n+@pytest.mark.skipif(\n+    hasattr(sys, \"pypy_version_info\"),\n+    reason=\"Not for pypy\",\n+)\n+def test_raise_type_error_on_non_string_warning_cpython() -> None:\n+    # Check that we get the same behavior with the stdlib, at least if filtering\n+    # (see https://github.com/python/cpython/issues/103577 for details)\n+    with pytest.raises(TypeError):\n+        with warnings.catch_warnings():\n+            warnings.filterwarnings(\"ignore\", \"test\")\n+            warnings.warn(1)  # type: ignore\n", "problem_statement": "`pytest.warns` hides type errors in `warnings.warn` calls\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- ~[ ] output of `pip list` from the virtual environment you are using~\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\nWhen using `pytest.warns`, incorrect values sent to `warnings.warn` are not reported obscuring bugs:\r\n\r\n```python\r\nimport pytest\r\nimport warnings\r\n\r\n\r\ndef test_example_one():\r\n    with pytest.warns(UserWarning):\r\n        warnings.warn(1)\r\n\r\n    # This test passes but should raise a `TypeError` as demonstrated in `example_two`\r\n\r\n\r\ndef test_example_two():\r\n    with pytest.raises(TypeError):\r\n        warnings.warn(1)\r\n```\r\n\r\n```\r\nmacOS 13.2.1\r\npytest 7.2.2\r\npython 3.11\r\n```\r\n\r\nRelated to https://github.com/pytest-dev/pytest/issues/9288\n", "hints_text": "Hmm that's unfortunate, thanks for the report!\r\n\r\nShould be simple to fix.\nYou're welcome! Certainly confused me for a minute :)\r\n\r\nI'm happy to contribute a fix \u2014 want to just raise a type error if it's not a string? Looks like CPython allows `Warning` types too https://github.com/python/cpython/blob/f513d5c80672c76acbdaf7d5b601f4bbe9fae56a/Lib/warnings.py#L299-L301\nWhile trying to find the logic where this `TypeError` is raised I've gotten a bit confused. Weirdly this is fine\r\n\r\n```\r\n\u276f python -c \"import warnings; warnings.warn(1)\"\r\n<string>:1: UserWarning: 1\r\n```\r\n\r\nbut the `TypeError` is definitely raised in pytest i.e. if I remove the `pytest.raises`:\r\n\r\n```\r\n    def test_example_two():\r\n>       warnings.warn(1)\r\nE       TypeError: expected string or bytes-like object, got 'int'\r\n```\r\n\r\nI feel like this caused me an error outside of pytest as well though\nAre you sure? This works for me:\r\n\r\n```python\r\nimport warnings\r\ndef test_example_two():\r\n    warnings.warn(1)\r\n```\r\n\r\nWhich Python and pytest versions are you using?\nThe Python and pytest versions are included in the original post, but consider me very confused \u2014 I did not reproduce this with the minimal example and a test matrix at https://github.com/madkinsz/pytest-10865/actions/runs/4714285419/jobs/8360551859\r\n\r\nIt does however reproduce quite clearly when I'm working in `PrefectHQ/prefect`. Here's the example running in our test suite https://github.com/PrefectHQ/prefect/pull/9231\nThe issue appears to be related to `filterwarnings`, for example:\r\n\r\n```python\r\nimport warnings\r\n\r\n# Does not raise a type error\r\nwarnings.warn(1)\r\n\r\n# Raises a type error\r\nwith warnings.catch_warnings():\r\n    warnings.filterwarnings(\"ignore\", \"test\")\r\n    warnings.warn(1)\r\n```\r\n\r\nwith the addition of a warnings filter to pytest https://github.com/madkinsz/pytest-10865/commit/1c3e4e37aa1fb7453bfe80946b50f391dd51d32a the type error is raised on all Python and 7.x pytest versions https://github.com/madkinsz/pytest-10865/actions/runs/4714336351\nI've opened a CPython issue as this doesn't really seem like pytest's fault https://github.com/python/cpython/issues/103577 but pytest probably shouldn't hide this error still.\n@nicoddemus I don't expect there to be changes upstream for this. Should we validate that argument is of the correct type in pytest?\nas far as im concerned, type metadata in typeshed is provided, and my understandig is, that it would point to the error\n@RonnyPfannschmidt the problem here is that when using `filterwarnings` the `TypeError` is raised outside of pytest but not raised inside `pytest.warns` blocks. This means that an error that can occur at runtime for users is hidden during execution of the test suite. I agree that this mistake would also be caught by a type-checker, but many people do not use static analysis tools and it feels rough to obscure the error that the standard library would raise.\nRetagging as bug based on upstream discussion, where consensus looks like \"this should always error\" and CPython may change accordingly.", "created_at": "2024-01-12T07:00:58Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11760, "instance_id": "pytest-dev__pytest-11760", "issue_numbers": ["11758"], "base_commit": "a53984a55b35235a21b4142822a9dd10d7e995f1", "patch": "diff --git a/changelog/11758.bugfix.rst b/changelog/11758.bugfix.rst\nnew file mode 100644\nindex 00000000000..af8a3f3514f\n--- /dev/null\n+++ b/changelog/11758.bugfix.rst\n@@ -0,0 +1,2 @@\n+Fixed ``IndexError: string index out of range`` crash in ``if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\"``.\n+This bug was introduced in pytest 8.0.0rc1.\n", "test_patch": "diff --git a/src/_pytest/_io/terminalwriter.py b/src/_pytest/_io/terminalwriter.py\nindex bf9b7665194..56107d56647 100644\n--- a/src/_pytest/_io/terminalwriter.py\n+++ b/src/_pytest/_io/terminalwriter.py\n@@ -200,8 +200,9 @@ def _highlight(\n         \"\"\"Highlight the given source if we have markup support.\"\"\"\n         from _pytest.config.exceptions import UsageError\n \n-        if not self.hasmarkup or not self.code_highlight:\n+        if not source or not self.hasmarkup or not self.code_highlight:\n             return source\n+\n         try:\n             from pygments.formatters.terminal import TerminalFormatter\n \ndiff --git a/testing/io/test_terminalwriter.py b/testing/io/test_terminalwriter.py\nindex 96e7366e543..c7e63c67284 100644\n--- a/testing/io/test_terminalwriter.py\n+++ b/testing/io/test_terminalwriter.py\n@@ -306,3 +306,17 @@ def test_code_highlight(has_markup, code_highlight, expected, color_mapping):\n         match=re.escape(\"indents size (2) should have same size as lines (1)\"),\n     ):\n         tw._write_source([\"assert 0\"], [\" \", \" \"])\n+\n+\n+def test_highlight_empty_source() -> None:\n+    \"\"\"Don't crash trying to highlight empty source code.\n+\n+    Issue #11758.\n+    \"\"\"\n+    f = io.StringIO()\n+    tw = terminalwriter.TerminalWriter(f)\n+    tw.hasmarkup = True\n+    tw.code_highlight = True\n+    tw._write_source([])\n+\n+    assert f.getvalue() == \"\"\n", "problem_statement": "Bug with prerelease pytest\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [ ] minimal example if possible\r\n\r\nIn our prerelease CIs we now get an internal error with 8.0.0rc1:\r\n\r\nhttps://github.com/mne-tools/mne-python/actions/runs/7387584833/job/20096612938?pr=12330#step:15:4411\r\n\r\n```\r\n_______________________________ test_dir_warning _______________________________\r\nmne/_fiff/tests/test_meas_info.py:355: in test_dir_warning\r\n    read_info(ctf_fname)\r\n<decorator-gen-34>:12: in read_info\r\n    ???\r\nmne/_fiff/meas_info.py:2045: in read_info\r\n    fname = _check_fname(fname, must_exist=True, overwrite=\"read\")\r\n<decorator-gen-0>:12: in _check_fname\r\n    ???\r\nmne/utils/check.py:255: in _check_fname\r\n    raise OSError(\r\nE   OSError: Need a file for File but found a directory at /home/runner/mne_data/MNE-testing-data/CTF/testdata_ctf.ds\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n    tw._write_source(source_lines, indents)\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_io/terminalwriter.py\", line 193, in _write_source\r\n    new_lines = self._highlight(source).splitlines()\r\n                ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages/_pytest/_io/terminalwriter.py\", line 228, in _highlight\r\n    if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\":\r\n                                   ~~~~~~^^^^\r\nIndexError: string index out of range\r\nError: Process completed with exit code 1.\r\n```\r\nThat's on Linux, but locally I can reproduce on reproduce on macOS arm64 as well:\r\n```\r\n$ pytest mne/_fiff/tests/test_meas_info.py --pdb\r\n...\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/reports.py\", line 88, in toterminal\r\nINTERNALERROR>     longrepr_terminal.toterminal(out)\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_code/code.py\", line 1140, in toterminal\r\nINTERNALERROR>     element[0].toterminal(tw)\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_code/code.py\", line 1170, in toterminal\r\nINTERNALERROR>     entry.toterminal(tw)\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_code/code.py\", line 1257, in toterminal\r\nINTERNALERROR>     self._write_entry_lines(tw)\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_code/code.py\", line 1247, in _write_entry_lines\r\nINTERNALERROR>     tw._write_source(source_lines, indents)\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_io/terminalwriter.py\", line 193, in _write_source\r\nINTERNALERROR>     new_lines = self._highlight(source).splitlines()\r\nINTERNALERROR>                 ^^^^^^^^^^^^^^^^^^^^^^^\r\nINTERNALERROR>   File \"/Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_io/terminalwriter.py\", line 228, in _highlight\r\nINTERNALERROR>     if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\":\r\nINTERNALERROR>                                    ~~~~~~^^^^\r\nINTERNALERROR> IndexError: string index out of range\r\n\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PDB post_mortem (IO-capturing turned off) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n> /Users/larsoner/Applications/MNE-Python/1.6.0_0/.mne-python/lib/python3.11/site-packages/_pytest/_io/terminalwriter.py(228)_highlight()\r\n-> if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\":\r\n(Pdb) p source\r\n''\r\n(Pdb) \r\n```\r\nNot really minimal (at all!) and it's not trivial to get the MNE tests running locally, so let me know if additional debugging at my end would be helpful. But maybe it's enough to know that `source` has length zero so `source[-1]` will fail here?\r\n\r\nEnv info:\r\n```\r\n$ pip list | grep pytest\r\npytest                        8.0.0rc1\r\npytest-cov                    4.1.0\r\npytest-harvest                1.10.4\r\npytest-qt                     4.2.0\r\npytest-timeout                2.2.0\r\n```\n", "hints_text": "Thanks for trying the release candidate!\r\n\r\n> But maybe it's enough to know that source has length zero so source[-1] will fail here?\r\n\r\nYes, I think the fix is just a matter of adding \r\n\r\n```py\r\nif not source:\r\n   return source\r\n```\r\n\r\nto the top of `_highlight`.\r\n\r\nFor a regression test, it would nice to reproduce the empty source, I will try see how to do it.\r\n\r\n---\r\n\r\nRegarding the error `E   OSError: Need a file for File but found a directory at /home/runner/mne_data/MNE-testing-data/CTF/testdata_ctf.ds`, this is something expected from your side, not something in the new pytest in itself, right?\n> Regarding the error E   OSError: Need a file for File but found a directory at /home/runner/mne_data/MNE-testing-data/CTF/testdata_ctf.ds, this is something expected from your side, not something in the new pytest in itself, right?\r\n\r\nYes that part is just at our end, thanks for the quick response!", "created_at": "2024-01-02T17:37:50Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11739, "instance_id": "pytest-dev__pytest-11739", "issue_numbers": ["11738"], "base_commit": "2c5c97b6d150b21860ac18a40856f960b5fbcbf8", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 42cfd0be249..14a35c3d5c3 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -242,6 +242,7 @@ Marc Mueller\n Marc Schlaich\n Marcelo Duarte Trevisani\n Marcin Bachry\n+Marc Bresson\n Marco Gorelli\n Mark Abramowitz\n Mark Dickinson\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex b2b63a89edc..5ad4672afec 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -2086,7 +2086,7 @@ All the command-line flags can be obtained by running ``pytest --help``::\n \n     [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg|pyproject.toml file found:\n \n-      markers (linelist):   Markers for test functions\n+      markers (linelist):   Register new markers for test functions\n       empty_parameter_set_mark (string):\n                             Default marker for empty parametersets\n       norecursedirs (args): Directory patterns to avoid for recursion\n", "test_patch": "diff --git a/src/_pytest/mark/__init__.py b/src/_pytest/mark/__init__.py\nindex de46b4c8a75..6f4180a3a56 100644\n--- a/src/_pytest/mark/__init__.py\n+++ b/src/_pytest/mark/__init__.py\n@@ -105,7 +105,7 @@ def pytest_addoption(parser: Parser) -> None:\n         help=\"show markers (builtin, plugin and per-project ones).\",\n     )\n \n-    parser.addini(\"markers\", \"Markers for test functions\", \"linelist\")\n+    parser.addini(\"markers\", \"Register new markers for test functions\", \"linelist\")\n     parser.addini(EMPTY_PARAMETERSET_OPTION, \"Default marker for empty parametersets\")\n \n \n", "problem_statement": "markers defined in pytest.ini or pyproject.toml are not considered. It does work when using the command line\n# problem\r\n\r\nWhen I use markers in `pyproject.toml` or in `pytest.ini`, all tests are selected.\r\n\r\n`pyproject.toml` (I make sure to delete pytest.ini when this config was tested)\r\n```\r\n[tool.pytest.ini_options]\r\npythonpath = \".\"\r\naddopts = \"--strict-markers\"\r\nmarkers = [\r\n    \"slow: mark a test that takes a long time to run.\",\r\n]\r\n```\r\n\r\n> platform darwin -- Python 3.10.11, pytest-7.4.3, pluggy-1.3.0\r\n> rootdir: /Users/datategy/Documents/o2_ml\r\n> configfile: pyproject.toml\r\n> plugins: fugue-0.8.7, anyio-4.2.0\r\n> collected 3 items\r\n\r\n`pytest.ini`\r\n```\r\n[pytest]\r\npythonpath = .\r\naddopts = --strict-markers\r\nmarkers =\r\n    slow\r\n```\r\n\r\n> platform darwin -- Python 3.10.11, pytest-7.4.3, pluggy-1.3.0\r\n> rootdir: /Users/datategy/Documents/o2_ml\r\n> configfile: pytest.ini\r\n> plugins: fugue-0.8.7, anyio-4.2.0\r\n> collected 3 items\r\n\r\nHowever, when I try with the command line, it works perfectly and only select the tests marked with 'slow'\r\n\r\n```\r\npytest -m slow\r\n```\r\n\r\n> platform darwin -- Python 3.10.11, pytest-7.4.3, pluggy-1.3.0\r\n> rootdir: /Users/datategy/Documents/o2_ml\r\n> configfile: pyproject.toml\r\n> plugins: fugue-0.8.7, anyio-4.2.0\r\n> collected 3 items / 2 deselected / 1 selected\r\n\r\n# my test\r\n\r\n```python\r\n@pytest.mark.slow\r\n@pytest.mark.parametrize(\"params_model\", params_slow_model)\r\ndef test_slow_ts_forecasting(params_model):\r\n    ...\r\n```\r\n\r\n# environment\r\n\r\npython 3.10.11\r\npytest 7.4.3\r\nChip Apple M2\r\nMacOS 13.2 (22D49)\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [ ] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [ ] minimal example if possible\r\n\n", "hints_text": "the markers ini option is for making markers known (so strict markers can be used to fail on typos instead of just warning\r\n\r\nthe mark expressions do not have a ini variant and must be passed in addopts - its strongly recommended not to do that for lack of a reverse/reset of those options\nok, thank you for the explanation ! Does that mean there is no way to have default markers enabled when running the `pytest` command?\r\n\r\nI could create a shell script that just calls `pytest -m \"not slow\"` but that does not seem right.\nhttps://pypi.org/project/pytest-skip-slow/ is a example of a plugin implementing the pattern\r\n\r\nits possible to override the default marker expression on the cli, but its confusing, thus its not recommended\r\n\r\n\nok thank you very much for your help.\r\n\r\nClosing this issue.\nAny reason why \"`the mark expressions do not have a ini variant`\"?\r\n\r\nBtw, i'm gonna open a pull request to clarify the role of the `marker` property in pytest.ini", "created_at": "2023-12-26T10:57:50Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11721, "instance_id": "pytest-dev__pytest-11721", "issue_numbers": ["11706"], "base_commit": "f017df443a589494b0a47488b1616db7c12dc8cd", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 14a35c3d5c3..67e794527fb 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -54,6 +54,7 @@ Aviral Verma\n Aviv Palivoda\n Babak Keyvani\n Barney Gale\n+Ben Brown\n Ben Gartner\n Ben Webb\n Benjamin Peterson\ndiff --git a/changelog/11706.bugfix.rst b/changelog/11706.bugfix.rst\nnew file mode 100644\nindex 00000000000..1b90d8f0b60\n--- /dev/null\n+++ b/changelog/11706.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fix reporting of teardown errors in higher-scoped fixtures when using `--maxfail` or `--stepwise`.\n", "test_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 9fb96840e5c..51be84164b2 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -6,6 +6,7 @@\n import importlib\n import os\n import sys\n+import warnings\n from pathlib import Path\n from typing import AbstractSet\n from typing import Callable\n@@ -44,6 +45,7 @@\n from _pytest.reports import TestReport\n from _pytest.runner import collect_one_node\n from _pytest.runner import SetupState\n+from _pytest.warning_types import PytestWarning\n \n \n def pytest_addoption(parser: Parser) -> None:\n@@ -548,8 +550,8 @@ def __init__(self, config: Config) -> None:\n         )\n         self.testsfailed = 0\n         self.testscollected = 0\n-        self.shouldstop: Union[bool, str] = False\n-        self.shouldfail: Union[bool, str] = False\n+        self._shouldstop: Union[bool, str] = False\n+        self._shouldfail: Union[bool, str] = False\n         self.trace = config.trace.root.get(\"collection\")\n         self._initialpaths: FrozenSet[Path] = frozenset()\n         self._initialpaths_with_parents: FrozenSet[Path] = frozenset()\n@@ -576,6 +578,42 @@ def __repr__(self) -> str:\n             self.testscollected,\n         )\n \n+    @property\n+    def shouldstop(self) -> Union[bool, str]:\n+        return self._shouldstop\n+\n+    @shouldstop.setter\n+    def shouldstop(self, value: Union[bool, str]) -> None:\n+        # The runner checks shouldfail and assumes that if it is set we are\n+        # definitely stopping, so prevent unsetting it.\n+        if value is False and self._shouldstop:\n+            warnings.warn(\n+                PytestWarning(\n+                    \"session.shouldstop cannot be unset after it has been set; ignoring.\"\n+                ),\n+                stacklevel=2,\n+            )\n+            return\n+        self._shouldstop = value\n+\n+    @property\n+    def shouldfail(self) -> Union[bool, str]:\n+        return self._shouldfail\n+\n+    @shouldfail.setter\n+    def shouldfail(self, value: Union[bool, str]) -> None:\n+        # The runner checks shouldfail and assumes that if it is set we are\n+        # definitely stopping, so prevent unsetting it.\n+        if value is False and self._shouldfail:\n+            warnings.warn(\n+                PytestWarning(\n+                    \"session.shouldfail cannot be unset after it has been set; ignoring.\"\n+                ),\n+                stacklevel=2,\n+            )\n+            return\n+        self._shouldfail = value\n+\n     @property\n     def startpath(self) -> Path:\n         \"\"\"The path from which pytest was invoked.\ndiff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex e20338520eb..3e19f0de50c 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -131,6 +131,10 @@ def runtestprotocol(\n             show_test_item(item)\n         if not item.config.getoption(\"setuponly\", False):\n             reports.append(call_and_report(item, \"call\", log))\n+    # If the session is about to fail or stop, teardown everything - this is\n+    # necessary to correctly report fixture teardown errors (see #11706)\n+    if item.session.shouldfail or item.session.shouldstop:\n+        nextitem = None\n     reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n     # After all teardown hooks have been called\n     # want funcargs and request info to go away.\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex c8b646857e7..26f5b9a0bc2 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -1087,3 +1087,53 @@ def func() -> None:\n     with pytest.raises(TypeError) as excinfo:\n         OutcomeException(func)  # type: ignore\n     assert str(excinfo.value) == expected\n+\n+\n+def test_teardown_session_failed(pytester: Pytester) -> None:\n+    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n+    item after the test session bails early due to --maxfail.\n+\n+    Regression test for #11706.\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.fixture(scope=\"module\")\n+        def baz():\n+            yield\n+            pytest.fail(\"This is a failing teardown\")\n+\n+        def test_foo(baz):\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--maxfail=1\")\n+    result.assert_outcomes(failed=1, errors=1)\n+\n+\n+def test_teardown_session_stopped(pytester: Pytester) -> None:\n+    \"\"\"Test that higher-scoped fixture teardowns run in the context of the last\n+    item after the test session bails early due to --stepwise.\n+\n+    Regression test for #11706.\n+    \"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.fixture(scope=\"module\")\n+        def baz():\n+            yield\n+            pytest.fail(\"This is a failing teardown\")\n+\n+        def test_foo(baz):\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--stepwise\")\n+    result.assert_outcomes(failed=1, errors=1)\ndiff --git a/testing/test_session.py b/testing/test_session.py\nindex 136e85eb640..803bbed5434 100644\n--- a/testing/test_session.py\n+++ b/testing/test_session.py\n@@ -418,3 +418,63 @@ def test_rootdir_wrong_option_arg(pytester: Pytester) -> None:\n     result.stderr.fnmatch_lines(\n         [\"*Directory *wrong_dir* not found. Check your '--rootdir' option.*\"]\n     )\n+\n+\n+def test_shouldfail_is_sticky(pytester: Pytester) -> None:\n+    \"\"\"Test that session.shouldfail cannot be reset to False after being set.\n+\n+    Issue #11706.\n+    \"\"\"\n+    pytester.makeconftest(\n+        \"\"\"\n+        def pytest_sessionfinish(session):\n+            assert session.shouldfail\n+            session.shouldfail = False\n+            assert session.shouldfail\n+        \"\"\"\n+    )\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        def test_foo():\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+\n+    result = pytester.runpytest(\"--maxfail=1\", \"-Wall\")\n+\n+    result.assert_outcomes(failed=1, warnings=1)\n+    result.stdout.fnmatch_lines(\"*session.shouldfail cannot be unset*\")\n+\n+\n+def test_shouldstop_is_sticky(pytester: Pytester) -> None:\n+    \"\"\"Test that session.shouldstop cannot be reset to False after being set.\n+\n+    Issue #11706.\n+    \"\"\"\n+    pytester.makeconftest(\n+        \"\"\"\n+        def pytest_sessionfinish(session):\n+            assert session.shouldstop\n+            session.shouldstop = False\n+            assert session.shouldstop\n+        \"\"\"\n+    )\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        def test_foo():\n+            pytest.fail(\"This is a failing test\")\n+\n+        def test_bar(): pass\n+        \"\"\"\n+    )\n+\n+    result = pytester.runpytest(\"--stepwise\", \"-Wall\")\n+\n+    result.assert_outcomes(failed=1, warnings=1)\n+    result.stdout.fnmatch_lines(\"*session.shouldstop cannot be unset*\")\n", "problem_statement": "Pytest aborts when fixture errors during teardown and `--maxfail=1`\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\n## Description\r\n\r\nPytest aborts if a session-scoped fixture errors during teardown when (a) one or more test cases fail and (b) `--maxfail=1` is used.\r\n\r\nWhen this happens, `test-report.xml` does not contain the teardown fixture error. This is problematic as users may want to also record teardown fixture errors when their test cases fail.\r\n\r\n## Minimal Example\r\n\r\n### Code\r\n\r\n```python\r\nimport pytest\r\n\r\n\r\ndef some_condition() -> bool:\r\n    return True\r\n\r\n\r\n@pytest.fixture(scope=\"session\", autouse=True)\r\ndef my_end_of_session_check():\r\n    yield\r\n\r\n    print(\"Running end of session check!\")\r\n    if some_condition():\r\n        pytest.fail(\"Oh noes\")\r\n\r\n\r\ndef test_case_1():\r\n    pytest.fail(\"This is a failing test\")\r\n\r\n\r\ndef test_case_2():\r\n     pytest.fail(\"This is also a failing test\")\r\n```\r\n\r\n### Args\r\n\r\n`pytest example.py --maxfail=1 --junitxml=test-report.xml`\r\n\r\n### Output\r\n\r\nConsole:\r\n\r\n```txt\r\n============================================================================== test session starts ===============================================================================\r\nplatform darwin -- Python 3.8.13, pytest-7.4.3, pluggy-1.3.0\r\nrootdir: /Users/bbrown/Downloads\r\ncollected 2 items\r\n\r\nexample.py FRunning end of session check!\r\nTraceback (most recent call last):\r\n  File \"/Users/bbrown/Downloads/.venv/bin/pytest\", line 8, in <module>\r\n    sys.exit(console_main())\r\n  <clipped>\r\n  File \"/Users/bbrown/Downloads/.venv/lib/python3.8/site-packages/_pytest/fixtures.py\", line 911, in _teardown_yield_fixture\r\n    next(it)\r\n  File \"/Users/bbrown/Downloads/example.py\", line 14, in my_end_of_session_check\r\n    pytest.fail(\"Oh noes\")\r\n  File \"/Users/bbrown/Downloads/.venv/lib/python3.8/site-packages/_pytest/outcomes.py\", line 198, in fail\r\n    raise Failed(msg=reason, pytrace=pytrace)\r\nFailed: Oh noes\r\n```\r\n\r\n`test-report.xml`:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites><testsuite name=\"pytest\" errors=\"0\" failures=\"1\" skipped=\"0\" tests=\"1\" time=\"0.035\" timestamp=\"2023-12-15T08:56:19.980572\" hostname=\"macbookpro\"><testcase classname=\"example\" name=\"test_case_1\" time=\"0.001\"><failure message=\"Failed: This is a failing test\">def test_case_1():\r\n&gt;       pytest.fail(\"This is a failing test\")\r\nE       Failed: This is a failing test\r\n\r\nexample.py:18: Failed</failure></testcase></testsuite></testsuites>\r\n```\r\n\r\n### Expected Output\r\n\r\nI expect pytest to not abort, and report \"1 failed, 1 error, 1 skipped\" in both the console and `test-report.xml` when this happens.\r\n\r\n### Environment\r\n\r\n__OS:__\r\n\r\nmacOS Sonoma 14.1.2\r\n\r\n__Virtual environment:__\r\n\r\n```txt\r\n(.venv) % pip list\r\nPackage        Version\r\n-------------- -------\r\nexceptiongroup 1.2.0\r\niniconfig      2.0.0\r\npackaging      23.2\r\npip            23.3.1\r\npluggy         1.3.0\r\npytest         7.4.3\r\nsetuptools     56.0.0\r\ntomli          2.0.1\r\n```\n", "hints_text": "Note that this also happens when the fixture is `module` scoped, but does _not_ happen if the fixture is `function` scoped. Will update the issue name to indicate this.\nThis is an interesting edge case you've stumbled upon.\r\n\r\n### Background\r\n\r\npytest's setups/teardowns are managed by the [`SetupState`](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/runner.py#L401) class.\r\n\r\nYou can see the docstring for how it works, but the important part here is that we're tearing down some `item` (test), we look at the next item (`nextitem`), see which fixtures the nextitem won't be needing, and tear them down in the context of `item`. In particular, the last item gets `nextitem = None` which tears down everything.\r\n\r\nWhen `--maxfail=N` is used (or `-x` which is alias for `--maxfail=1`), if the N failures are reached, the runner [sets `session.shouldfail = ...`](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/main.py#L547-L548C20), then the runner loop checks it and [exits the loop](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/main.py#L355-L356).\r\n\r\n### Problem\r\n\r\nLet's call the Nth failing test \"test N\" and assume there is at least one test after it, \"test N + 1\", which shares some higher-scoped fixtures.\r\n\r\n\"test N\" is torn down with `nextitem = test N + 1`, then `shouldfail` is set and the loop exits. But, all of the remaining fixtures weren't torn down because nothing told them to.\r\n\r\nTo fix this, pytest in a last ditch effort runs the remaining teardowns in a [`pytest_sessionfinish` hook](https://github.com/pytest-dev/pytest/blob/047ba83dabe492af938104fe0058597f67a672be/src/_pytest/runner.py#L106-L107). \r\n\r\nBut this `pytest_sessionfinish` hook currently is not written to handle exceptions, except for `pytest.exit`, even though it executes user code. So if one of the remaining teardowns raises, the exception just propagates.\r\n\r\n### Possible solution 1\r\n\r\nCatch the exceptions from the `pytest_sessionfinish` and issue some warning.\r\n\r\nThis would work, however then the teardown failures aren't reported in the context of any test. In particular they won't show in any xml reports and such.\r\n\r\n### Possible solution 2\r\n\r\nDetect when an item had set `shouldfail = True`, then instead of tearing it down with `nextitem = item N+1`, tear it down with `nextitem = None`.\r\n\r\nThis would work and run the teardowns in the context of the test, but is a bit dangerous - doesn't handle the case where plugins reset `shouldfail`. Also, I think there are other cases where we bail early, those would still need `pytest_sessionfinish` and the problem would still be possible there.\nThanks for the detailed reply @bluetech! \r\n\r\nThe real pain point here is the lack of reporting - my team's observability tools consume `test-report.xml` and want all errors/failures to be reported such that we can triage them. Because of that, I'll try to investigate _Possible solution 2_ you've outlined above.\n> Detect when an item had set shouldfail = True, then instead of tearing it down with nextitem = item N+1, tear it down with nextitem = None.\r\n\r\nThis was pretty easy to implement, basically a one-line change in `pytest_runtest_teardown`:\r\n\r\n```python\r\ndef pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\r\n    _update_current_test_var(item, \"teardown\")\r\n    nextitem = None if item.session.shouldfail else nextitem\r\n    item.session._setupstate.teardown_exact(nextitem)\r\n    _update_current_test_var(item, None)\r\n```\r\n\r\nI also added a unittest in `test_runner.py` mimicking the sample code above. I can open a PR with this change, however I'm not sure what to do about these comments:\r\n\r\n> This would work and run the teardowns in the context of the test, but is a bit dangerous - doesn't handle the case where plugins reset shouldfail. \r\n\r\nA plugin resetting `shouldfail` feels like even more of an edge-case, not sure if we should be that concerned about it?\r\n\r\n> Also, I think there are other cases where we bail early, those would still need pytest_sessionfinish and the problem would still be possible there.\r\n\r\nI'm not really following this comment, likely just due to my lack of context about the codebase.\r\n", "created_at": "2023-12-18T16:32:29Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11711, "instance_id": "pytest-dev__pytest-11711", "issue_numbers": ["11710"], "base_commit": "047ba83dabe492af938104fe0058597f67a672be", "patch": "diff --git a/changelog/11710.bugfix.rst b/changelog/11710.bugfix.rst\nnew file mode 100644\nindex 00000000000..4bbf9fa2e7d\n--- /dev/null\n+++ b/changelog/11710.bugfix.rst\n@@ -0,0 +1,1 @@\n+Fixed tracebacks from collection errors not getting pruned.\n", "test_patch": "diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 183f3c9d958..c942fab9a16 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -579,7 +579,7 @@ def _traceback_filter(self, excinfo: ExceptionInfo[BaseException]) -> Traceback:\n             ntraceback = traceback.cut(path=self.path)\n             if ntraceback == traceback:\n                 ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n-            return excinfo.traceback.filter(excinfo)\n+            return ntraceback.filter(excinfo)\n         return excinfo.traceback\n \n \ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex b2492f7f28f..6c3d2a30565 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -345,6 +345,29 @@ def pytest_make_collect_report():\n         result = pytester.runpytest(p)\n         result.stdout.fnmatch_lines([\"*ERROR collecting*\", \"*header1*\"])\n \n+    def test_collection_error_traceback_is_clean(self, pytester: Pytester) -> None:\n+        \"\"\"When a collection error occurs, the report traceback doesn't contain\n+        internal pytest stack entries.\n+\n+        Issue #11710.\n+        \"\"\"\n+        pytester.makepyfile(\n+            \"\"\"\n+            raise Exception(\"LOUSY\")\n+            \"\"\"\n+        )\n+        result = pytester.runpytest()\n+        result.stdout.fnmatch_lines(\n+            [\n+                \"*ERROR collecting*\",\n+                \"test_*.py:1: in <module>\",\n+                '    raise Exception(\"LOUSY\")',\n+                \"E   Exception: LOUSY\",\n+                \"*= short test summary info =*\",\n+            ],\n+            consecutive=True,\n+        )\n+\n \n class TestCustomConftests:\n     def test_ignore_collect_path(self, pytester: Pytester) -> None:\n", "problem_statement": "Tracebacks from collection errors are not pruned\nThis is a regression in pytest 7.4 from commit fcada1ea4763c0e3471cd58ac4b89e7c874e6264.\r\n\r\nGiven a test module\r\n\r\n```py\r\nraise Exception('foo')\r\n```\r\n\r\nExpected output:\r\n\r\n```\r\n_______ ERROR collecting yy/test_y.py _______\r\nyy/test_y.py:1: in <module>\r\n    raise Exception('foo')\r\nE   Exception: foo\r\n```\r\n\r\nActual output:\r\n\r\n```\r\n_______ ERROR collecting yy/test_y.py _______\r\nsrc/_pytest/runner.py:340: in from_call\r\n    result: Optional[TResult] = func()\r\nsrc/_pytest/runner.py:371: in <lambda>\r\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\r\nsrc/_pytest/python.py:579: in collect\r\n    self._inject_setup_module_fixture()\r\nsrc/_pytest/python.py:593: in _inject_setup_module_fixture\r\n    self.obj, (\"setUpModule\", \"setup_module\")\r\nsrc/_pytest/python.py:307: in obj\r\n    self._obj = obj = self._getobj()\r\nsrc/_pytest/python.py:576: in _getobj\r\n    return importtestmodule(self.path, self.config)\r\nsrc/_pytest/python.py:528: in importtestmodule\r\n    mod = import_path(path, mode=importmode, root=config.rootpath)\r\nsrc/_pytest/pathlib.py:567: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/lib/python3.11/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1204: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1176: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:690: in _load_unlocked\r\n    ???\r\nsrc/_pytest/assertion/rewrite.py:175: in exec_module\r\n    exec(co, module.__dict__)\r\nyy/test_y.py:1: in <module>\r\n    raise Exception('foo')\r\nE   Exception: foo\r\n```\n", "hints_text": "", "created_at": "2023-12-16T15:47:08Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11698, "instance_id": "pytest-dev__pytest-11698", "issue_numbers": ["11695"], "base_commit": "2b86d2bddc3eda0a1b342ddb7d7d3aed7b29501f", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 669ec537e56..bb273edcc30 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -48,6 +48,7 @@ Ariel Pillemer\n Armin Rigo\n Aron Coyle\n Aron Curzon\n+Arthur Richard\n Ashish Kurmi\n Aviral Verma\n Aviv Palivoda\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex d6f942ad0e2..3054109ba50 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -79,7 +79,7 @@ pytest.xfail\n pytest.exit\n ~~~~~~~~~~~\n \n-.. autofunction:: pytest.exit(reason, [returncode=False, msg=None])\n+.. autofunction:: pytest.exit(reason, [returncode=None, msg=None])\n \n pytest.main\n ~~~~~~~~~~~\n", "test_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex a8984c5b97b..0f64f91d9ff 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -112,7 +112,7 @@ def exit(\n         only because `msg` is deprecated.\n \n     :param returncode:\n-        Return code to be used when exiting pytest.\n+        Return code to be used when exiting pytest. None means the same as ``0`` (no error), same as :func:`sys.exit`.\n \n     :param msg:\n         Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n", "problem_statement": "pytest.exit returncode default is poorly documented\nAccording to <https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-exit>, the default value of the `returncode` parameter of `pytest.exit` is `False`. However:\r\n\r\n* According to the actual source, the default value is `None`, not `False`: <https://docs.pytest.org/en/7.1.x/_modules/_pytest/outcomes.html#exit>.\r\n\r\n* It's not clear what a `returncode` of `None` actually means. You can't return `None` to the OS (the return code is an integer), so it must correspond to some integer value.\r\n\n", "hints_text": "", "created_at": "2023-12-13T11:31:47Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11677, "instance_id": "pytest-dev__pytest-11677", "issue_numbers": ["11676"], "base_commit": "d1675646f2d5f218cbaae5b88f3b5dee5a5061ca", "patch": "diff --git a/changelog/11676.breaking.rst b/changelog/11676.breaking.rst\nnew file mode 100644\nindex 00000000000..f20efa80db0\n--- /dev/null\n+++ b/changelog/11676.breaking.rst\n@@ -0,0 +1,3 @@\n+The classes :class:`~_pytest.nodes.Node`, :class:`~pytest.Collector`, :class:`~pytest.Item`, :class:`~pytest.File`, :class:`~_pytest.nodes.FSCollector` are now marked abstract (see :mod:`abc`).\n+\n+We do not expect this change to affect users and plugin authors, it will only cause errors when the code is already wrong or problematic.\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 254973709af..923ffc69f74 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -801,6 +801,7 @@ Node\n \n .. autoclass:: _pytest.nodes.Node()\n     :members:\n+    :show-inheritance:\n \n Collector\n ~~~~~~~~~\n", "test_patch": "diff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex d56274629a8..89046ddd0bd 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -135,7 +135,9 @@ def get_scope_node(\n     import _pytest.python\n \n     if scope is Scope.Function:\n-        return node.getparent(nodes.Item)\n+        # Type ignored because this is actually safe, see:\n+        # https://github.com/python/mypy/issues/4717\n+        return node.getparent(nodes.Item)  # type: ignore[type-abstract]\n     elif scope is Scope.Class:\n         return node.getparent(_pytest.python.Class)\n     elif scope is Scope.Module:\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4b94f413bb7..6472c2ac6f4 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -1,3 +1,4 @@\n+import abc\n import os\n import warnings\n from functools import cached_property\n@@ -121,7 +122,7 @@ def _imply_path(\n _NodeType = TypeVar(\"_NodeType\", bound=\"Node\")\n \n \n-class NodeMeta(type):\n+class NodeMeta(abc.ABCMeta):\n     \"\"\"Metaclass used by :class:`Node` to enforce that direct construction raises\n     :class:`Failed`.\n \n@@ -165,7 +166,7 @@ def _create(self, *k, **kw):\n             return super().__call__(*k, **known_kw)\n \n \n-class Node(metaclass=NodeMeta):\n+class Node(abc.ABC, metaclass=NodeMeta):\n     r\"\"\"Base class of :class:`Collector` and :class:`Item`, the components of\n     the test collection tree.\n \n@@ -534,7 +535,7 @@ def get_fslocation_from_item(node: \"Node\") -> Tuple[Union[str, Path], Optional[i\n     return getattr(node, \"fspath\", \"unknown location\"), -1\n \n \n-class Collector(Node):\n+class Collector(Node, abc.ABC):\n     \"\"\"Base class of all collectors.\n \n     Collector create children through `collect()` and thus iteratively build\n@@ -544,6 +545,7 @@ class Collector(Node):\n     class CollectError(Exception):\n         \"\"\"An error during collection, contains a custom message.\"\"\"\n \n+    @abc.abstractmethod\n     def collect(self) -> Iterable[Union[\"Item\", \"Collector\"]]:\n         \"\"\"Collect children (items and collectors) for this collector.\"\"\"\n         raise NotImplementedError(\"abstract\")\n@@ -588,7 +590,7 @@ def _check_initialpaths_for_relpath(session: \"Session\", path: Path) -> Optional[\n     return None\n \n \n-class FSCollector(Collector):\n+class FSCollector(Collector, abc.ABC):\n     \"\"\"Base class for filesystem collectors.\"\"\"\n \n     def __init__(\n@@ -666,14 +668,14 @@ def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n         return self.session.isinitpath(path)\n \n \n-class File(FSCollector):\n+class File(FSCollector, abc.ABC):\n     \"\"\"Base class for collecting tests from a file.\n \n     :ref:`non-python tests`.\n     \"\"\"\n \n \n-class Item(Node):\n+class Item(Node, abc.ABC):\n     \"\"\"Base class of all test invocation items.\n \n     Note that for a single function there might be multiple test invocation items.\n@@ -739,6 +741,7 @@ def _check_item_and_collector_diamond_inheritance(self) -> None:\n                 PytestWarning,\n             )\n \n+    @abc.abstractmethod\n     def runtest(self) -> None:\n         \"\"\"Run the test case for this item.\n \ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 0985c871d3b..3dd3026fb50 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -1,4 +1,5 @@\n \"\"\"Python test discovery, setup and run of test functions.\"\"\"\n+import abc\n import dataclasses\n import enum\n import fnmatch\n@@ -380,7 +381,7 @@ class _EmptyClass: pass  # noqa: E701\n # fmt: on\n \n \n-class PyCollector(PyobjMixin, nodes.Collector):\n+class PyCollector(PyobjMixin, nodes.Collector, abc.ABC):\n     def funcnamefilter(self, name: str) -> bool:\n         return self._matches_prefix_or_glob_option(\"python_functions\", name)\n \ndiff --git a/testing/deprecated_test.py b/testing/deprecated_test.py\nindex 08e193b5cec..fcd824d5f57 100644\n--- a/testing/deprecated_test.py\n+++ b/testing/deprecated_test.py\n@@ -257,11 +257,17 @@ def pytest_cmdline_preparse(config, args):\n def test_node_ctor_fspath_argument_is_deprecated(pytester: Pytester) -> None:\n     mod = pytester.getmodulecol(\"\")\n \n+    class MyFile(pytest.File):\n+        def collect(self):\n+            raise NotImplementedError()\n+\n     with pytest.warns(\n         pytest.PytestDeprecationWarning,\n-        match=re.escape(\"The (fspath: py.path.local) argument to File is deprecated.\"),\n+        match=re.escape(\n+            \"The (fspath: py.path.local) argument to MyFile is deprecated.\"\n+        ),\n     ):\n-        pytest.File.from_parent(\n+        MyFile.from_parent(\n             parent=mod.parent,\n             fspath=legacy_path(\"bla\"),\n         )\ndiff --git a/testing/example_scripts/issue88_initial_file_multinodes/conftest.py b/testing/example_scripts/issue88_initial_file_multinodes/conftest.py\nindex cb8f5d671ea..0598eb841a4 100644\n--- a/testing/example_scripts/issue88_initial_file_multinodes/conftest.py\n+++ b/testing/example_scripts/issue88_initial_file_multinodes/conftest.py\n@@ -11,4 +11,5 @@ def pytest_collect_file(file_path, parent):\n \n \n class MyItem(pytest.Item):\n-    pass\n+    def runtest(self):\n+        raise NotImplementedError()\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex ca2e2b7313f..b2492f7f28f 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -99,7 +99,8 @@ def test_getcustomfile_roundtrip(self, pytester: Pytester) -> None:\n             conftest=\"\"\"\n             import pytest\n             class CustomFile(pytest.File):\n-                pass\n+                def collect(self):\n+                    return []\n             def pytest_collect_file(file_path, parent):\n                 if file_path.suffix == \".xxx\":\n                     return CustomFile.from_parent(path=file_path, parent=parent)\n@@ -1509,6 +1510,9 @@ def __init__(self, *k, x, **kw):\n             super().__init__(*k, **kw)\n             self.x = x\n \n+        def collect(self):\n+            raise NotImplementedError()\n+\n     collector = MyCollector.from_parent(\n         parent=request.session, path=pytester.path / \"foo\", x=10\n     )\ndiff --git a/testing/test_nodes.py b/testing/test_nodes.py\nindex df1439e1c49..84c377cf990 100644\n--- a/testing/test_nodes.py\n+++ b/testing/test_nodes.py\n@@ -73,6 +73,12 @@ def __init__(self, fspath, parent):\n                 \"\"\"Legacy ctor with legacy call # don't wana see\"\"\"\n                 super().__init__(fspath, parent)\n \n+            def collect(self):\n+                raise NotImplementedError()\n+\n+            def runtest(self):\n+                raise NotImplementedError()\n+\n     with pytest.warns(PytestWarning) as rec:\n         SoWrong.from_parent(\n             request.session, fspath=legacy_path(tmp_path / \"broken.txt\")\n", "problem_statement": "Mark base node classes as ABCs\nThe Node class hierarchy has some classes which are only meant to be used as base classes, never instantiated directly. These are `Node`, `Collector`, `Item`, `File`, `FSCollector`, `PyCollector`.\r\n\r\nI propose we mark them as abstract i.e. inherit from `abc.ABC`. Reasons:\r\n\r\n- Trying to instantiate fails quickly at runtime\r\n- Type checkers issue an error if trying to instantiate\r\n- The docs will show `abstractmethod` on the abstract methods that need to be implemented (`collect` or `runtest`), and show inheritance from `ABC` making it clear it's a base class\r\n\r\nIt seems somewhat hard to deprecate, and it will only cause errors when the code is already very wrong. So I propose to do it in pytest 8.0 without deprecation.\n", "hints_text": "", "created_at": "2023-12-06T17:15:37Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11646, "instance_id": "pytest-dev__pytest-11646", "issue_numbers": ["7777"], "base_commit": "c7fcb3f281991ef7f1f03da393ffcdde9c31a743", "patch": "diff --git a/changelog/7777.breaking.rst b/changelog/7777.breaking.rst\nnew file mode 100644\nindex 00000000000..d38fea33096\n--- /dev/null\n+++ b/changelog/7777.breaking.rst\n@@ -0,0 +1,90 @@\n+Added a new :class:`pytest.Directory` base collection node, which all collector nodes for filesystem directories are expected to subclass.\n+This is analogous to the existing :class:`pytest.File` for file nodes.\n+\n+Changed :class:`pytest.Package` to be a subclass of :class:`pytest.Directory`.\n+A ``Package`` represents a filesystem directory which is a Python package,\n+i.e. contains an ``__init__.py`` file.\n+\n+:class:`pytest.Package` now only collects files in its own directory; previously it collected recursively.\n+Sub-directories are collected as sub-collector nodes, thus creating a collection tree which mirrors the filesystem hierarchy.\n+\n+Added a new :class:`pytest.Dir` concrete collection node, a subclass of :class:`pytest.Directory`.\n+This node represents a filesystem directory, which is not a :class:`pytest.Package`,\n+i.e. does not contain an ``__init__.py`` file.\n+Similarly to ``Package``, it only collects the files in its own directory,\n+while collecting sub-directories as sub-collector nodes.\n+\n+Added a new hook :hook:`pytest_collect_directory`,\n+which is called by filesystem-traversing collector nodes,\n+such as :class:`pytest.Session`, :class:`pytest.Dir` and :class:`pytest.Package`,\n+to create a collector node for a sub-directory.\n+It is expected to return a subclass of :class:`pytest.Directory`.\n+This hook allows plugins to :ref:`customize the collection of directories <custom directory collectors>`.\n+\n+:class:`pytest.Session` now only collects the initial arguments, without recursing into directories.\n+This work is now done by the :func:`recursive expansion process <pytest.Collector.collect>` of directory collector nodes.\n+\n+:attr:`session.name <pytest.Session.name>` is now ``\"\"``; previously it was the rootdir directory name.\n+This matches :attr:`session.nodeid <_pytest.nodes.Node.nodeid>` which has always been `\"\"`.\n+\n+Files and directories are now collected in alphabetical order jointly, unless changed by a plugin.\n+Previously, files were collected before directories.\n+\n+The collection tree now contains directories/packages up to the :ref:`rootdir <rootdir>`,\n+for initial arguments that are found within the rootdir.\n+For files outside the rootdir, only the immediate directory/package is collected --\n+note however that collecting from outside the rootdir is discouraged.\n+\n+As an example, given the following filesystem tree::\n+\n+    myroot/\n+        pytest.ini\n+        top/\n+        \u251c\u2500\u2500 aaa\n+        \u2502   \u2514\u2500\u2500 test_aaa.py\n+        \u251c\u2500\u2500 test_a.py\n+        \u251c\u2500\u2500 test_b\n+        \u2502   \u251c\u2500\u2500 __init__.py\n+        \u2502   \u2514\u2500\u2500 test_b.py\n+        \u251c\u2500\u2500 test_c.py\n+        \u2514\u2500\u2500 zzz\n+            \u251c\u2500\u2500 __init__.py\n+            \u2514\u2500\u2500 test_zzz.py\n+\n+the collection tree, as shown by `pytest --collect-only top/` but with the otherwise-hidden :class:`~pytest.Session` node added for clarity,\n+is now the following::\n+\n+    <Session>\n+      <Dir myroot>\n+        <Dir top>\n+          <Dir aaa>\n+            <Module test_aaa.py>\n+              <Function test_it>\n+          <Module test_a.py>\n+            <Function test_it>\n+          <Package test_b>\n+            <Module test_b.py>\n+              <Function test_it>\n+          <Module test_c.py>\n+            <Function test_it>\n+          <Package zzz>\n+            <Module test_zzz.py>\n+              <Function test_it>\n+\n+Previously, it was::\n+\n+    <Session>\n+      <Module top/test_a.py>\n+        <Function test_it>\n+      <Module top/test_c.py>\n+        <Function test_it>\n+      <Module top/aaa/test_aaa.py>\n+        <Function test_it>\n+      <Package test_b>\n+        <Module test_b.py>\n+          <Function test_it>\n+      <Package zzz>\n+        <Module test_zzz.py>\n+          <Function test_it>\n+\n+Code/plugins which rely on a specific shape of the collection tree might need to update.\ndiff --git a/doc/en/deprecations.rst b/doc/en/deprecations.rst\nindex ad051fc6228..caa7cb3e760 100644\n--- a/doc/en/deprecations.rst\n+++ b/doc/en/deprecations.rst\n@@ -495,6 +495,91 @@ an appropriate period of deprecation has passed.\n Some breaking changes which could not be deprecated are also listed.\n \n \n+Collection changes in pytest 8\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Added a new :class:`pytest.Directory` base collection node, which all collector nodes for filesystem directories are expected to subclass.\n+This is analogous to the existing :class:`pytest.File` for file nodes.\n+\n+Changed :class:`pytest.Package` to be a subclass of :class:`pytest.Directory`.\n+A ``Package`` represents a filesystem directory which is a Python package,\n+i.e. contains an ``__init__.py`` file.\n+\n+:class:`pytest.Package` now only collects files in its own directory; previously it collected recursively.\n+Sub-directories are collected as sub-collector nodes, thus creating a collection tree which mirrors the filesystem hierarchy.\n+\n+:attr:`session.name <pytest.Session.name>` is now ``\"\"``; previously it was the rootdir directory name.\n+This matches :attr:`session.nodeid <_pytest.nodes.Node.nodeid>` which has always been `\"\"`.\n+\n+Added a new :class:`pytest.Dir` concrete collection node, a subclass of :class:`pytest.Directory`.\n+This node represents a filesystem directory, which is not a :class:`pytest.Package`,\n+i.e. does not contain an ``__init__.py`` file.\n+Similarly to ``Package``, it only collects the files in its own directory,\n+while collecting sub-directories as sub-collector nodes.\n+\n+Files and directories are now collected in alphabetical order jointly, unless changed by a plugin.\n+Previously, files were collected before directories.\n+\n+The collection tree now contains directories/packages up to the :ref:`rootdir <rootdir>`,\n+for initial arguments that are found within the rootdir.\n+For files outside the rootdir, only the immediate directory/package is collected --\n+note however that collecting from outside the rootdir is discouraged.\n+\n+As an example, given the following filesystem tree::\n+\n+    myroot/\n+        pytest.ini\n+        top/\n+        \u251c\u2500\u2500 aaa\n+        \u2502   \u2514\u2500\u2500 test_aaa.py\n+        \u251c\u2500\u2500 test_a.py\n+        \u251c\u2500\u2500 test_b\n+        \u2502   \u251c\u2500\u2500 __init__.py\n+        \u2502   \u2514\u2500\u2500 test_b.py\n+        \u251c\u2500\u2500 test_c.py\n+        \u2514\u2500\u2500 zzz\n+            \u251c\u2500\u2500 __init__.py\n+            \u2514\u2500\u2500 test_zzz.py\n+\n+the collection tree, as shown by `pytest --collect-only top/` but with the otherwise-hidden :class:`~pytest.Session` node added for clarity,\n+is now the following::\n+\n+    <Session>\n+      <Dir myroot>\n+        <Dir top>\n+          <Dir aaa>\n+            <Module test_aaa.py>\n+              <Function test_it>\n+          <Module test_a.py>\n+            <Function test_it>\n+          <Package test_b>\n+            <Module test_b.py>\n+              <Function test_it>\n+          <Module test_c.py>\n+            <Function test_it>\n+          <Package zzz>\n+            <Module test_zzz.py>\n+              <Function test_it>\n+\n+Previously, it was::\n+\n+    <Session>\n+      <Module top/test_a.py>\n+        <Function test_it>\n+      <Module top/test_c.py>\n+        <Function test_it>\n+      <Module top/aaa/test_aaa.py>\n+        <Function test_it>\n+      <Package test_b>\n+        <Module test_b.py>\n+          <Function test_it>\n+      <Package zzz>\n+        <Module test_zzz.py>\n+          <Function test_it>\n+\n+Code/plugins which rely on a specific shape of the collection tree might need to update.\n+\n+\n :class:`pytest.Package` is no longer a :class:`pytest.Module` or :class:`pytest.File`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \ndiff --git a/doc/en/example/customdirectory.rst b/doc/en/example/customdirectory.rst\nnew file mode 100644\nindex 00000000000..1e4d7e370de\n--- /dev/null\n+++ b/doc/en/example/customdirectory.rst\n@@ -0,0 +1,77 @@\n+.. _`custom directory collectors`:\n+\n+Using a custom directory collector\n+====================================================\n+\n+By default, pytest collects directories using :class:`pytest.Package`, for directories with ``__init__.py`` files,\n+and :class:`pytest.Dir` for other directories.\n+If you want to customize how a directory is collected, you can write your own :class:`pytest.Directory` collector,\n+and use :hook:`pytest_collect_directory` to hook it up.\n+\n+.. _`directory manifest plugin`:\n+\n+A basic example for a directory manifest file\n+--------------------------------------------------------------\n+\n+Suppose you want to customize how collection is done on a per-directory basis.\n+Here is an example ``conftest.py`` plugin that allows directories to contain a ``manifest.json`` file,\n+which defines how the collection should be done for the directory.\n+In this example, only a simple list of files is supported,\n+however you can imagine adding other keys, such as exclusions and globs.\n+\n+.. include:: customdirectory/conftest.py\n+    :literal:\n+\n+You can create a ``manifest.json`` file and some test files:\n+\n+.. include:: customdirectory/tests/manifest.json\n+    :literal:\n+\n+.. include:: customdirectory/tests/test_first.py\n+    :literal:\n+\n+.. include:: customdirectory/tests/test_second.py\n+    :literal:\n+\n+.. include:: customdirectory/tests/test_third.py\n+    :literal:\n+\n+An you can now execute the test specification:\n+\n+.. code-block:: pytest\n+\n+    customdirectory $ pytest\n+    =========================== test session starts ============================\n+    platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y\n+    rootdir: /home/sweet/project/customdirectory\n+    configfile: pytest.ini\n+    collected 2 items\n+\n+    tests/test_first.py .                                                [ 50%]\n+    tests/test_second.py .                                               [100%]\n+\n+    ============================ 2 passed in 0.12s =============================\n+\n+.. regendoc:wipe\n+\n+Notice how ``test_three.py`` was not executed, because it is not listed in the manifest.\n+\n+You can verify that your custom collector appears in the collection tree:\n+\n+.. code-block:: pytest\n+\n+    customdirectory $ pytest --collect-only\n+    =========================== test session starts ============================\n+    platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y\n+    rootdir: /home/sweet/project/customdirectory\n+    configfile: pytest.ini\n+    collected 2 items\n+\n+    <Dir customdirectory>\n+      <ManifestDirectory tests>\n+        <Module test_first.py>\n+          <Function test_1>\n+        <Module test_second.py>\n+          <Function test_2>\n+\n+    ======================== 2 tests collected in 0.12s ========================\ndiff --git a/doc/en/example/index.rst b/doc/en/example/index.rst\nindex 71e855534ff..e8835aae9d3 100644\n--- a/doc/en/example/index.rst\n+++ b/doc/en/example/index.rst\n@@ -32,3 +32,4 @@ The following examples aim at various use cases you might encounter.\n    special\n    pythoncollection\n    nonpython\n+   customdirectory\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex d6f942ad0e2..a360e16120c 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -682,6 +682,8 @@ Collection hooks\n .. autofunction:: pytest_collection\n .. hook:: pytest_ignore_collect\n .. autofunction:: pytest_ignore_collect\n+.. hook:: pytest_collect_directory\n+.. autofunction:: pytest_collect_directory\n .. hook:: pytest_collect_file\n .. autofunction:: pytest_collect_file\n .. hook:: pytest_pycollect_makemodule\n@@ -921,6 +923,18 @@ Config\n .. autoclass:: pytest.Config()\n     :members:\n \n+Dir\n+~~~\n+\n+.. autoclass:: pytest.Dir()\n+    :members:\n+\n+Directory\n+~~~~~~~~~\n+\n+.. autoclass:: pytest.Directory()\n+    :members:\n+\n ExceptionInfo\n ~~~~~~~~~~~~~\n \n", "test_patch": "diff --git a/doc/en/example/conftest.py b/doc/en/example/conftest.py\nindex f905738c4f6..66e70f14dd7 100644\n--- a/doc/en/example/conftest.py\n+++ b/doc/en/example/conftest.py\n@@ -1,1 +1,1 @@\n-collect_ignore = [\"nonpython\"]\n+collect_ignore = [\"nonpython\", \"customdirectory\"]\ndiff --git a/doc/en/example/customdirectory/conftest.py b/doc/en/example/customdirectory/conftest.py\nnew file mode 100644\nindex 00000000000..350893cab43\n--- /dev/null\n+++ b/doc/en/example/customdirectory/conftest.py\n@@ -0,0 +1,28 @@\n+# content of conftest.py\n+import json\n+\n+import pytest\n+\n+\n+class ManifestDirectory(pytest.Directory):\n+    def collect(self):\n+        # The standard pytest behavior is to loop over all `test_*.py` files and\n+        # call `pytest_collect_file` on each file. This collector instead reads\n+        # the `manifest.json` file and only calls `pytest_collect_file` for the\n+        # files defined there.\n+        manifest_path = self.path / \"manifest.json\"\n+        manifest = json.loads(manifest_path.read_text(encoding=\"utf-8\"))\n+        ihook = self.ihook\n+        for file in manifest[\"files\"]:\n+            yield from ihook.pytest_collect_file(\n+                file_path=self.path / file, parent=self\n+            )\n+\n+\n+@pytest.hookimpl\n+def pytest_collect_directory(path, parent):\n+    # Use our custom collector for directories containing a `mainfest.json` file.\n+    if path.joinpath(\"manifest.json\").is_file():\n+        return ManifestDirectory.from_parent(parent=parent, path=path)\n+    # Otherwise fallback to the standard behavior.\n+    return None\ndiff --git a/doc/en/example/customdirectory/pytest.ini b/doc/en/example/customdirectory/pytest.ini\nnew file mode 100644\nindex 00000000000..e69de29bb2d\ndiff --git a/doc/en/example/customdirectory/tests/manifest.json b/doc/en/example/customdirectory/tests/manifest.json\nnew file mode 100644\nindex 00000000000..6ab6d0a5222\n--- /dev/null\n+++ b/doc/en/example/customdirectory/tests/manifest.json\n@@ -0,0 +1,6 @@\n+{\n+    \"files\": [\n+        \"test_first.py\",\n+        \"test_second.py\"\n+    ]\n+}\ndiff --git a/doc/en/example/customdirectory/tests/test_first.py b/doc/en/example/customdirectory/tests/test_first.py\nnew file mode 100644\nindex 00000000000..0a78de59945\n--- /dev/null\n+++ b/doc/en/example/customdirectory/tests/test_first.py\n@@ -0,0 +1,3 @@\n+# content of test_first.py\n+def test_1():\n+    pass\ndiff --git a/doc/en/example/customdirectory/tests/test_second.py b/doc/en/example/customdirectory/tests/test_second.py\nnew file mode 100644\nindex 00000000000..eed724a7d96\n--- /dev/null\n+++ b/doc/en/example/customdirectory/tests/test_second.py\n@@ -0,0 +1,3 @@\n+# content of test_second.py\n+def test_2():\n+    pass\ndiff --git a/doc/en/example/customdirectory/tests/test_third.py b/doc/en/example/customdirectory/tests/test_third.py\nnew file mode 100644\nindex 00000000000..61cf59dc16c\n--- /dev/null\n+++ b/doc/en/example/customdirectory/tests/test_third.py\n@@ -0,0 +1,3 @@\n+# content of test_third.py\n+def test_3():\n+    pass\ndiff --git a/src/_pytest/cacheprovider.py b/src/_pytest/cacheprovider.py\nindex 50a474a2920..793e796de69 100755\n--- a/src/_pytest/cacheprovider.py\n+++ b/src/_pytest/cacheprovider.py\n@@ -27,8 +27,8 @@\n from _pytest.fixtures import fixture\n from _pytest.fixtures import FixtureRequest\n from _pytest.main import Session\n+from _pytest.nodes import Directory\n from _pytest.nodes import File\n-from _pytest.python import Package\n from _pytest.reports import TestReport\n \n README_CONTENT = \"\"\"\\\n@@ -222,7 +222,7 @@ def pytest_make_collect_report(\n         self, collector: nodes.Collector\n     ) -> Generator[None, CollectReport, CollectReport]:\n         res = yield\n-        if isinstance(collector, (Session, Package)):\n+        if isinstance(collector, (Session, Directory)):\n             # Sort any lf-paths to the beginning.\n             lf_paths = self.lfplugin._last_failed_paths\n \ndiff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex adf1bfd9a67..e5775546dde 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -415,8 +415,6 @@ def __init__(self) -> None:\n         # session (#9478), often with the same path, so cache it.\n         self._get_directory = lru_cache(256)(_get_directory)\n \n-        self._duplicatepaths: Set[Path] = set()\n-\n         # plugins that were explicitly skipped with pytest.skip\n         # list of (module name, skip reason)\n         # previously we would issue a warning when a plugin was skipped, but\ndiff --git a/src/_pytest/hookspec.py b/src/_pytest/hookspec.py\nindex 8a4e29e672f..3c65234daa7 100644\n--- a/src/_pytest/hookspec.py\n+++ b/src/_pytest/hookspec.py\n@@ -284,11 +284,35 @@ def pytest_ignore_collect(\n     \"\"\"\n \n \n+@hookspec(firstresult=True)\n+def pytest_collect_directory(path: Path, parent: \"Collector\") -> \"Optional[Collector]\":\n+    \"\"\"Create a :class:`~pytest.Collector` for the given directory, or None if\n+    not relevant.\n+\n+    .. versionadded:: 8.0\n+\n+    For best results, the returned collector should be a subclass of\n+    :class:`~pytest.Directory`, but this is not required.\n+\n+    The new node needs to have the specified ``parent`` as a parent.\n+\n+    Stops at first non-None result, see :ref:`firstresult`.\n+\n+    :param path: The path to analyze.\n+\n+    See :ref:`custom directory collectors` for a simple example of use of this\n+    hook.\n+    \"\"\"\n+\n+\n def pytest_collect_file(\n     file_path: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n ) -> \"Optional[Collector]\":\n     \"\"\"Create a :class:`~pytest.Collector` for the given path, or None if not relevant.\n \n+    For best results, the returned collector should be a subclass of\n+    :class:`~pytest.File`, but this is not required.\n+\n     The new node needs to have the specified ``parent`` as a parent.\n \n     :param file_path: The path to analyze.\ndiff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 5cee8e89b26..3672df05a01 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -12,6 +12,7 @@\n from typing import Dict\n from typing import final\n from typing import FrozenSet\n+from typing import Iterable\n from typing import Iterator\n from typing import List\n from typing import Literal\n@@ -19,8 +20,6 @@\n from typing import overload\n from typing import Sequence\n from typing import Tuple\n-from typing import Type\n-from typing import TYPE_CHECKING\n from typing import Union\n \n import pluggy\n@@ -41,17 +40,13 @@\n from _pytest.pathlib import bestrelpath\n from _pytest.pathlib import fnmatch_ex\n from _pytest.pathlib import safe_exists\n-from _pytest.pathlib import visit\n+from _pytest.pathlib import scandir\n from _pytest.reports import CollectReport\n from _pytest.reports import TestReport\n from _pytest.runner import collect_one_node\n from _pytest.runner import SetupState\n \n \n-if TYPE_CHECKING:\n-    from _pytest.python import Package\n-\n-\n def pytest_addoption(parser: Parser) -> None:\n     parser.addini(\n         \"norecursedirs\",\n@@ -414,6 +409,12 @@ def pytest_ignore_collect(collection_path: Path, config: Config) -> Optional[boo\n     return None\n \n \n+def pytest_collect_directory(\n+    path: Path, parent: nodes.Collector\n+) -> Optional[nodes.Collector]:\n+    return Dir.from_parent(parent, path=path)\n+\n+\n def pytest_collection_modifyitems(items: List[nodes.Item], config: Config) -> None:\n     deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n     if not deselect_prefixes:\n@@ -470,7 +471,60 @@ def __missing__(self, path: Path) -> str:\n \n \n @final\n-class Session(nodes.FSCollector):\n+class Dir(nodes.Directory):\n+    \"\"\"Collector of files in a file system directory.\n+\n+    .. versionadded:: 8.0\n+\n+    .. note::\n+\n+        Python directories with an `__init__.py` file are instead collected by\n+        :class:`~pytest.Package` by default. Both are :class:`~pytest.Directory`\n+        collectors.\n+    \"\"\"\n+\n+    @classmethod\n+    def from_parent(  # type: ignore[override]\n+        cls,\n+        parent: nodes.Collector,  # type: ignore[override]\n+        *,\n+        path: Path,\n+    ) -> \"Dir\":\n+        \"\"\"The public constructor.\n+\n+        :param parent: The parent collector of this Dir.\n+        :param path: The directory's path.\n+        \"\"\"\n+        return super().from_parent(parent=parent, path=path)  # type: ignore[no-any-return]\n+\n+    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n+        config = self.config\n+        col: Optional[nodes.Collector]\n+        cols: Sequence[nodes.Collector]\n+        ihook = self.ihook\n+        for direntry in scandir(self.path):\n+            if direntry.is_dir():\n+                if direntry.name == \"__pycache__\":\n+                    continue\n+                path = Path(direntry.path)\n+                if not self.session.isinitpath(path, with_parents=True):\n+                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n+                        continue\n+                col = ihook.pytest_collect_directory(path=path, parent=self)\n+                if col is not None:\n+                    yield col\n+\n+            elif direntry.is_file():\n+                path = Path(direntry.path)\n+                if not self.session.isinitpath(path):\n+                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n+                        continue\n+                cols = ihook.pytest_collect_file(file_path=path, parent=self)\n+                yield from cols\n+\n+\n+@final\n+class Session(nodes.Collector):\n     \"\"\"The root of the collection tree.\n \n     ``Session`` collects the initial paths given as arguments to pytest.\n@@ -486,6 +540,7 @@ class Session(nodes.FSCollector):\n \n     def __init__(self, config: Config) -> None:\n         super().__init__(\n+            name=\"\",\n             path=config.rootpath,\n             fspath=None,\n             parent=None,\n@@ -499,6 +554,11 @@ def __init__(self, config: Config) -> None:\n         self.shouldfail: Union[bool, str] = False\n         self.trace = config.trace.root.get(\"collection\")\n         self._initialpaths: FrozenSet[Path] = frozenset()\n+        self._initialpaths_with_parents: FrozenSet[Path] = frozenset()\n+        self._notfound: List[Tuple[str, Sequence[nodes.Collector]]] = []\n+        self._initial_parts: List[Tuple[Path, List[str]]] = []\n+        self._collection_cache: Dict[nodes.Collector, CollectReport] = {}\n+        self.items: List[nodes.Item] = []\n \n         self._bestrelpathcache: Dict[Path, str] = _bestrelpath_cache(config.rootpath)\n \n@@ -549,10 +609,29 @@ def pytest_runtest_logreport(\n \n     pytest_collectreport = pytest_runtest_logreport\n \n-    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n+    def isinitpath(\n+        self,\n+        path: Union[str, \"os.PathLike[str]\"],\n+        *,\n+        with_parents: bool = False,\n+    ) -> bool:\n+        \"\"\"Is path an initial path?\n+\n+        An initial path is a path explicitly given to pytest on the command\n+        line.\n+\n+        :param with_parents:\n+            If set, also return True if the path is a parent of an initial path.\n+\n+        .. versionchanged:: 8.0\n+            Added the ``with_parents`` parameter.\n+        \"\"\"\n         # Optimization: Path(Path(...)) is much slower than isinstance.\n         path_ = path if isinstance(path, Path) else Path(path)\n-        return path_ in self._initialpaths\n+        if with_parents:\n+            return path_ in self._initialpaths_with_parents\n+        else:\n+            return path_ in self._initialpaths\n \n     def gethookproxy(self, fspath: \"os.PathLike[str]\") -> pluggy.HookRelay:\n         # Optimization: Path(Path(...)) is much slower than isinstance.\n@@ -560,15 +639,6 @@ def gethookproxy(self, fspath: \"os.PathLike[str]\") -> pluggy.HookRelay:\n         pm = self.config.pluginmanager\n         # Check if we have the common case of running\n         # hooks with all conftest.py files.\n-        #\n-        # TODO: pytest relies on this call to load non-initial conftests. This\n-        # is incidental. It will be better to load conftests at a more\n-        # well-defined place.\n-        pm._loadconftestmodules(\n-            path,\n-            self.config.getoption(\"importmode\"),\n-            rootpath=self.config.rootpath,\n-        )\n         my_conftestmodules = pm._getconftestmodules(path)\n         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n         proxy: pluggy.HookRelay\n@@ -580,49 +650,36 @@ def gethookproxy(self, fspath: \"os.PathLike[str]\") -> pluggy.HookRelay:\n             proxy = self.config.hook\n         return proxy\n \n-    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n-        if direntry.name == \"__pycache__\":\n-            return False\n-        fspath = Path(direntry.path)\n-        ihook = self.gethookproxy(fspath.parent)\n-        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n-            return False\n-        return True\n-\n-    def _collectpackage(self, fspath: Path) -> Optional[\"Package\"]:\n-        from _pytest.python import Package\n+    def _collect_path(\n+        self,\n+        path: Path,\n+        path_cache: Dict[Path, Sequence[nodes.Collector]],\n+    ) -> Sequence[nodes.Collector]:\n+        \"\"\"Create a Collector for the given path.\n \n-        ihook = self.gethookproxy(fspath)\n-        if not self.isinitpath(fspath):\n-            if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n-                return None\n+        `path_cache` makes it so the same Collectors are returned for the same\n+        path.\n+        \"\"\"\n+        if path in path_cache:\n+            return path_cache[path]\n \n-        pkg: Package = Package.from_parent(self, path=fspath)\n-        return pkg\n+        if path.is_dir():\n+            ihook = self.gethookproxy(path.parent)\n+            col: Optional[nodes.Collector] = ihook.pytest_collect_directory(\n+                path=path, parent=self\n+            )\n+            cols: Sequence[nodes.Collector] = (col,) if col is not None else ()\n \n-    def _collectfile(\n-        self, fspath: Path, handle_dupes: bool = True\n-    ) -> Sequence[nodes.Collector]:\n-        assert (\n-            fspath.is_file()\n-        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n-            fspath, fspath.is_dir(), fspath.exists(), fspath.is_symlink()\n-        )\n-        ihook = self.gethookproxy(fspath)\n-        if not self.isinitpath(fspath):\n-            if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n-                return ()\n+        elif path.is_file():\n+            ihook = self.gethookproxy(path)\n+            cols = ihook.pytest_collect_file(file_path=path, parent=self)\n \n-        if handle_dupes:\n-            keepduplicates = self.config.getoption(\"keepduplicates\")\n-            if not keepduplicates:\n-                duplicate_paths = self.config.pluginmanager._duplicatepaths\n-                if fspath in duplicate_paths:\n-                    return ()\n-                else:\n-                    duplicate_paths.add(fspath)\n+        else:\n+            # Broken symlink or invalid/missing file.\n+            cols = ()\n \n-        return ihook.pytest_collect_file(file_path=fspath, parent=self)  # type: ignore[no-any-return]\n+        path_cache[path] = cols\n+        return cols\n \n     @overload\n     def perform_collect(\n@@ -658,15 +715,16 @@ def perform_collect(  # noqa: F811\n         self.trace(\"perform_collect\", self, args)\n         self.trace.root.indent += 1\n \n-        self._notfound: List[Tuple[str, Sequence[nodes.Collector]]] = []\n-        self._initial_parts: List[Tuple[Path, List[str]]] = []\n-        self.items: List[nodes.Item] = []\n-\n         hook = self.config.hook\n \n+        self._notfound = []\n+        self._initial_parts = []\n+        self._collection_cache = {}\n+        self.items = []\n         items: Sequence[Union[nodes.Item, nodes.Collector]] = self.items\n         try:\n             initialpaths: List[Path] = []\n+            initialpaths_with_parents: List[Path] = []\n             for arg in args:\n                 fspath, parts = resolve_collection_argument(\n                     self.config.invocation_params.dir,\n@@ -675,7 +733,11 @@ def perform_collect(  # noqa: F811\n                 )\n                 self._initial_parts.append((fspath, parts))\n                 initialpaths.append(fspath)\n+                initialpaths_with_parents.append(fspath)\n+                initialpaths_with_parents.extend(fspath.parents)\n             self._initialpaths = frozenset(initialpaths)\n+            self._initialpaths_with_parents = frozenset(initialpaths_with_parents)\n+\n             rep = collect_one_node(self)\n             self.ihook.pytest_collectreport(report=rep)\n             self.trace.root.indent -= 1\n@@ -684,12 +746,13 @@ def perform_collect(  # noqa: F811\n                 for arg, collectors in self._notfound:\n                     if collectors:\n                         errors.append(\n-                            f\"not found: {arg}\\n(no name {arg!r} in any of {collectors!r})\"\n+                            f\"not found: {arg}\\n(no match in any of {collectors!r})\"\n                         )\n                     else:\n                         errors.append(f\"found no collectors for {arg}\")\n \n                 raise UsageError(*errors)\n+\n             if not genitems:\n                 items = rep.result\n             else:\n@@ -702,22 +765,34 @@ def perform_collect(  # noqa: F811\n                 session=self, config=self.config, items=items\n             )\n         finally:\n+            self._notfound = []\n+            self._initial_parts = []\n+            self._collection_cache = {}\n             hook.pytest_collection_finish(session=self)\n \n-        self.testscollected = len(items)\n-        return items\n+        if genitems:\n+            self.testscollected = len(items)\n \n-    def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n-        # Keep track of any collected nodes in here, so we don't duplicate fixtures.\n-        node_cache1: Dict[Path, Sequence[nodes.Collector]] = {}\n-        node_cache2: Dict[Tuple[Type[nodes.Collector], Path], nodes.Collector] = {}\n+        return items\n \n-        # Keep track of any collected collectors in matchnodes paths, so they\n-        # are not collected more than once.\n-        matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = {}\n+    def _collect_one_node(\n+        self,\n+        node: nodes.Collector,\n+        handle_dupes: bool = True,\n+    ) -> Tuple[CollectReport, bool]:\n+        if node in self._collection_cache and handle_dupes:\n+            rep = self._collection_cache[node]\n+            return rep, True\n+        else:\n+            rep = collect_one_node(node)\n+            self._collection_cache[node] = rep\n+            return rep, False\n \n-        # Directories of pkgs with dunder-init files.\n-        pkg_roots: Dict[Path, \"Package\"] = {}\n+    def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n+        # This is a cache for the root directories of the initial paths.\n+        # We can't use collection_cache for Session because of its special\n+        # role as the bootstrapping collector.\n+        path_cache: Dict[Path, Sequence[nodes.Collector]] = {}\n \n         pm = self.config.pluginmanager\n \n@@ -725,108 +800,87 @@ def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n             self.trace(\"processing argument\", (argpath, names))\n             self.trace.root.indent += 1\n \n-            # Start with a Session root, and delve to argpath item (dir or file)\n-            # and stack all Packages found on the way.\n-            for parent in (argpath, *argpath.parents):\n-                if not pm._is_in_confcutdir(argpath):\n-                    break\n-\n-                if parent.is_dir():\n-                    pkginit = parent / \"__init__.py\"\n-                    if pkginit.is_file() and parent not in node_cache1:\n-                        pkg = self._collectpackage(parent)\n-                        if pkg is not None:\n-                            pkg_roots[parent] = pkg\n-                            node_cache1[pkg.path] = [pkg]\n-\n-            # If it's a directory argument, recurse and look for any Subpackages.\n-            # Let the Package collector deal with subnodes, don't collect here.\n+            # resolve_collection_argument() ensures this.\n             if argpath.is_dir():\n                 assert not names, f\"invalid arg {(argpath, names)!r}\"\n \n-                if argpath in pkg_roots:\n-                    yield pkg_roots[argpath]\n-\n-                for direntry in visit(argpath, self._recurse):\n-                    path = Path(direntry.path)\n-                    if direntry.is_dir() and self._recurse(direntry):\n-                        pkginit = path / \"__init__.py\"\n-                        if pkginit.is_file():\n-                            pkg = self._collectpackage(path)\n-                            if pkg is not None:\n-                                yield pkg\n-                                pkg_roots[path] = pkg\n-\n-                    elif direntry.is_file():\n-                        if path.parent in pkg_roots:\n-                            # Package handles this file.\n-                            continue\n-                        for x in self._collectfile(path):\n-                            key2 = (type(x), x.path)\n-                            if key2 in node_cache2:\n-                                yield node_cache2[key2]\n-                            else:\n-                                node_cache2[key2] = x\n-                                yield x\n-            else:\n-                assert argpath.is_file()\n+            # Match the argpath from the root, e.g.\n+            #   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]\n+            paths = [*reversed(argpath.parents), argpath]\n+            # Paths outside of the confcutdir should not be considered, unless\n+            # it's the argpath itself.\n+            while len(paths) > 1 and not pm._is_in_confcutdir(paths[0]):\n+                paths = paths[1:]\n+\n+            # Start going over the parts from the root, collecting each level\n+            # and discarding all nodes which don't match the level's part.\n+            any_matched_in_initial_part = False\n+            notfound_collectors = []\n+            work: List[\n+                Tuple[Union[nodes.Collector, nodes.Item], List[Union[Path, str]]]\n+            ] = [(self, paths + names)]\n+            while work:\n+                matchnode, matchparts = work.pop()\n+\n+                # Pop'd all of the parts, this is a match.\n+                if not matchparts:\n+                    yield matchnode\n+                    any_matched_in_initial_part = True\n+                    continue\n \n-                if argpath in node_cache1:\n-                    col = node_cache1[argpath]\n-                else:\n-                    collect_root = pkg_roots.get(argpath.parent, self)\n-                    col = collect_root._collectfile(argpath, handle_dupes=False)\n-                    if col:\n-                        node_cache1[argpath] = col\n-\n-                matching = []\n-                work: List[\n-                    Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]\n-                ] = [(col, names)]\n-                while work:\n-                    self.trace(\"matchnodes\", col, names)\n-                    self.trace.root.indent += 1\n-\n-                    matchnodes, matchnames = work.pop()\n-                    for node in matchnodes:\n-                        if not matchnames:\n-                            matching.append(node)\n-                            continue\n-                        if not isinstance(node, nodes.Collector):\n-                            continue\n-                        key = (type(node), node.nodeid)\n-                        if key in matchnodes_cache:\n-                            rep = matchnodes_cache[key]\n-                        else:\n-                            rep = collect_one_node(node)\n-                            matchnodes_cache[key] = rep\n-                        if rep.passed:\n-                            submatchnodes = []\n-                            for r in rep.result:\n-                                # TODO: Remove parametrized workaround once collection structure contains\n-                                # parametrization.\n-                                if (\n-                                    r.name == matchnames[0]\n-                                    or r.name.split(\"[\")[0] == matchnames[0]\n-                                ):\n-                                    submatchnodes.append(r)\n-                            if submatchnodes:\n-                                work.append((submatchnodes, matchnames[1:]))\n-                        else:\n-                            # Report collection failures here to avoid failing to run some test\n-                            # specified in the command line because the module could not be\n-                            # imported (#134).\n-                            node.ihook.pytest_collectreport(report=rep)\n-\n-                    self.trace(\"matchnodes finished -> \", len(matching), \"nodes\")\n-                    self.trace.root.indent -= 1\n-\n-                if not matching:\n-                    report_arg = \"::\".join((str(argpath), *names))\n-                    self._notfound.append((report_arg, col))\n+                # Should have been matched by now, discard.\n+                if not isinstance(matchnode, nodes.Collector):\n                     continue\n \n-                yield from matching\n+                # Collect this level of matching.\n+                # Collecting Session (self) is done directly to avoid endless\n+                # recursion to this function.\n+                subnodes: Sequence[Union[nodes.Collector, nodes.Item]]\n+                if isinstance(matchnode, Session):\n+                    assert isinstance(matchparts[0], Path)\n+                    subnodes = matchnode._collect_path(matchparts[0], path_cache)\n+                else:\n+                    # For backward compat, files given directly multiple\n+                    # times on the command line should not be deduplicated.\n+                    handle_dupes = not (\n+                        len(matchparts) == 1\n+                        and isinstance(matchparts[0], Path)\n+                        and matchparts[0].is_file()\n+                    )\n+                    rep, duplicate = self._collect_one_node(matchnode, handle_dupes)\n+                    if not duplicate and not rep.passed:\n+                        # Report collection failures here to avoid failing to\n+                        # run some test specified in the command line because\n+                        # the module could not be imported (#134).\n+                        matchnode.ihook.pytest_collectreport(report=rep)\n+                    if not rep.passed:\n+                        continue\n+                    subnodes = rep.result\n+\n+                # Prune this level.\n+                any_matched_in_collector = False\n+                for node in subnodes:\n+                    # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.\n+                    if isinstance(matchparts[0], Path):\n+                        is_match = node.path == matchparts[0]\n+                    # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.\n+                    else:\n+                        # TODO: Remove parametrized workaround once collection structure contains\n+                        # parametrization.\n+                        is_match = (\n+                            node.name == matchparts[0]\n+                            or node.name.split(\"[\")[0] == matchparts[0]\n+                        )\n+                    if is_match:\n+                        work.append((node, matchparts[1:]))\n+                        any_matched_in_collector = True\n+\n+                if not any_matched_in_collector:\n+                    notfound_collectors.append(matchnode)\n+\n+            if not any_matched_in_initial_part:\n+                report_arg = \"::\".join((str(argpath), *names))\n+                self._notfound.append((report_arg, notfound_collectors))\n \n             self.trace.root.indent -= 1\n \n@@ -839,11 +893,17 @@ def genitems(\n             yield node\n         else:\n             assert isinstance(node, nodes.Collector)\n-            rep = collect_one_node(node)\n+            keepduplicates = self.config.getoption(\"keepduplicates\")\n+            # For backward compat, dedup only applies to files.\n+            handle_dupes = not (keepduplicates and isinstance(node, nodes.File))\n+            rep, duplicate = self._collect_one_node(node, handle_dupes)\n+            if duplicate and not keepduplicates:\n+                return\n             if rep.passed:\n                 for subnode in rep.result:\n                     yield from self.genitems(subnode)\n-            node.ihook.pytest_collectreport(report=rep)\n+            if not duplicate:\n+                node.ihook.pytest_collectreport(report=rep)\n \n \n def search_pypath(module_name: str) -> str:\ndiff --git a/src/_pytest/mark/__init__.py b/src/_pytest/mark/__init__.py\nindex de46b4c8a75..3f97299ea70 100644\n--- a/src/_pytest/mark/__init__.py\n+++ b/src/_pytest/mark/__init__.py\n@@ -152,12 +152,19 @@ class KeywordMatcher:\n     def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n         mapped_names = set()\n \n-        # Add the names of the current item and any parent items.\n+        # Add the names of the current item and any parent items,\n+        # except the Session and root Directory's which are not\n+        # interesting for matching.\n         import pytest\n \n         for node in item.listchain():\n-            if not isinstance(node, pytest.Session):\n-                mapped_names.add(node.name)\n+            if isinstance(node, pytest.Session):\n+                continue\n+            if isinstance(node, pytest.Directory) and isinstance(\n+                node.parent, pytest.Session\n+            ):\n+                continue\n+            mapped_names.add(node.name)\n \n         # Add the names added as extra keywords to current or parent items.\n         mapped_names.update(item.listextrakeywords())\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 183f3c9d958..29efd56f49e 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -676,6 +676,24 @@ class File(FSCollector, abc.ABC):\n     \"\"\"\n \n \n+class Directory(FSCollector, abc.ABC):\n+    \"\"\"Base class for collecting files from a directory.\n+\n+    A basic directory collector does the following: goes over the files and\n+    sub-directories in the directory and creates collectors for them by calling\n+    the hooks :hook:`pytest_collect_directory` and :hook:`pytest_collect_file`,\n+    after checking that they are not ignored using\n+    :hook:`pytest_ignore_collect`.\n+\n+    The default directory collectors are :class:`~pytest.Dir` and\n+    :class:`~pytest.Package`.\n+\n+    .. versionadded:: 8.0\n+\n+    :ref:`custom directory collectors`.\n+    \"\"\"\n+\n+\n class Item(Node, abc.ABC):\n     \"\"\"Base class of all test invocation items.\n \ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e39b3dc8eec..4cd635ed7e1 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -689,10 +689,14 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n-def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n+def scandir(\n+    path: Union[str, \"os.PathLike[str]\"],\n+    sort_key: Callable[[\"os.DirEntry[str]\"], object] = lambda entry: entry.name,\n+) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n-    The returned entries are sorted.\n+    The returned entries are sorted according to the given key.\n+    The default is to sort by name.\n     \"\"\"\n     entries = []\n     with os.scandir(path) as s:\n@@ -706,7 +710,7 @@ def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n                     continue\n                 raise\n             entries.append(entry)\n-    entries.sort(key=lambda entry: entry.name)\n+    entries.sort(key=sort_key)  # type: ignore[arg-type]\n     return entries\n \n \ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 3dd3026fb50..e0f7a447a61 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -76,8 +76,7 @@\n from _pytest.pathlib import fnmatch_ex\n from _pytest.pathlib import import_path\n from _pytest.pathlib import ImportPathMismatchError\n-from _pytest.pathlib import parts\n-from _pytest.pathlib import visit\n+from _pytest.pathlib import scandir\n from _pytest.scope import _ScopeName\n from _pytest.scope import Scope\n from _pytest.stash import StashKey\n@@ -204,6 +203,16 @@ def pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n     return True\n \n \n+def pytest_collect_directory(\n+    path: Path, parent: nodes.Collector\n+) -> Optional[nodes.Collector]:\n+    pkginit = path / \"__init__.py\"\n+    if pkginit.is_file():\n+        pkg: Package = Package.from_parent(parent, path=path)\n+        return pkg\n+    return None\n+\n+\n def pytest_collect_file(file_path: Path, parent: nodes.Collector) -> Optional[\"Module\"]:\n     if file_path.suffix == \".py\":\n         if not parent.session.isinitpath(file_path):\n@@ -659,9 +668,20 @@ def xunit_setup_function_fixture(request) -> Generator[None, None, None]:\n         self.obj.__pytest_setup_function = xunit_setup_function_fixture\n \n \n-class Package(nodes.FSCollector):\n+class Package(nodes.Directory):\n     \"\"\"Collector for files and directories in a Python packages -- directories\n-    with an `__init__.py` file.\"\"\"\n+    with an `__init__.py` file.\n+\n+    .. note::\n+\n+        Directories without an `__init__.py` file are instead collected by\n+        :class:`~pytest.Dir` by default. Both are :class:`~pytest.Directory`\n+        collectors.\n+\n+    .. versionchanged:: 8.0\n+\n+        Now inherits from :class:`~pytest.Directory`.\n+    \"\"\"\n \n     def __init__(\n         self,\n@@ -674,10 +694,9 @@ def __init__(\n         path: Optional[Path] = None,\n     ) -> None:\n         # NOTE: Could be just the following, but kept as-is for compat.\n-        # nodes.FSCollector.__init__(self, fspath, parent=parent)\n+        # super().__init__(self, fspath, parent=parent)\n         session = parent.session\n-        nodes.FSCollector.__init__(\n-            self,\n+        super().__init__(\n             fspath=fspath,\n             path=path,\n             parent=parent,\n@@ -685,7 +704,6 @@ def __init__(\n             session=session,\n             nodeid=nodeid,\n         )\n-        self.name = self.path.name\n \n     def setup(self) -> None:\n         init_mod = importtestmodule(self.path / \"__init__.py\", self.config)\n@@ -705,66 +723,34 @@ def setup(self) -> None:\n             func = partial(_call_with_optional_argument, teardown_module, init_mod)\n             self.addfinalizer(func)\n \n-    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n-        if direntry.name == \"__pycache__\":\n-            return False\n-        fspath = Path(direntry.path)\n-        ihook = self.session.gethookproxy(fspath.parent)\n-        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n-            return False\n-        return True\n-\n-    def _collectfile(\n-        self, fspath: Path, handle_dupes: bool = True\n-    ) -> Sequence[nodes.Collector]:\n-        assert (\n-            fspath.is_file()\n-        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n-            fspath, fspath.is_dir(), fspath.exists(), fspath.is_symlink()\n-        )\n-        ihook = self.session.gethookproxy(fspath)\n-        if not self.session.isinitpath(fspath):\n-            if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n-                return ()\n-\n-        if handle_dupes:\n-            keepduplicates = self.config.getoption(\"keepduplicates\")\n-            if not keepduplicates:\n-                duplicate_paths = self.config.pluginmanager._duplicatepaths\n-                if fspath in duplicate_paths:\n-                    return ()\n-                else:\n-                    duplicate_paths.add(fspath)\n-\n-        return ihook.pytest_collect_file(file_path=fspath, parent=self)  # type: ignore[no-any-return]\n-\n     def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n-        # Always collect the __init__ first.\n-        yield from self._collectfile(self.path / \"__init__.py\")\n+        # Always collect __init__.py first.\n+        def sort_key(entry: \"os.DirEntry[str]\") -> object:\n+            return (entry.name != \"__init__.py\", entry.name)\n \n-        pkg_prefixes: Set[Path] = set()\n-        for direntry in visit(self.path, recurse=self._recurse):\n-            path = Path(direntry.path)\n-\n-            # Already handled above.\n-            if direntry.is_file():\n-                if direntry.name == \"__init__.py\" and path.parent == self.path:\n+        config = self.config\n+        col: Optional[nodes.Collector]\n+        cols: Sequence[nodes.Collector]\n+        ihook = self.ihook\n+        for direntry in scandir(self.path, sort_key):\n+            if direntry.is_dir():\n+                if direntry.name == \"__pycache__\":\n                     continue\n-\n-            parts_ = parts(direntry.path)\n-            if any(\n-                str(pkg_prefix) in parts_ and pkg_prefix / \"__init__.py\" != path\n-                for pkg_prefix in pkg_prefixes\n-            ):\n-                continue\n-\n-            if direntry.is_file():\n-                yield from self._collectfile(path)\n-            elif not direntry.is_dir():\n-                # Broken symlink or invalid/missing file.\n-                continue\n-            elif self._recurse(direntry) and path.joinpath(\"__init__.py\").is_file():\n-                pkg_prefixes.add(path)\n+                path = Path(direntry.path)\n+                if not self.session.isinitpath(path, with_parents=True):\n+                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n+                        continue\n+                col = ihook.pytest_collect_directory(path=path, parent=self)\n+                if col is not None:\n+                    yield col\n+\n+            elif direntry.is_file():\n+                path = Path(direntry.path)\n+                if not self.session.isinitpath(path):\n+                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n+                        continue\n+                cols = ihook.pytest_collect_file(file_path=path, parent=self)\n+                yield from cols\n \n \n def _call_with_optional_argument(func, arg) -> None:\ndiff --git a/src/_pytest/runner.py b/src/_pytest/runner.py\nindex 1b39f93cf13..dcfc6b7d0e2 100644\n--- a/src/_pytest/runner.py\n+++ b/src/_pytest/runner.py\n@@ -28,6 +28,7 @@\n from _pytest.config.argparsing import Parser\n from _pytest.deprecated import check_ispytest\n from _pytest.nodes import Collector\n+from _pytest.nodes import Directory\n from _pytest.nodes import Item\n from _pytest.nodes import Node\n from _pytest.outcomes import Exit\n@@ -368,7 +369,23 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n \n \n def pytest_make_collect_report(collector: Collector) -> CollectReport:\n-    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n+    def collect() -> List[Union[Item, Collector]]:\n+        # Before collecting, if this is a Directory, load the conftests.\n+        # If a conftest import fails to load, it is considered a collection\n+        # error of the Directory collector. This is why it's done inside of the\n+        # CallInfo wrapper.\n+        #\n+        # Note: initial conftests are loaded early, not here.\n+        if isinstance(collector, Directory):\n+            collector.config.pluginmanager._loadconftestmodules(\n+                collector.path,\n+                collector.config.getoption(\"importmode\"),\n+                rootpath=collector.config.rootpath,\n+            )\n+\n+        return list(collector.collect())\n+\n+    call = CallInfo.from_call(collect, \"collect\")\n     longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n     if not call.excinfo:\n         outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\ndiff --git a/src/pytest/__init__.py b/src/pytest/__init__.py\nindex 0aa496a2fa7..4e0c23ddbe7 100644\n--- a/src/pytest/__init__.py\n+++ b/src/pytest/__init__.py\n@@ -30,6 +30,7 @@\n from _pytest.legacypath import TempdirFactory\n from _pytest.legacypath import Testdir\n from _pytest.logging import LogCaptureFixture\n+from _pytest.main import Dir\n from _pytest.main import Session\n from _pytest.mark import Mark\n from _pytest.mark import MARK_GEN as mark\n@@ -38,6 +39,7 @@\n from _pytest.mark import param\n from _pytest.monkeypatch import MonkeyPatch\n from _pytest.nodes import Collector\n+from _pytest.nodes import Directory\n from _pytest.nodes import File\n from _pytest.nodes import Item\n from _pytest.outcomes import exit\n@@ -98,6 +100,8 @@\n     \"Config\",\n     \"console_main\",\n     \"deprecated_call\",\n+    \"Dir\",\n+    \"Directory\",\n     \"DoctestItem\",\n     \"exit\",\n     \"ExceptionInfo\",\ndiff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\nindex d597311ae38..43390ab83ae 100644\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -185,7 +185,8 @@ def test_not_collectable_arguments(self, pytester: Pytester) -> None:\n         assert result.ret == ExitCode.USAGE_ERROR\n         result.stderr.fnmatch_lines(\n             [\n-                f\"ERROR: found no collectors for {p2}\",\n+                f\"ERROR: not found: {p2}\",\n+                \"(no match in any of *)\",\n                 \"\",\n             ]\n         )\n@@ -238,7 +239,7 @@ def test_issue88_initial_file_multinodes(self, pytester: Pytester) -> None:\n         pytester.copy_example(\"issue88_initial_file_multinodes\")\n         p = pytester.makepyfile(\"def test_hello(): pass\")\n         result = pytester.runpytest(p, \"--collect-only\")\n-        result.stdout.fnmatch_lines([\"*MyFile*test_issue88*\", \"*Module*test_issue88*\"])\n+        result.stdout.fnmatch_lines([\"*Module*test_issue88*\", \"*MyFile*test_issue88*\"])\n \n     def test_issue93_initialnode_importing_capturing(self, pytester: Pytester) -> None:\n         pytester.makeconftest(\ndiff --git a/testing/example_scripts/customdirectory/conftest.py b/testing/example_scripts/customdirectory/conftest.py\nnew file mode 100644\nindex 00000000000..5357014d7ab\n--- /dev/null\n+++ b/testing/example_scripts/customdirectory/conftest.py\n@@ -0,0 +1,22 @@\n+# content of conftest.py\n+import json\n+\n+import pytest\n+\n+\n+class ManifestDirectory(pytest.Directory):\n+    def collect(self):\n+        manifest_path = self.path / \"manifest.json\"\n+        manifest = json.loads(manifest_path.read_text(encoding=\"utf-8\"))\n+        ihook = self.ihook\n+        for file in manifest[\"files\"]:\n+            yield from ihook.pytest_collect_file(\n+                file_path=self.path / file, parent=self\n+            )\n+\n+\n+@pytest.hookimpl\n+def pytest_collect_directory(path, parent):\n+    if path.joinpath(\"manifest.json\").is_file():\n+        return ManifestDirectory.from_parent(parent=parent, path=path)\n+    return None\ndiff --git a/testing/example_scripts/customdirectory/pytest.ini b/testing/example_scripts/customdirectory/pytest.ini\nnew file mode 100644\nindex 00000000000..e69de29bb2d\ndiff --git a/testing/example_scripts/customdirectory/tests/manifest.json b/testing/example_scripts/customdirectory/tests/manifest.json\nnew file mode 100644\nindex 00000000000..6ab6d0a5222\n--- /dev/null\n+++ b/testing/example_scripts/customdirectory/tests/manifest.json\n@@ -0,0 +1,6 @@\n+{\n+    \"files\": [\n+        \"test_first.py\",\n+        \"test_second.py\"\n+    ]\n+}\ndiff --git a/testing/example_scripts/customdirectory/tests/test_first.py b/testing/example_scripts/customdirectory/tests/test_first.py\nnew file mode 100644\nindex 00000000000..0a78de59945\n--- /dev/null\n+++ b/testing/example_scripts/customdirectory/tests/test_first.py\n@@ -0,0 +1,3 @@\n+# content of test_first.py\n+def test_1():\n+    pass\ndiff --git a/testing/example_scripts/customdirectory/tests/test_second.py b/testing/example_scripts/customdirectory/tests/test_second.py\nnew file mode 100644\nindex 00000000000..eed724a7d96\n--- /dev/null\n+++ b/testing/example_scripts/customdirectory/tests/test_second.py\n@@ -0,0 +1,3 @@\n+# content of test_second.py\n+def test_2():\n+    pass\ndiff --git a/testing/example_scripts/customdirectory/tests/test_third.py b/testing/example_scripts/customdirectory/tests/test_third.py\nnew file mode 100644\nindex 00000000000..61cf59dc16c\n--- /dev/null\n+++ b/testing/example_scripts/customdirectory/tests/test_third.py\n@@ -0,0 +1,3 @@\n+# content of test_third.py\n+def test_3():\n+    pass\ndiff --git a/testing/python/collect.py b/testing/python/collect.py\nindex 309d7e6801a..da11dd34a9a 100644\n--- a/testing/python/collect.py\n+++ b/testing/python/collect.py\n@@ -1514,3 +1514,108 @@ def test_package_ordering(pytester: Pytester) -> None:\n     # Execute from .\n     result = pytester.runpytest(\"-v\", \"-s\")\n     result.assert_outcomes(passed=3)\n+\n+\n+def test_collection_hierarchy(pytester: Pytester) -> None:\n+    \"\"\"A general test checking that a filesystem hierarchy is collected as\n+    expected in various scenarios.\n+\n+    top/\n+    \u251c\u2500\u2500 aaa\n+    \u2502   \u251c\u2500\u2500 pkg\n+    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n+    \u2502   \u2502   \u2514\u2500\u2500 test_pkg.py\n+    \u2502   \u2514\u2500\u2500 test_aaa.py\n+    \u251c\u2500\u2500 test_a.py\n+    \u251c\u2500\u2500 test_b\n+    \u2502   \u251c\u2500\u2500 __init__.py\n+    \u2502   \u2514\u2500\u2500 test_b.py\n+    \u251c\u2500\u2500 test_c.py\n+    \u2514\u2500\u2500 zzz\n+        \u251c\u2500\u2500 dir\n+        \u2502   \u2514\u2500\u2500 test_dir.py\n+        \u251c\u2500\u2500 __init__.py\n+        \u2514\u2500\u2500 test_zzz.py\n+    \"\"\"\n+    pytester.makepyfile(\n+        **{\n+            \"top/aaa/test_aaa.py\": \"def test_it(): pass\",\n+            \"top/aaa/pkg/__init__.py\": \"\",\n+            \"top/aaa/pkg/test_pkg.py\": \"def test_it(): pass\",\n+            \"top/test_a.py\": \"def test_it(): pass\",\n+            \"top/test_b/__init__.py\": \"\",\n+            \"top/test_b/test_b.py\": \"def test_it(): pass\",\n+            \"top/test_c.py\": \"def test_it(): pass\",\n+            \"top/zzz/__init__.py\": \"\",\n+            \"top/zzz/test_zzz.py\": \"def test_it(): pass\",\n+            \"top/zzz/dir/test_dir.py\": \"def test_it(): pass\",\n+        }\n+    )\n+\n+    full = [\n+        \"<Dir test_collection_hierarchy*>\",\n+        \"  <Dir top>\",\n+        \"    <Dir aaa>\",\n+        \"      <Package pkg>\",\n+        \"        <Module test_pkg.py>\",\n+        \"          <Function test_it>\",\n+        \"      <Module test_aaa.py>\",\n+        \"        <Function test_it>\",\n+        \"    <Module test_a.py>\",\n+        \"      <Function test_it>\",\n+        \"    <Package test_b>\",\n+        \"      <Module test_b.py>\",\n+        \"        <Function test_it>\",\n+        \"    <Module test_c.py>\",\n+        \"      <Function test_it>\",\n+        \"    <Package zzz>\",\n+        \"      <Dir dir>\",\n+        \"        <Module test_dir.py>\",\n+        \"          <Function test_it>\",\n+        \"      <Module test_zzz.py>\",\n+        \"        <Function test_it>\",\n+    ]\n+    result = pytester.runpytest(\"--collect-only\")\n+    result.stdout.fnmatch_lines(full, consecutive=True)\n+    result = pytester.runpytest(\"top\", \"--collect-only\")\n+    result.stdout.fnmatch_lines(full, consecutive=True)\n+    result = pytester.runpytest(\"top\", \"top\", \"--collect-only\")\n+    result.stdout.fnmatch_lines(full, consecutive=True)\n+\n+    result = pytester.runpytest(\n+        \"top/aaa\", \"top/aaa/pkg\", \"--collect-only\", \"--keep-duplicates\"\n+    )\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"<Dir test_collection_hierarchy*>\",\n+            \"  <Dir top>\",\n+            \"    <Dir aaa>\",\n+            \"      <Package pkg>\",\n+            \"        <Module test_pkg.py>\",\n+            \"          <Function test_it>\",\n+            \"      <Module test_aaa.py>\",\n+            \"        <Function test_it>\",\n+            \"      <Package pkg>\",\n+            \"        <Module test_pkg.py>\",\n+            \"          <Function test_it>\",\n+        ],\n+        consecutive=True,\n+    )\n+\n+    result = pytester.runpytest(\n+        \"top/aaa/pkg\", \"top/aaa\", \"--collect-only\", \"--keep-duplicates\"\n+    )\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"<Dir test_collection_hierarchy*>\",\n+            \"  <Dir top>\",\n+            \"    <Dir aaa>\",\n+            \"      <Package pkg>\",\n+            \"        <Module test_pkg.py>\",\n+            \"          <Function test_it>\",\n+            \"          <Function test_it>\",\n+            \"      <Module test_aaa.py>\",\n+            \"        <Function test_it>\",\n+        ],\n+        consecutive=True,\n+    )\ndiff --git a/testing/python/metafunc.py b/testing/python/metafunc.py\nindex e93363a787e..9768c82ffa7 100644\n--- a/testing/python/metafunc.py\n+++ b/testing/python/metafunc.py\n@@ -1005,16 +1005,16 @@ def test3(arg1):\n         result = pytester.runpytest(\"--collect-only\")\n         result.stdout.re_match_lines(\n             [\n-                r\"  <Function test1\\[0-3\\]>\",\n-                r\"  <Function test1\\[0-4\\]>\",\n-                r\"  <Function test3\\[0\\]>\",\n-                r\"  <Function test1\\[1-3\\]>\",\n-                r\"  <Function test1\\[1-4\\]>\",\n-                r\"  <Function test3\\[1\\]>\",\n-                r\"  <Function test1\\[2-3\\]>\",\n-                r\"  <Function test1\\[2-4\\]>\",\n-                r\"  <Function test3\\[2\\]>\",\n-                r\"  <Function test2>\",\n+                r\"    <Function test1\\[0-3\\]>\",\n+                r\"    <Function test1\\[0-4\\]>\",\n+                r\"    <Function test3\\[0\\]>\",\n+                r\"    <Function test1\\[1-3\\]>\",\n+                r\"    <Function test1\\[1-4\\]>\",\n+                r\"    <Function test3\\[1\\]>\",\n+                r\"    <Function test1\\[2-3\\]>\",\n+                r\"    <Function test1\\[2-4\\]>\",\n+                r\"    <Function test3\\[2\\]>\",\n+                r\"    <Function test2>\",\n             ]\n         )\n \ndiff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex 4d751f8dbfc..c08c1cd8200 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -1574,12 +1574,12 @@ def test_assertrepr_loaded_per_dir(pytester: Pytester) -> None:\n     result = pytester.runpytest()\n     result.stdout.fnmatch_lines(\n         [\n-            \"*def test_base():*\",\n-            \"*E*assert 1 == 2*\",\n             \"*def test_a():*\",\n             \"*E*assert summary a*\",\n             \"*def test_b():*\",\n             \"*E*assert summary b*\",\n+            \"*def test_base():*\",\n+            \"*E*assert 1 == 2*\",\n         ]\n     )\n \n@@ -1744,9 +1744,9 @@ def test_something():\n     )\n     result = pytester.runpytest(\"--collect-only\")\n     result.stdout.fnmatch_lines(\n-        \"\"\"\n-        <Module*>\n-    \"\"\"\n+        [\n+            \"  <Module*>\",\n+        ]\n     )\n \n \ndiff --git a/testing/test_cacheprovider.py b/testing/test_cacheprovider.py\nindex e2e195ca7f5..21c1957cfeb 100644\n--- a/testing/test_cacheprovider.py\n+++ b/testing/test_cacheprovider.py\n@@ -422,7 +422,7 @@ def test_fail(val):\n         result = pytester.runpytest()\n         result.stdout.fnmatch_lines([\"*1 failed in*\"])\n \n-    @pytest.mark.parametrize(\"parent\", (\"session\", \"package\"))\n+    @pytest.mark.parametrize(\"parent\", (\"directory\", \"package\"))\n     def test_terminal_report_lastfailed(self, pytester: Pytester, parent: str) -> None:\n         if parent == \"package\":\n             pytester.makepyfile(\n@@ -936,8 +936,10 @@ def test_lastfailed_with_known_failures_not_being_selected(\n                 \"collected 1 item\",\n                 \"run-last-failure: rerun previous 1 failure (skipped 1 file)\",\n                 \"\",\n-                \"<Module pkg1/test_1.py>\",\n-                \"  <Function test_renamed>\",\n+                \"<Dir *>\",\n+                \"  <Dir pkg1>\",\n+                \"    <Module test_1.py>\",\n+                \"      <Function test_renamed>\",\n             ]\n         )\n \n@@ -966,8 +968,10 @@ def test_fail(): assert 0\n                 \"*collected 1 item\",\n                 \"run-last-failure: 1 known failures not in selected tests\",\n                 \"\",\n-                \"<Module pkg1/test_1.py>\",\n-                \"  <Function test_pass>\",\n+                \"<Dir *>\",\n+                \"  <Dir pkg1>\",\n+                \"    <Module test_1.py>\",\n+                \"      <Function test_pass>\",\n             ],\n             consecutive=True,\n         )\n@@ -981,8 +985,10 @@ def test_fail(): assert 0\n                 \"collected 2 items / 1 deselected / 1 selected\",\n                 \"run-last-failure: rerun previous 1 failure\",\n                 \"\",\n-                \"<Module pkg1/test_1.py>\",\n-                \"  <Function test_fail>\",\n+                \"<Dir *>\",\n+                \"  <Dir pkg1>\",\n+                \"    <Module test_1.py>\",\n+                \"      <Function test_fail>\",\n                 \"*= 1/2 tests collected (1 deselected) in *\",\n             ],\n         )\n@@ -1011,10 +1017,12 @@ def test_other(): assert 0\n                 \"collected 3 items / 1 deselected / 2 selected\",\n                 \"run-last-failure: rerun previous 2 failures\",\n                 \"\",\n-                \"<Module pkg1/test_1.py>\",\n-                \"  <Class TestFoo>\",\n-                \"    <Function test_fail>\",\n-                \"  <Function test_other>\",\n+                \"<Dir *>\",\n+                \"  <Dir pkg1>\",\n+                \"    <Module test_1.py>\",\n+                \"      <Class TestFoo>\",\n+                \"        <Function test_fail>\",\n+                \"      <Function test_other>\",\n                 \"\",\n                 \"*= 2/3 tests collected (1 deselected) in *\",\n             ],\n@@ -1048,8 +1056,10 @@ def test_pass(): pass\n                 \"collected 1 item\",\n                 \"run-last-failure: 1 known failures not in selected tests\",\n                 \"\",\n-                \"<Module pkg1/test_1.py>\",\n-                \"  <Function test_pass>\",\n+                \"<Dir *>\",\n+                \"  <Dir pkg1>\",\n+                \"    <Module test_1.py>\",\n+                \"      <Function test_pass>\",\n                 \"\",\n                 \"*= 1 test collected in*\",\n             ],\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex b2492f7f28f..deed4bda522 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -490,7 +490,7 @@ def test_collect_topdir(self, pytester: Pytester) -> None:\n         # assert root2 == rcol, rootid\n         colitems = rcol.perform_collect([rcol.nodeid], genitems=False)\n         assert len(colitems) == 1\n-        assert colitems[0].path == p\n+        assert colitems[0].path == topdir\n \n     def get_reported_items(self, hookrec: HookRecorder) -> List[Item]:\n         \"\"\"Return pytest.Item instances reported by the pytest_collectreport hook\"\"\"\n@@ -568,12 +568,12 @@ def pytest_collect_file(file_path, parent):\n         hookrec.assert_contains(\n             [\n                 (\"pytest_collectstart\", \"collector.path == collector.session.path\"),\n+                (\"pytest_collectstart\", \"collector.__class__.__name__ == 'Module'\"),\n+                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                 (\n                     \"pytest_collectstart\",\n                     \"collector.__class__.__name__ == 'SpecialFile'\",\n                 ),\n-                (\"pytest_collectstart\", \"collector.__class__.__name__ == 'Module'\"),\n-                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                 (\"pytest_collectreport\", \"report.nodeid.startswith(p.name)\"),\n             ]\n         )\n@@ -657,7 +657,8 @@ def test_global_file(self, pytester: Pytester) -> None:\n         assert isinstance(col, pytest.Module)\n         assert col.name == \"x.py\"\n         assert col.parent is not None\n-        assert col.parent.parent is None\n+        assert col.parent.parent is not None\n+        assert col.parent.parent.parent is None\n         for parent in col.listchain():\n             assert parent.config is config\n \n@@ -937,6 +938,46 @@ def test_method(self): pass\n         assert \"baz\" not in mod.keywords\n \n \n+class TestCollectDirectoryHook:\n+    def test_custom_directory_example(self, pytester: Pytester) -> None:\n+        \"\"\"Verify the example from the customdirectory.rst doc.\"\"\"\n+        pytester.copy_example(\"customdirectory\")\n+\n+        reprec = pytester.inline_run()\n+\n+        reprec.assertoutcome(passed=2, failed=0)\n+        calls = reprec.getcalls(\"pytest_collect_directory\")\n+        assert len(calls) == 2\n+        assert calls[0].path == pytester.path\n+        assert isinstance(calls[0].parent, pytest.Session)\n+        assert calls[1].path == pytester.path / \"tests\"\n+        assert isinstance(calls[1].parent, pytest.Dir)\n+\n+    def test_directory_ignored_if_none(self, pytester: Pytester) -> None:\n+        \"\"\"If the (entire) hook returns None, it's OK, the directory is ignored.\"\"\"\n+        pytester.makeconftest(\n+            \"\"\"\n+            import pytest\n+\n+            @pytest.hookimpl(wrapper=True)\n+            def pytest_collect_directory():\n+                yield\n+                return None\n+            \"\"\",\n+        )\n+        pytester.makepyfile(\n+            **{\n+                \"tests/test_it.py\": \"\"\"\n+                    import pytest\n+\n+                    def test_it(): pass\n+                \"\"\",\n+            },\n+        )\n+        reprec = pytester.inline_run()\n+        reprec.assertoutcome(passed=0, failed=0)\n+\n+\n COLLECTION_ERROR_PY_FILES = dict(\n     test_01_failure=\"\"\"\n         def test_1():\n@@ -1098,22 +1139,24 @@ def test_collect_init_tests(pytester: Pytester) -> None:\n     result.stdout.fnmatch_lines(\n         [\n             \"collected 2 items\",\n-            \"<Package tests>\",\n-            \"  <Module __init__.py>\",\n-            \"    <Function test_init>\",\n-            \"  <Module test_foo.py>\",\n-            \"    <Function test_foo>\",\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module __init__.py>\",\n+            \"      <Function test_init>\",\n+            \"    <Module test_foo.py>\",\n+            \"      <Function test_foo>\",\n         ]\n     )\n     result = pytester.runpytest(\"./tests\", \"--collect-only\")\n     result.stdout.fnmatch_lines(\n         [\n             \"collected 2 items\",\n-            \"<Package tests>\",\n-            \"  <Module __init__.py>\",\n-            \"    <Function test_init>\",\n-            \"  <Module test_foo.py>\",\n-            \"    <Function test_foo>\",\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module __init__.py>\",\n+            \"      <Function test_init>\",\n+            \"    <Module test_foo.py>\",\n+            \"      <Function test_foo>\",\n         ]\n     )\n     # Ignores duplicates with \".\" and pkginit (#4310).\n@@ -1121,11 +1164,12 @@ def test_collect_init_tests(pytester: Pytester) -> None:\n     result.stdout.fnmatch_lines(\n         [\n             \"collected 2 items\",\n-            \"<Package tests>\",\n-            \"  <Module __init__.py>\",\n-            \"    <Function test_init>\",\n-            \"  <Module test_foo.py>\",\n-            \"    <Function test_foo>\",\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module __init__.py>\",\n+            \"      <Function test_init>\",\n+            \"    <Module test_foo.py>\",\n+            \"      <Function test_foo>\",\n         ]\n     )\n     # Same as before, but different order.\n@@ -1133,21 +1177,32 @@ def test_collect_init_tests(pytester: Pytester) -> None:\n     result.stdout.fnmatch_lines(\n         [\n             \"collected 2 items\",\n-            \"<Package tests>\",\n-            \"  <Module __init__.py>\",\n-            \"    <Function test_init>\",\n-            \"  <Module test_foo.py>\",\n-            \"    <Function test_foo>\",\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module __init__.py>\",\n+            \"      <Function test_init>\",\n+            \"    <Module test_foo.py>\",\n+            \"      <Function test_foo>\",\n         ]\n     )\n     result = pytester.runpytest(\"./tests/test_foo.py\", \"--collect-only\")\n     result.stdout.fnmatch_lines(\n-        [\"<Package tests>\", \"  <Module test_foo.py>\", \"    <Function test_foo>\"]\n+        [\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module test_foo.py>\",\n+            \"      <Function test_foo>\",\n+        ]\n     )\n     result.stdout.no_fnmatch_line(\"*test_init*\")\n     result = pytester.runpytest(\"./tests/__init__.py\", \"--collect-only\")\n     result.stdout.fnmatch_lines(\n-        [\"<Package tests>\", \"  <Module __init__.py>\", \"    <Function test_init>\"]\n+        [\n+            \"<Dir *>\",\n+            \"  <Package tests>\",\n+            \"    <Module __init__.py>\",\n+            \"      <Function test_init>\",\n+        ]\n     )\n     result.stdout.no_fnmatch_line(\"*test_foo*\")\n \ndiff --git a/testing/test_config.py b/testing/test_config.py\nindex 900cccee80b..18022977ca3 100644\n--- a/testing/test_config.py\n+++ b/testing/test_config.py\n@@ -1966,7 +1966,8 @@ def test_config_blocked_default_plugins(pytester: Pytester, plugin: str) -> None\n         assert result.ret == ExitCode.USAGE_ERROR\n         result.stderr.fnmatch_lines(\n             [\n-                \"ERROR: found no collectors for */test_config_blocked_default_plugins.py\",\n+                \"ERROR: not found: */test_config_blocked_default_plugins.py\",\n+                \"(no match in any of *<Dir *>*\",\n             ]\n         )\n         return\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 7415b393ef2..609f73d68eb 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -871,17 +871,30 @@ def test_one(): assert 1\n         deselected_tests = dlist[0].items\n         assert len(deselected_tests) == 1\n \n-    def test_no_match_directories_outside_the_suite(self, pytester: Pytester) -> None:\n+    def test_no_match_directories_outside_the_suite(\n+        self,\n+        pytester: Pytester,\n+        monkeypatch: pytest.MonkeyPatch,\n+    ) -> None:\n         \"\"\"`-k` should not match against directories containing the test suite (#7040).\"\"\"\n-        test_contents = \"\"\"\n-            def test_aaa(): pass\n-            def test_ddd(): pass\n-        \"\"\"\n+        pytester.makefile(\n+            **{\n+                \"suite/pytest\": \"\"\"[pytest]\"\"\",\n+            },\n+            ext=\".ini\",\n+        )\n         pytester.makepyfile(\n-            **{\"ddd/tests/__init__.py\": \"\", \"ddd/tests/test_foo.py\": test_contents}\n+            **{\n+                \"suite/ddd/tests/__init__.py\": \"\",\n+                \"suite/ddd/tests/test_foo.py\": \"\"\"\n+                def test_aaa(): pass\n+                def test_ddd(): pass\n+            \"\"\",\n+            }\n         )\n+        monkeypatch.chdir(pytester.path / \"suite\")\n \n-        def get_collected_names(*args):\n+        def get_collected_names(*args: str) -> List[str]:\n             _, rec = pytester.inline_genitems(*args)\n             calls = rec.getcalls(\"pytest_collection_finish\")\n             assert len(calls) == 1\n@@ -893,12 +906,6 @@ def get_collected_names(*args):\n         # do not collect anything based on names outside the collection tree\n         assert get_collected_names(\"-k\", pytester._name) == []\n \n-        # \"-k ddd\" should only collect \"test_ddd\", but not\n-        # 'test_aaa' just because one of its parent directories is named \"ddd\";\n-        # this was matched previously because Package.name would contain the full path\n-        # to the package\n-        assert get_collected_names(\"-k\", \"ddd\") == [\"test_ddd\"]\n-\n \n class TestMarkDecorator:\n     @pytest.mark.parametrize(\ndiff --git a/testing/test_reports.py b/testing/test_reports.py\nindex 387d2e807ce..627ea1ed24f 100644\n--- a/testing/test_reports.py\n+++ b/testing/test_reports.py\n@@ -304,9 +304,9 @@ def test_a():\n             report = reports[1]\n         else:\n             assert report_class is CollectReport\n-            # two collection reports: session and test file\n+            # three collection reports: session, test file, directory\n             reports = reprec.getreports(\"pytest_collectreport\")\n-            assert len(reports) == 2\n+            assert len(reports) == 3\n             report = reports[1]\n \n         def check_longrepr(longrepr: ExceptionChainRepr) -> None:\n@@ -471,7 +471,7 @@ def test_b(): pass\n         )\n         reprec = pytester.inline_run()\n         reports = reprec.getreports(\"pytest_collectreport\")\n-        assert len(reports) == 2\n+        assert len(reports) == 3\n         for rep in reports:\n             data = pytestconfig.hook.pytest_report_to_serializable(\n                 config=pytestconfig, report=rep\ndiff --git a/testing/test_runner.py b/testing/test_runner.py\nindex cab631ee12e..c8b646857e7 100644\n--- a/testing/test_runner.py\n+++ b/testing/test_runner.py\n@@ -1006,7 +1006,7 @@ def test_longreprtext_collect_skip(self, pytester: Pytester) -> None:\n         )\n         rec = pytester.inline_run()\n         calls = rec.getcalls(\"pytest_collectreport\")\n-        _, call = calls\n+        _, call, _ = calls\n         assert isinstance(call.report.longrepr, tuple)\n         assert \"Skipped\" in call.report.longreprtext\n \ndiff --git a/testing/test_session.py b/testing/test_session.py\nindex 48dc08e8c8f..136e85eb640 100644\n--- a/testing/test_session.py\n+++ b/testing/test_session.py\n@@ -172,8 +172,9 @@ def test_one(): pass\n         except pytest.skip.Exception:  # pragma: no cover\n             pytest.fail(\"wrong skipped caught\")\n         reports = reprec.getreports(\"pytest_collectreport\")\n-        assert len(reports) == 1\n-        assert reports[0].skipped\n+        # Session, Dir\n+        assert len(reports) == 2\n+        assert reports[1].skipped\n \n \n class TestNewSession(SessionTests):\n@@ -357,9 +358,10 @@ def test_2(): pass\n     )\n     result.stdout.fnmatch_lines(\n         [\n-            \"<Module d/test_it.py>\",\n-            \"  <Function test_1>\",\n-            \"  <Function test_2>\",\n+            \"  <Dir d>\",\n+            \"    <Module test_it.py>\",\n+            \"      <Function test_1>\",\n+            \"      <Function test_2>\",\n         ],\n         consecutive=True,\n     )\n@@ -373,11 +375,12 @@ def test_2(): pass\n     )\n     result.stdout.fnmatch_lines(\n         [\n-            \"<Module d/test_it.py>\",\n-            \"  <Function test_1>\",\n-            \"  <Function test_2>\",\n-            \"  <Function test_1>\",\n-            \"  <Function test_2>\",\n+            \"  <Dir d>\",\n+            \"    <Module test_it.py>\",\n+            \"      <Function test_1>\",\n+            \"      <Function test_2>\",\n+            \"      <Function test_1>\",\n+            \"      <Function test_2>\",\n         ],\n         consecutive=True,\n     )\ndiff --git a/testing/test_terminal.py b/testing/test_terminal.py\nindex 264ab96d8d0..12c80f9b8b8 100644\n--- a/testing/test_terminal.py\n+++ b/testing/test_terminal.py\n@@ -451,7 +451,11 @@ def test_func():\n         )\n         result = pytester.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines(\n-            [\"<Module test_collectonly_basic.py>\", \"  <Function test_func>\"]\n+            [\n+                \"<Dir test_collectonly_basic0>\",\n+                \"  <Module test_collectonly_basic.py>\",\n+                \"    <Function test_func>\",\n+            ]\n         )\n \n     def test_collectonly_skipped_module(self, pytester: Pytester) -> None:\n@@ -480,14 +484,15 @@ def test_with_description():\n         result = pytester.runpytest(\"--collect-only\", \"--verbose\")\n         result.stdout.fnmatch_lines(\n             [\n-                \"<YamlFile test1.yaml>\",\n-                \"  <YamlItem test1.yaml>\",\n-                \"<Module test_collectonly_displays_test_description.py>\",\n-                \"  <Function test_with_description>\",\n-                \"    This test has a description.\",\n-                \"    \",\n-                \"    more1.\",\n-                \"      more2.\",\n+                \"<Dir test_collectonly_displays_test_description0>\",\n+                \"  <YamlFile test1.yaml>\",\n+                \"    <YamlItem test1.yaml>\",\n+                \"  <Module test_collectonly_displays_test_description.py>\",\n+                \"    <Function test_with_description>\",\n+                \"      This test has a description.\",\n+                \"      \",\n+                \"      more1.\",\n+                \"        more2.\",\n             ],\n             consecutive=True,\n         )\n@@ -2001,9 +2006,9 @@ def test_normal_verbosity(self, pytester: Pytester, test_files) -> None:\n         result = pytester.runpytest(\"-o\", \"console_output_style=classic\")\n         result.stdout.fnmatch_lines(\n             [\n+                f\"sub{os.sep}test_three.py .F.\",\n                 \"test_one.py .\",\n                 \"test_two.py F\",\n-                f\"sub{os.sep}test_three.py .F.\",\n                 \"*2 failed, 3 passed in*\",\n             ]\n         )\n@@ -2012,18 +2017,18 @@ def test_verbose(self, pytester: Pytester, test_files) -> None:\n         result = pytester.runpytest(\"-o\", \"console_output_style=classic\", \"-v\")\n         result.stdout.fnmatch_lines(\n             [\n-                \"test_one.py::test_one PASSED\",\n-                \"test_two.py::test_two FAILED\",\n                 f\"sub{os.sep}test_three.py::test_three_1 PASSED\",\n                 f\"sub{os.sep}test_three.py::test_three_2 FAILED\",\n                 f\"sub{os.sep}test_three.py::test_three_3 PASSED\",\n+                \"test_one.py::test_one PASSED\",\n+                \"test_two.py::test_two FAILED\",\n                 \"*2 failed, 3 passed in*\",\n             ]\n         )\n \n     def test_quiet(self, pytester: Pytester, test_files) -> None:\n         result = pytester.runpytest(\"-o\", \"console_output_style=classic\", \"-q\")\n-        result.stdout.fnmatch_lines([\".F.F.\", \"*2 failed, 3 passed in*\"])\n+        result.stdout.fnmatch_lines([\".F..F\", \"*2 failed, 3 passed in*\"])\n \n \n class TestProgressOutputStyle:\n", "problem_statement": "How should package collection work?\nI am working on cleaning up our collection code, but the current behavior seems odd and incidental, therefore I'd first like to discuss how it *should* behave.\r\n\r\npytest and operating system versions: pytest 6.0.2/master on Linux.\r\n\r\n### Current behavior\r\n\r\nConsider the following filesystem tree:\r\n\r\n```\r\na\r\n\u251c\u2500\u2500 b\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 c\r\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 d\r\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\r\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test_d.py\r\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test_c.py\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test_b.py\r\n\u251c\u2500\u2500 b2\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test_b2.py\r\n\u251c\u2500\u2500 __init__.py\r\n\u2514\u2500\u2500 test_a.py\r\n```\r\n\r\nThis has several nested packages, but note that the `c` level doesn't have an `__init__.py` (just to make it more interesting).\r\n\r\nThis results in the following collection tree:\r\n\r\n```\r\n$ pytest --co a/\r\ncollected 5 items\r\n\r\n<Package a>\r\n  <Module test_a.py>\r\n    <Function test_a1>\r\n<Package b>\r\n  <Module test_b.py>\r\n    <Function test_b1>\r\n<Module a/b/c/test_c.py>\r\n  <Function test_c1>\r\n<Package d>\r\n  <Module test_d.py>\r\n    <Function test_d1>\r\n<Package b2>\r\n  <Module test_b2.py>\r\n    <Function test_b21>\r\n```\r\n\r\nThe `Package`s are all flat, not nested. Namespace packages are not considered `Package`s. Files not inside packages are collected as standalone `Module`s.\r\n\r\nThis however does not reveal the real story. See what happens when `--keep-duplicates` is used:\r\n\r\n```\r\n$ pytest --co --keep-duplicates a/\r\ncollected 11 items\r\n\r\n<Package a>\r\n  <Module test_a.py>\r\n    <Function test_a1>\r\n  <Package b>\r\n    <Module test_b.py>\r\n      <Function test_b1>\r\n    <Module test_c.py>\r\n      <Function test_c1>\r\n    <Package d>\r\n      <Module test_d.py>\r\n        <Function test_d1>\r\n  <Package b2>\r\n    <Module test_b2.py>\r\n      <Function test_b21>\r\n<Package b>\r\n  <Module test_b.py>\r\n    <Function test_b1>\r\n  <Module test_c.py>\r\n    <Function test_c1>\r\n  <Package d>\r\n    <Module test_d.py>\r\n      <Function test_d1>\r\n<Module a/b/c/test_c.py>\r\n  <Function test_c1>\r\n<Package d>\r\n  <Module test_d.py>\r\n    <Function test_d1>\r\n<Package b2>\r\n  <Module test_b2.py>\r\n    <Function test_b21>\r\n```\r\n\r\nThis has all of the previous collectors, but also duplicates which are nested under each Package.\r\n\r\n### Technical details\r\n\r\nFor this interested, the code details are as follows:\r\n\r\npytest has two recursive filesystem collectors, `Session` and `Package`.\r\n\r\n[`Session.collect()`](https://github.com/pytest-dev/pytest/blob/cdfdb3a25d1033f732072d9a4d2fb700feb73a09/src/_pytest/main.py#L636) walks the entire trees (of the given command line arguments) recursively in BFS order and creates collectors for `Package`s and `Module`s. It has various obscure code to special-case `Package`s and exclude files belonging directly to the package. The `Collector`s it creates always have the `Session` as parent (i.e. flat).\r\n\r\nNote that the `Collector`s themselves are only recursively expanded to `Item`s *after* the above is finished. (This step is done by `Session.genitems()` which calls each `Collector`'s own `collect()` method).\r\n\r\n[`Package.collect()`](https://github.com/pytest-dev/pytest/blob/cdfdb3a25d1033f732072d9a4d2fb700feb73a09/src/_pytest/python.py#L692) also walks the package's directory recursively. It has some code to try to avoid collecting `Modules` belonging to sub-packages, but otherwise creates `Module`s and `Package`s with itself as parent.\r\n\r\nSince the stuff collected by `Package`s was already collected by the `Session` (with the exception of a package's own direct files) they are mostly discarded as duplicates unless `--keep-duplicates` is used.\r\n\r\n### Question\r\n\r\nMy question is, what do we *want* to happen?\r\n\r\nEvidently the nesting is not super important, otherwise we would have heard loud complaints by now (though there are some issues about this). But the nesting does have an effect on how package-scope fixtures are applied - reuse from super-package or not?\r\n\r\nThe duplication seems definitely broken.\r\n\r\nAnd there is a question on how PEP 382 namespace packages fit into this (if it all).\r\n\r\nWould be happy for any thoughts!\n", "hints_text": "I'd like to have a more detailed discussion about structuring the collection tree, we accrued a mess that requires some decomposition to begin with \nThanks @bluetech for putting up this detailed description.\r\n\r\nIndeed the Package node was not thought through before being included, and I'm at fault for not giving the attention it deserved at the time.\r\n\r\n> Evidently the nesting is not super important, otherwise we would have heard loud complaints by now (though there are some issues about this). But the nesting does have an effect on how package-scope fixtures are applied - reuse from super-package or not?\r\n\r\nI think packages should be nested, just like the other nodes. I'm surprised that no one noticed this inconsistency before (including myself). Then package-scoped fixtures follow the normal rules that other fixtures follow.\r\n\r\nThe question about namespace packages unfortunately is not that simple. Besides being a pain to detect at runtime (at least that I recall the discussions around that subject), we need to wonder how they would be represented given that in the same namespace package, sub-packages might be located in completely different directories, and the collection tree is directory-based. In other words, in your example if we collect `a/b/c` as a namespace package, what happens if some other `c/foo` package exists in a directory outside of the collection root `a`?\r\n\r\nI think however we can postpone what to do with namespace packages to some other time, and focus on natural packages (those with `__init__.py`) instead for now.\r\n\r\n> I'd like to have a more detailed discussion about structuring the collection tree, we accrued a mess that requires some decomposition to begin with\r\n\r\nGood idea @RonnyPfannschmidt. You want to do that here or somewhere else? I think here is fine IMHO. \r\n\r\n\nFound this issue while trying to figure out why my nested test packages all report as top level packages. I, for one, if I went through the trouble to nest them, I want them to be nested when reported. Is there a way to force that to happen right now for my situation as a workaround? I've tried so many things that I'm at a loss.\n> Found this issue while trying to figure out why my nested test packages all report as top level packages. I, for one, if I went through the trouble to nest them, I want them to be nested when reported. Is there a way to force that to happen right now for my situation as a workaround? I've tried so many things that I'm at a loss.\r\n\r\nOk, so I wrote a plugin as a workaround for what I needed since I couldn't find anything else. Code is MIT license.\r\nPyPI: https://pypi.org/project/pytest-prefer-nested-dup-tests/\r\ngithub: https://github.com/MarximusMaximus/pytest-prefer-nested-dup-tests\r\n\r\nHopefully it's useful to other people!\n### Possible Plan\r\n\r\nLooked at this again.\r\n\r\nThe main trouble here stems from the fact that we have two recursive collectors -- `Session` and `Package` -- which step on each other toes in unexpected ways, and it's very hard to fix.\r\n\r\nI'm increasingly convinced that we shouldn't have *any* recursive collector. *Huh*? Well, if you think about it, we already have a concept to handle the recursion for us -- the collection tree. The collectors are already recursively expanded on their own, that is, a `Collector` can collect other `Collector`s, which are then collected themselves, etc. until we get only `Item`s (for reference, see [`Session.genitems`](https://github.com/pytest-dev/pytest/blob/9fa82598a96ce28013630a45ef4af0074f73f944/src/_pytest/main.py#L823-L836), which is literally implemented with simple recursion).\r\n\r\nWhat does it mean in practice? At a high level:\r\n\r\n- Introduce a new `Directory` collector node.\r\n- Remove recursion (filesystem walking) from `Session` and `Package`.\r\n- A directory is collected like this: if the directory contains an `__init__.py` file, create a `Package`, otherwise a `Directory`.\r\n- `Session` collects directories from the collection arguments (paths given on the command line/`testpaths`).\r\n- `Package` and `Directory` collect like this: scan their directory: if the entry is a file, collect it like today; if it's a directory, collect it like as above.\r\n\r\nThis looks like this:\r\n\r\n```\r\n<Session>\r\n    <Package a>\r\n        <Package b>\r\n            <Directory c>\r\n                <Package d>\r\n                    <Module test_d.py>\r\n                        <Function test_d>\r\n                <Module test_c.py>\r\n                    <Function test_c>\r\n            <Module test_b.py>\r\n                <Function test_b>\r\n        <Package b2>\r\n            <Module test_b2.py>\r\n                <Function test_b2>\r\n        <Module test_a.py>\r\n            <Function test_a>\r\n```\r\n\r\nSome points:\r\n\r\n- `<Directory c>` is what I call a \"graft\" - a non-package directory inside of a package directory. There are two options: nest it under `<Package b>`, or nest it directly under `Session` as an independent sub-tree. This mostly has implications for `package` scope fixtures.\r\n\r\n- Seems like in very old versions of `pytest` there existed a `Directory` node, but it was removed in 6dac77433eb139247f94ac07c6caf6784b341a70. It's too hard to try and figure out why unfortunately.\r\n\r\n- One thing I need to think about is *file* collection arguments (i.e. `pytest foo/bar/test_it.py`). We need to have collection nodes for `foo` and `foo/bar` in this case (be they `Directory`s or `Package`s), but ignore irrelevant paths (e.g. `foo/test_baz.py`). This is currently handled by `Session`, but can't be under the new scheme (I think. Maybe the \"matchnodes\" mechanism is good enough for this).\r\n\r\n- This will have to go in a major release as a breaking change.\r\n\r\nI have a very simple POC implementation, but there are a bunch of details to figure out. Interested to hear opinions. I vaguely remember @RonnyPfannschmidt mentioned a `Directory` node, but I can't find it and might be misremembering.\nIt's been more than a decade, that directory node existed\n\nIt was undone for good reasons, but I think it is reasonable to reintroduce it \n> It was undone for good reasons\r\n\r\nDo you remember what they were? I do suspect there is some issue here; the Directory solution is pretty natural and harmonious with the entire collection tree concept, that I'm sure it's been tried. If there's something fundamental I'm sure I'll run into it eventually but sooner is better than later :)\nPytest prior to the refactoring back then had no concept of separation of test running and test execution\n\nTests where executed as found\n\nWhile changing the details, it was simpler to do collect towards if there where only files and session \nSuggestion regarding the design above: Directory nodes wrap Packages that are not inside other Packages, such as:\r\n\r\n```\r\n<Session>\r\n    <Directory a>\r\n        <Package a>\r\n            <Package b>\r\n                <Directory c>\r\n                    <Package d>\r\n                        <Module test_d.py>\r\n                            <Function test_d>\r\n                    <Module test_c.py>\r\n                        <Function test_c>\r\n                <Module test_b.py>\r\n                    <Function test_b>\r\n            <Package b2>\r\n                <Module test_b2.py>\r\n                    <Function test_b2>\r\n            <Module test_a.py>\r\n                <Function test_a>\r\n    <Directory z>\r\n        <Package z>\r\n            ...\r\n        <Module z>\r\n            ...\r\n     <Directory y>\r\n        <Directory y2>\r\n            <Module y3> (single explicit file path case: ./y/y2/y3.py)\r\n```\r\n\r\nI feel like this (1) makes it clear that a session can be multiple directories (since it can already be multiple \"top level\" packages, this is roughly equivalent), and (2) Should(tm) make it easier to track file system scoping b/c it Should(tm) only need to find the closest parent Directory node.\r\n\r\nNOTE: The suggestion implies that we would SKIP Directory Nodes for sub-packages and modules BUT include directory nodes for \"grafted sub-packages\". In other words, (I think) only add a Directory Node if the directory lacks an __init__.py (grafted case) OR does not have a parent package (top level packages).\n@MarximusMaximus right. I'm not entirely sure how it would look like exactly, but that's the basic idea - `Directory` is a non-package directory, and `Package` is a yes-package directory (really the `__init__.py` file); and we mirror the filesystem hierarchy with either `Directory` or `Package` nodes.\nIn case I get hit by a bus, my WIP branch is here: https://github.com/bluetech/pytest/commits/pkg-collect\r\n\r\nIt seems viable for sure, but very delicate.\n### `Package` should not be a `Module`\r\n\r\n*This comment was extracted to #11137*\n### `pytest_collect_directory` hook\r\n\r\nAfter the changes proposed in this issue, all of `Session`, `Package` and `Directory` would need to collect directories. It basically looks like this:\r\n\r\n```py\r\nif (path / \"__init__.py\").is_file:\r\n    return Package.from_parent(parent, path=path)\r\nelse:\r\n    return Directory.from_parent(parent, path=path)\r\n```\r\n\r\nI don't like that this logic is hardcoded, and repeated in 3 places.\r\n\r\nI propose to add a new hook, `pytest_collect_directory`, similar to the existing `pytest_collect_file`, but for directories. There will be 2 implementations:\r\n\r\n1. An implementation in `main.py` will create `Directory` nodes.\r\n2. An implementation in `pytest.py` will create `Package` nodes, if the directory has an `__init__.py` file.\r\n\r\nThis has the following benefits:\r\n\r\n1. Avoids the repetition.\r\n2. Decouples the `python` plugin - now `main` doesn't need to know about `Package` anymore, the `python` plugin plugs `Package` itself.\r\n3. Plugins can invent new features involving directories. For example, a `YamlDirectory` which collects files based on some manifest, or a virtual filesystem, etc.\r\n\r\nOne question is whether the hook should be `firstresult` or not. The `pytest_collect_file` hook is not, which means multiple plugins can generate multiple nodes for a single file. But `firstresult=False` creates an issue for `pytest_collect_directory` -- `main` doesn't want to create a `Directory` if a `Package` is created. So I'm going to define `pytest_collect_directory` as `firstresult=True`, which means only one plugin creates a node for a directory.\r\n\r\n### POC\r\n\r\nThis is currently implemented as part of the bigger change here:\r\nhttps://github.com/bluetech/pytest/commits/pkg-collect\r\nThis branch doesn't pass all tests yet, but I don't foresee issues with `pytest_collect_directory` in particular.\nAmusingly I just realized that `pytest_collect_directory` already existed up to pytest 6.0, but was removed because it was broken: [deprecation doc](https://github.com/pytest-dev/pytest/blob/85c5bd26b6d94dca423c2c0c54717750eac81cae/doc/en/deprecations.rst#pytest-collect-directory-hook), [deprecation issue](https://github.com/pytest-dev/pytest/issues/571), [deprecation pr](https://github.com/pytest-dev/pytest/pull/6847), [removal pr](https://github.com/pytest-dev/pytest/pull/7660). So I propose to bring it back, with a different definition (py.path -> pathlib, returns the node instead of just being called??), but this time it will actually work and be useful :)\nAfter a lot of tinkering with obscure pytest behaviors (`keepduplicates`, conftest exceptions, eek), I managed to make the branch pass all tests. I'll now be working on preparing it for submission (split commits, update docs, add tests, add changelogs, finding relevant issues etc.). I'll be proposing it for pytest 8.0.\n### Abstract `Directory` node, parent of `Dir` and `Package`\r\n\r\nOne change I've made from the initial proposal is to add an abstract `nodes.Directory` node, which is analogous to `nodes.File` for files, and renamed the concrete `Directory` node to `Dir` to avoid the naming conflict.\r\n\r\nReminder: `nodes.File` is the parent of `python.Module`, but also used for [non-Python tests](https://docs.pytest.org/en/7.3.x/example/nonpython.html), like `YamlFile` etc.\r\n\r\nSince now we have a proper collector hierarchy mirroring the filesystem hierarchy, I've decided to add an abstract `nodes.Directory`, which is a parent of the concrete `python.Package` (directories with `__init__.py`) and `main.Dir` (directories without `__init__.py`).\r\n\r\nI think it's nice because:\r\n\r\n1. Plugins can invent their own `Directory` nodes, like they can for `File`s.\r\n\r\n2. It further decouples the python plugin, now can replace explicit checks for `python.Package` (where it stands for \"a directory\") to `nodes.Directory`.\r\n\r\n3. We can replace the `package` scope, which is tied to `python.Package`, with a `directory` scope which works for any `Directory`. Why not allow non-`Package` directories to have directory-level fixtures? (This will be follow up work if we think it's a good idea).\r\n\r\n4. I think it would be good to tighten `pytest_collect_directory` return type to `nodes.Directory`, to make clear the expectations from this hook. (Side note: would also be good to make `pytest_collect_file` need to return `nodes.File` instead of an arbitrary `Collector`...).\n### Order of files vs. directories in collection\r\n\r\nPreviously, files in a directory were collected before sub-directories in the directory. That is, given a filesystem tree\r\n\r\n```\r\ntop/\r\n\u251c\u2500\u2500 aaa\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test_aaa.py\r\n\u251c\u2500\u2500 test_a.py\r\n\u251c\u2500\u2500 test_b\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test_b.py\r\n\u251c\u2500\u2500 test_c.py\r\n\u2514\u2500\u2500 zzz\r\n    \u2514\u2500\u2500 test_zzz.py\r\n```\r\n\r\nwould collect as\r\n\r\n```\r\n<Module top/test_a.py>\r\n  <Function test_it>\r\n<Module top/test_c.py>\r\n  <Function test_it>\r\n<Module top/aaa/test_aaa.py>\r\n  <Function test_it>\r\n<Module top/test_b/test_b.py>\r\n  <Function test_it>\r\n<Module top/zzz/test_zzz.py>\r\n  <Function test_it>\r\n```\r\n\r\nAfter my changes, the order that naturally flows from the code is that files and sub-directories are orderer jointly, that is the tree is\r\n\r\n```\r\n<Dir pytest>\r\n  <Dir top>\r\n    <Dir aaa>\r\n      <Module test_aaa.py>\r\n        <Function test_it>\r\n    <Module test_a.py>\r\n      <Function test_it>\r\n    <Dir test_b>\r\n      <Module test_b.py>\r\n        <Function test_it>\r\n    <Module test_c.py>\r\n      <Function test_it>\r\n    <Dir zzz>\r\n      <Module test_zzz.py>\r\n        <Function test_it>\r\n```\r\n\r\nFor now I am keeping the joint ordering, but let me know if you think ordering files before subdirs is better.", "created_at": "2023-11-27T21:47:19Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11625, "instance_id": "pytest-dev__pytest-11625", "issue_numbers": ["11610"], "base_commit": "80442ae2f2177039e5395d8a26fc6e3ca3a54f3e", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex d8e90171504..d54da7eeb01 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -188,6 +188,7 @@ Javier Romero\n Jeff Rackauckas\n Jeff Widman\n Jenni Rinker\n+Jens Tr\u00f6ger\n John Eddie Ayson\n John Litborn\n John Towler\ndiff --git a/changelog/11610.feature.rst b/changelog/11610.feature.rst\nnew file mode 100644\nindex 00000000000..34df3470509\n--- /dev/null\n+++ b/changelog/11610.feature.rst\n@@ -0,0 +1,2 @@\n+Added :func:`LogCaptureFixture.filtering() <pytest.LogCaptureFixture.filtering>` context manager that\n+adds a given :class:`logging.Filter` object to the caplog fixture.\n", "test_patch": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex bacca4b2aa9..246a4ab6eb0 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -564,6 +564,22 @@ def at_level(\n             self.handler.setLevel(handler_orig_level)\n             logging.disable(original_disable_level)\n \n+    @contextmanager\n+    def filtering(self, filter_: logging.Filter) -> Generator[None, None, None]:\n+        \"\"\"Context manager that temporarily adds the given filter to the caplog's\n+        :meth:`handler` for the 'with' statement block, and removes that filter at the\n+        end of the block.\n+\n+        :param filter_: A custom :class:`logging.Filter` object.\n+\n+        .. versionadded:: 7.5\n+        \"\"\"\n+        self.handler.addFilter(filter_)\n+        try:\n+            yield\n+        finally:\n+            self.handler.removeFilter(filter_)\n+\n \n @fixture\n def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\ndiff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex 753cf5fcd03..f4912aecce4 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -144,7 +144,7 @@ def test3(caplog):\n     result.assert_outcomes(passed=3)\n \n \n-def test_with_statement(caplog: pytest.LogCaptureFixture) -> None:\n+def test_with_statement_at_level(caplog: pytest.LogCaptureFixture) -> None:\n     with caplog.at_level(logging.INFO):\n         logger.debug(\"handler DEBUG level\")\n         logger.info(\"handler INFO level\")\n@@ -159,7 +159,9 @@ def test_with_statement(caplog: pytest.LogCaptureFixture) -> None:\n     assert \"CRITICAL\" in caplog.text\n \n \n-def test_with_statement_logging_disabled(caplog: pytest.LogCaptureFixture) -> None:\n+def test_with_statement_at_level_logging_disabled(\n+    caplog: pytest.LogCaptureFixture,\n+) -> None:\n     logging.disable(logging.CRITICAL)\n     assert logging.root.manager.disable == logging.CRITICAL\n     with caplog.at_level(logging.WARNING):\n@@ -185,6 +187,22 @@ def test_with_statement_logging_disabled(caplog: pytest.LogCaptureFixture) -> No\n     assert logging.root.manager.disable == logging.CRITICAL\n \n \n+def test_with_statement_filtering(caplog: pytest.LogCaptureFixture) -> None:\n+    class TestFilter(logging.Filter):\n+        def filter(self, record: logging.LogRecord) -> bool:\n+            record.msg = \"filtered handler call\"\n+            return True\n+\n+    with caplog.at_level(logging.INFO):\n+        with caplog.filtering(TestFilter()):\n+            logger.info(\"handler call\")\n+        logger.info(\"handler call\")\n+\n+    filtered_tuple, unfiltered_tuple = caplog.record_tuples\n+    assert filtered_tuple == (\"test_fixture\", 20, \"filtered handler call\")\n+    assert unfiltered_tuple == (\"test_fixture\", 20, \"handler call\")\n+\n+\n @pytest.mark.parametrize(\n     \"level_str,expected_disable_level\",\n     [\n", "problem_statement": "Add a `set_filter()` context manager to the caplog fixture\n<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\n<!-- What are you trying to do, that you are unable to achieve with pytest as it currently stands? -->\r\n\r\nI need to test a custom [filter](https://docs.python.org/3/library/logging.html#filter-objects) for logging, and currently I use one of the following two approaches:\r\n```python\r\ndef test_filter(caplog: pytest.LogCaptureFixture) -> None:\r\n    caplog.set_level(logging.INFO)\r\n\r\n    logger = logging.getLogger(__name__)  # This test module's logger.\r\n    filter_ = SchnufteCustomFilter()\r\n    logger.addFilter(filter_)\r\n\r\n    # Run tests.\r\n    assert len(caplog.record_tuples) == 1\r\n    assert caplog.record_tuples[0] == (\"test_custom_filter\", 20, \"Schnufte!\")\r\n\r\n    logger.removeFilter(filter_)\r\n```\r\nor\r\n```python\r\ndef test_filter(caplog: pytest.LogCaptureFixture) -> None:\r\n    caplog.set_level(logging.INFO)\r\n\r\n    filter_ = SchnufteCustomFilter()\r\n    caplog.handler.addFilter(filter_)\r\n\r\n    # Run tests.\r\n    assert len(caplog.record_tuples) == 1\r\n    assert caplog.record_tuples[0] == (\"test_custom_filter\", 20, \"Schnufte!\")     \r\n\r\n    caplog.handler.removeFilter(filter_)\r\n```\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\n\r\nSimilar to the [`at_level()`](https://docs.pytest.org/en/6.2.x/reference.html?highlight=logcapturefixture#pytest.LogCaptureFixture.at_level) context manager I think it would be useful to wrap the second of the above filter setups into a custom context manager, that I can then call like so:\r\n```python\r\ndef test_filter(caplog: pytest.LogCaptureFixture) -> None:\r\n    caplog.set_level(logging.INFO)\r\n\r\n    filter_ = SchnufteCustomFilter()\r\n    with caplog.set_filter(filter_):  # use_filter() or with_filter() or ...\r\n        # Run tests.\r\n        assert len(caplog.record_tuples) == 1\r\n        assert caplog.record_tuples[0] == (\"test_custom_filter\", 20, \"Schnufte!\")     \r\n```\r\n\r\n#### Alternative Solutions\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\n\r\nSee above\u2019s examples, I guess.\r\n\r\n#### Additional context\r\n<!-- Add any other context, links, etc. about the feature here. -->\r\n\r\nI\u2019m happy to give a PR a shot: I suppose the change would be adding a method to the [LogCaptureFixture](https://github.com/pytest-dev/pytest/blob/99f77388107fcee4cbc665659fac61c8468b693d/src/_pytest/logging.py#L391), for example:\r\n```python\r\n@final\r\nclass LogCaptureFixture:\r\n\r\n    @contextmanager\r\n    def set_filter(filter_: logging.Filter) -> Generator[None, None, None]:  # Type needs to be aligned with _FilterType from stdlib/typeshed.\r\n        self.handler.addFilter(filter_)\r\n        try:\r\n            yield\r\n        finally:\r\n            self.handler.removeFilter(filter_)\r\n```\n", "hints_text": "\ud83d\udc4d  from me.\r\n\r\nBikesheding:\r\n\r\n```python\r\nwith caplog.with_filter(SchnufteCustomFilter()): ...\r\n\r\nwith caplog.filtering(SchnufteCustomFilter()): ...\r\n```\r\n\r\nI prefer the latter, reads naturally to me (although I'm not a native speaker).\n@nicoddemus shall I go ahead and create a PR?\nYes please\n@nicoddemus what\u2019s the recommendation regarding testing: the `at_level()` context manager  has its own test functions [here](https://github.com/pytest-dev/pytest/blob/80442ae2f2177039e5395d8a26fc6e3ca3a54f3e/testing/logging/test_fixture.py#L147-L185), so I could add the new `filtering()` context manager into those existing functions, or create new functions?\nNew functions are preferred. \ud83d\udc4d ", "created_at": "2023-11-18T05:22:14Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11594, "instance_id": "pytest-dev__pytest-11594", "issue_numbers": ["11282"], "base_commit": "e701df5eb6645c0aaaab385e28f6ecf98b692a31", "patch": "diff --git a/changelog/11282.breaking.rst b/changelog/11282.breaking.rst\nnew file mode 100644\nindex 00000000000..cee9788ef1c\n--- /dev/null\n+++ b/changelog/11282.breaking.rst\n@@ -0,0 +1,11 @@\n+Sanitized the handling of the ``default`` parameter when defining configuration options.\n+\n+Previously if ``default`` was not supplied for :meth:`parser.addini <pytest.Parser.addini>` and the configuration option value was not defined in a test session, then calls to :func:`config.getini <pytest.Config.getini>` returned an *empty list* or an *empty string* depending on whether ``type`` was supplied or not respectively, which is clearly incorrect. Also, ``None`` was not honored even if ``default=None`` was used explicitly while defining the option.\n+\n+Now the behavior of :meth:`parser.addini <pytest.Parser.addini>` is as follows:\n+\n+* If ``default`` is NOT passed but ``type`` is provided, then a type-specific default will be returned. For example ``type=bool`` will return ``False``, ``type=str`` will return ``\"\"``, etc.\n+* If ``default=None`` is passed and the option is not defined in a test session, then ``None`` will be returned, regardless of the ``type``.\n+* If neither ``default`` nor ``type`` are provided, assume ``type=str`` and return ``\"\"`` as default (this is as per previous behavior).\n+\n+The team decided to not introduce a deprecation period for this change, as doing so would be complicated both in terms of communicating this to the community as well as implementing it, and also because the team believes this change should not break existing plugins except in rare cases.\n", "test_patch": "diff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py\nindex 447ebc42abb..03f69ed31e3 100644\n--- a/src/_pytest/config/__init__.py\n+++ b/src/_pytest/config/__init__.py\n@@ -1495,6 +1495,27 @@ def addinivalue_line(self, name: str, line: str) -> None:\n     def getini(self, name: str):\n         \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n \n+        If a configuration value is not defined in an\n+        :ref:`ini file <configfiles>`, then the ``default`` value provided while\n+        registering the configuration through\n+        :func:`parser.addini <pytest.Parser.addini>` will be returned.\n+        Please note that you can even provide ``None`` as a valid\n+        default value.\n+\n+        If ``default`` is not provided while registering using\n+        :func:`parser.addini <pytest.Parser.addini>`, then a default value\n+        based on the ``type`` parameter passed to\n+        :func:`parser.addini <pytest.Parser.addini>` will be returned.\n+        The default values based on ``type`` are:\n+        ``paths``, ``pathlist``, ``args`` and ``linelist`` : empty list ``[]``\n+        ``bool`` : ``False``\n+        ``string`` : empty string ``\"\"``\n+\n+        If neither the ``default`` nor the ``type`` parameter is passed\n+        while registering the configuration through\n+        :func:`parser.addini <pytest.Parser.addini>`, then the configuration\n+        is treated as a string and a default empty string '' is returned.\n+\n         If the specified name hasn't been registered through a prior\n         :func:`parser.addini <pytest.Parser.addini>` call (usually from a\n         plugin), a ValueError is raised.\n@@ -1521,11 +1542,7 @@ def _getini(self, name: str):\n             try:\n                 value = self.inicfg[name]\n             except KeyError:\n-                if default is not None:\n-                    return default\n-                if type is None:\n-                    return \"\"\n-                return []\n+                return default\n         else:\n             value = override_value\n         # Coerce the values based on types.\ndiff --git a/src/_pytest/config/argparsing.py b/src/_pytest/config/argparsing.py\nindex e345de01639..461b8afdff9 100644\n--- a/src/_pytest/config/argparsing.py\n+++ b/src/_pytest/config/argparsing.py\n@@ -27,6 +27,14 @@\n FILE_OR_DIR = \"file_or_dir\"\n \n \n+class NotSet:\n+    def __repr__(self) -> str:\n+        return \"<notset>\"\n+\n+\n+NOT_SET = NotSet()\n+\n+\n @final\n class Parser:\n     \"\"\"Parser for command line arguments and ini-file values.\n@@ -176,7 +184,7 @@ def addini(\n         type: Optional[\n             Literal[\"string\", \"paths\", \"pathlist\", \"args\", \"linelist\", \"bool\"]\n         ] = None,\n-        default: Any = None,\n+        default: Any = NOT_SET,\n     ) -> None:\n         \"\"\"Register an ini-file option.\n \n@@ -203,10 +211,30 @@ def addini(\n         :py:func:`config.getini(name) <pytest.Config.getini>`.\n         \"\"\"\n         assert type in (None, \"string\", \"paths\", \"pathlist\", \"args\", \"linelist\", \"bool\")\n+        if default is NOT_SET:\n+            default = get_ini_default_for_type(type)\n+\n         self._inidict[name] = (help, type, default)\n         self._ininames.append(name)\n \n \n+def get_ini_default_for_type(\n+    type: Optional[Literal[\"string\", \"paths\", \"pathlist\", \"args\", \"linelist\", \"bool\"]]\n+) -> Any:\n+    \"\"\"\n+    Used by addini to get the default value for a given ini-option type, when\n+    default is not supplied.\n+    \"\"\"\n+    if type is None:\n+        return \"\"\n+    elif type in (\"paths\", \"pathlist\", \"args\", \"linelist\"):\n+        return []\n+    elif type == \"bool\":\n+        return False\n+    else:\n+        return \"\"\n+\n+\n class ArgumentError(Exception):\n     \"\"\"Raised if an Argument instance is created with invalid or\n     inconsistent arguments.\"\"\"\ndiff --git a/testing/test_config.py b/testing/test_config.py\nindex ded30790188..b7c61feea98 100644\n--- a/testing/test_config.py\n+++ b/testing/test_config.py\n@@ -5,6 +5,7 @@\n import sys\n import textwrap\n from pathlib import Path\n+from typing import Any\n from typing import Dict\n from typing import List\n from typing import Sequence\n@@ -21,6 +22,7 @@\n from _pytest.config import ConftestImportFailure\n from _pytest.config import ExitCode\n from _pytest.config import parse_warning_filter\n+from _pytest.config.argparsing import get_ini_default_for_type\n from _pytest.config.exceptions import UsageError\n from _pytest.config.findpaths import determine_setup\n from _pytest.config.findpaths import get_common_ancestor\n@@ -857,6 +859,68 @@ def pytest_addoption(parser):\n         assert len(values) == 2\n         assert values == [\"456\", \"123\"]\n \n+    def test_addini_default_values(self, pytester: Pytester) -> None:\n+        \"\"\"Tests the default values for configuration based on\n+        config type\n+        \"\"\"\n+\n+        pytester.makeconftest(\n+            \"\"\"\n+            def pytest_addoption(parser):\n+                parser.addini(\"linelist1\", \"\", type=\"linelist\")\n+                parser.addini(\"paths1\", \"\", type=\"paths\")\n+                parser.addini(\"pathlist1\", \"\", type=\"pathlist\")\n+                parser.addini(\"args1\", \"\", type=\"args\")\n+                parser.addini(\"bool1\", \"\", type=\"bool\")\n+                parser.addini(\"string1\", \"\", type=\"string\")\n+                parser.addini(\"none_1\", \"\", type=\"linelist\", default=None)\n+                parser.addini(\"none_2\", \"\", default=None)\n+                parser.addini(\"no_type\", \"\")\n+        \"\"\"\n+        )\n+\n+        config = pytester.parseconfig()\n+        # default for linelist, paths, pathlist and args is []\n+        value = config.getini(\"linelist1\")\n+        assert value == []\n+        value = config.getini(\"paths1\")\n+        assert value == []\n+        value = config.getini(\"pathlist1\")\n+        assert value == []\n+        value = config.getini(\"args1\")\n+        assert value == []\n+        # default for bool is False\n+        value = config.getini(\"bool1\")\n+        assert value is False\n+        # default for string is \"\"\n+        value = config.getini(\"string1\")\n+        assert value == \"\"\n+        # should return None if None is explicity set as default value\n+        # irrespective of the type argument\n+        value = config.getini(\"none_1\")\n+        assert value is None\n+        value = config.getini(\"none_2\")\n+        assert value is None\n+        # in case no type is provided and no default set\n+        # treat it as string and default value will be \"\"\n+        value = config.getini(\"no_type\")\n+        assert value == \"\"\n+\n+    @pytest.mark.parametrize(\n+        \"type, expected\",\n+        [\n+            pytest.param(None, \"\", id=\"None\"),\n+            pytest.param(\"string\", \"\", id=\"string\"),\n+            pytest.param(\"paths\", [], id=\"paths\"),\n+            pytest.param(\"pathlist\", [], id=\"pathlist\"),\n+            pytest.param(\"args\", [], id=\"args\"),\n+            pytest.param(\"linelist\", [], id=\"linelist\"),\n+            pytest.param(\"bool\", False, id=\"bool\"),\n+        ],\n+    )\n+    def test_get_ini_default_for_type(self, type: Any, expected: Any) -> None:\n+        assert get_ini_default_for_type(type) == expected\n+\n     def test_confcutdir_check_isdir(self, pytester: Pytester) -> None:\n         \"\"\"Give an error if --confcutdir is not a valid directory (#2078)\"\"\"\n         exp_match = r\"^--confcutdir must be a directory, given: \"\n", "problem_statement": "config.getini returns an empty list for an option of type string absent in INI file\nI want to manage this INI option \r\n```\r\n    parser.addini(\r\n        \"my_option\",\r\n        type=\"string\",\r\n        default=None,\r\n        help=\"My option\",\r\n    )\r\n```\r\n\r\nI decide not to include this option in the INI file\r\n\r\nI read the value with this code\r\n\r\n```\r\n@pytest.fixture(scope='session')\r\ndef my_option(request):\r\n    return request.config.getini(\"my_option\")\r\n```\r\n\r\nActual result: The returned value is an empty list\r\n\r\nExpected result: None\r\n\r\nTested with pytest 7.4.0 on Linux Mint\r\n\n", "hints_text": "Here is an actual reproducer:\r\n\r\n`conftest.py`:\r\n\r\n```python\r\nimport pytest\r\n\r\ndef pytest_addoption(parser):\r\n    parser.addini(\r\n        \"my_option\",\r\n        type=\"string\",\r\n        default=None,\r\n        help=\"My option\",\r\n    )\r\n\r\n@pytest.fixture(scope='session')\r\ndef my_option(request):\r\n    return request.config.getini(\"my_option\")\r\n```\r\n\r\n`test_x.py`:\r\n\r\n```python\r\ndef test_x(my_option):\r\n    assert my_option is None\r\n```\r\n\r\nresults in:\r\n\r\n```python\r\n    def test_x(my_option):\r\n>       assert my_option is None\r\nE       assert [] is None\r\n```\nHello @harmin-parra, @The-Compiler, @Zac-HD,\r\n\r\nI can work on this fix if you all agree.\r\n\r\nRegards\r\nSharad\nHello all,\r\n\r\nI have a question regarding this issue. Should **config.getini()** return \"None\" irrespective of the \"type\" provided for the configuration? What if the the \"type\" is linelist or pathlist with no default value or \"None\" provided in configuration or while making the call to **parser.addini()**\r\n\r\nPlease look at a test that exists in the current code base that implicitly assumes that the configuration item named \"xy\" has a default value of empty list. I think the correct way to call **parser.addini()** is to always provide a default value if you are expecting it to return an Empty List or any other data type. Which means the call to addini() in the test code below should be:\r\n\r\nparser.addini(\"xy\", \"\", type=\"linelist\", **default=[]**)\r\ninstead of just\r\nparser.addini(\"xy\", \"\", type=\"linelist\")\r\n\r\n```\r\n def test_addinivalue_line_new(self, pytester: Pytester) -> None:\r\n        pytester.makeconftest(\r\n            \"\"\"\r\n            def pytest_addoption(parser):\r\n                parser.addini(\"xy\", \"\", type=\"linelist\")\r\n        \"\"\"\r\n        )\r\n        config = pytester.parseconfig()\r\n        assert not config.getini(\"xy\")\r\n        config.addinivalue_line(\"xy\", \"456\")\r\n        values = config.getini(\"xy\")\r\n        assert len(values) == 1\r\n        assert values == [\"456\"]\r\n        config.addinivalue_line(\"xy\", \"123\")\r\n        values = config.getini(\"xy\")\r\n        assert len(values) == 2\r\n        assert values == [\"456\", \"123\"]\r\n```\r\n\r\nPlease let me know your views as there are some occurrences within the code base that makes this assumption of implicit default values based on \"type\".\r\n\r\nRegards\r\nSharad\nthe issue lies in https://github.com/pytest-dev/pytest/blob/b73b4c464c6fa54f55a1c6ed8eaceb5529a161bb/src/_pytest/config/__init__.py#L1521-L1528\r\n\r\nit tries to be smart based on type, but does not quite deal with all kinds of types correctly\r\n\r\nas far as i can tell there also is the case of automatically returning \"\" on a empty default for a string when no type was defined (none implies string)\r\n\r\nmaybe using something like dataclasses.Missing as a experiment to see how to make sane default return values could be a starting point\r\n\r\n\r\n\r\n\r\n\nThank you @RonnyPfannschmidt,\r\n\r\nBut my question was around the expected behavior after making changes for this issue. This issue as raised by @harmin-parra expects config.getini() to return \"None\" if \"None\" is set as the default value while adding the configuration item using parser.addini().\r\n\r\n**Solution 1**\r\nReturn \"None\" as the default value if \"None\" or no default value if provided by the developer. In this approach, existing calls to the config.getini() function would need to check for \"None\" values\r\n\r\n**Solution 2**\r\nReturn a default value based on the \"type\" argument. If no type argument is specified, then it will be treated as a string. But in this approach, \"None\" will never be returned as a default value.\r\n\r\n**Solution 3**\r\nThe default value can have an additional possible option of \"NotSet\" which would mean that the developer did not pass any value for the \"default\" parameter. This will be different from passing \"None\" as default. In this approach, the following behavior will be seen:\r\n\r\n1) If the developer sets \"None\" as the default value for the configuration, then \"None\" will be returned irrespective of the \"type\" parameter.\r\n2) if the developer does not provide any value for the configuration, then it will be treated as \"NotSet\" and an appropriate default value based on the \"type\" argument will be returned. If no \"type\" argument is provided, the an empty string will be returned.\r\n\r\nPlease let me know which approach would be more acceptable?\r\n\r\nRegards\r\nSharad\r\n\nI personally feel, Solution 1 is the right way to go considering the straight forward and clean approach.\r\n\r\nregards\r\nSharad\n+1 for solution 1\r\n\r\nWe should return `None` if `None` is set as default value and no input value is provided by the user\nI also agree that \r\n`parser.addini(\"xy\", \"\", type=\"linelist\", default=[])` :white_check_mark:\r\nwhile\r\n`parser.addini(\"xy\", \"\", type=\"linelist\") `:x:\r\n\r\nThe source code of `parser.addoption` says that this function takes the same arguments as the `add_argument` function of the\r\nargparse library <https://docs.python.org/library/argparse.html>\r\n\r\nThe default value for the `default` parameter of `add_argument` function is `None`.\r\n\r\nSo I don't understand why the unit test checks for `[]` as default value.", "created_at": "2023-11-07T13:01:20Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11584, "instance_id": "pytest-dev__pytest-11584", "issue_numbers": ["11572"], "base_commit": "fdb8bbf15499fc3dfe3547822df7a38fcf103538", "patch": "diff --git a/changelog/11572.bugfix.rst b/changelog/11572.bugfix.rst\nnew file mode 100644\nindex 00000000000..7a235a071fe\n--- /dev/null\n+++ b/changelog/11572.bugfix.rst\n@@ -0,0 +1,1 @@\n+Handle an edge case where :data:`sys.stderr` and :data:`sys.__stderr__` might already be closed when :ref:`faulthandler` is tearing down.\n", "test_patch": "diff --git a/src/_pytest/faulthandler.py b/src/_pytest/faulthandler.py\nindex a9418f34e11..1bccd18c636 100644\n--- a/src/_pytest/faulthandler.py\n+++ b/src/_pytest/faulthandler.py\n@@ -9,8 +9,8 @@\n from _pytest.stash import StashKey\n \n \n+fault_handler_original_stderr_fd_key = StashKey[int]()\n fault_handler_stderr_fd_key = StashKey[int]()\n-fault_handler_originally_enabled_key = StashKey[bool]()\n \n \n def pytest_addoption(parser: Parser) -> None:\n@@ -24,8 +24,15 @@ def pytest_addoption(parser: Parser) -> None:\n def pytest_configure(config: Config) -> None:\n     import faulthandler\n \n-    config.stash[fault_handler_stderr_fd_key] = os.dup(get_stderr_fileno())\n-    config.stash[fault_handler_originally_enabled_key] = faulthandler.is_enabled()\n+    # at teardown we want to restore the original faulthandler fileno\n+    # but faulthandler has no api to return the original fileno\n+    # so here we stash the stderr fileno to be used at teardown\n+    # sys.stderr and sys.__stderr__ may be closed or patched during the session\n+    # so we can't rely on their values being good at that point (#11572).\n+    stderr_fileno = get_stderr_fileno()\n+    if faulthandler.is_enabled():\n+        config.stash[fault_handler_original_stderr_fd_key] = stderr_fileno\n+    config.stash[fault_handler_stderr_fd_key] = os.dup(stderr_fileno)\n     faulthandler.enable(file=config.stash[fault_handler_stderr_fd_key])\n \n \n@@ -37,9 +44,10 @@ def pytest_unconfigure(config: Config) -> None:\n     if fault_handler_stderr_fd_key in config.stash:\n         os.close(config.stash[fault_handler_stderr_fd_key])\n         del config.stash[fault_handler_stderr_fd_key]\n-    if config.stash.get(fault_handler_originally_enabled_key, False):\n-        # Re-enable the faulthandler if it was originally enabled.\n-        faulthandler.enable(file=get_stderr_fileno())\n+    # Re-enable the faulthandler if it was originally enabled.\n+    if fault_handler_original_stderr_fd_key in config.stash:\n+        faulthandler.enable(config.stash[fault_handler_original_stderr_fd_key])\n+        del config.stash[fault_handler_original_stderr_fd_key]\n \n \n def get_stderr_fileno() -> int:\n", "problem_statement": "ValueError: I/O operation on closed file\nThis is a follow-up to this issue https://github.com/pytest-dev/pytest/issues/11439\r\n\r\nNow the exception comes from `sys.__stderr__.fileno()`\r\n\r\nMaybe it would be better to stash the original value of stderr and use that in unconfigure rather than trying to get it by calling fileno()? Happy to supply a patch.\r\n\r\n```shell\r\nTraceback (most recent call last):\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/faulthandler.py\", line 47, in get_stderr_fileno\r\n    fileno = sys.stderr.fileno()\r\nValueError: I/O operation on closed file\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/venv3.9/bin/pytest\", line 8, in <module>\r\n    sys.exit(console_main())\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/config/__init__.py\", line 192, in console_main\r\n    code = main()\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/config/__init__.py\", line 169, in main\r\n    ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n    raise exception.with_traceback(exception.__traceback__)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/main.py\", line 318, in pytest_cmdline_main\r\n    return wrap_session(config, _main)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/main.py\", line 313, in wrap_session\r\n    config._ensure_unconfigure()\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/config/__init__.py\", line 1058, in _ensure_unconfigure\r\n    self.hook.pytest_unconfigure(config=self)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\r\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\r\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\r\n    raise exception.with_traceback(exception.__traceback__)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\r\n    res = hook_impl.function(*args)\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/faulthandler.py\", line 42, in pytest_unconfigure\r\n    faulthandler.enable(file=get_stderr_fileno())\r\n  File \"/home/venv3.9/lib/python3.9/site-packages/_pytest/faulthandler.py\", line 57, in get_stderr_fileno\r\n    return sys.__stderr__.fileno()\r\nValueError: I/O operation on closed file\r\n```\r\n\r\n\r\n## Environment\r\n\r\n```shell\r\nPython \t3.9.10\r\nPlatform \tLinux-5.4.226-129.415.amzn2.x86_64-x86_64-with-glibc2.31\r\nPackages \t\r\n\r\n    pytest: 7.4.3\r\n    pluggy: 1.3.0\r\n\r\nPlugins \t\r\n\r\n    Faker: 19.6.2\r\n    anyio: 4.0.0\r\n    cov: 4.1.0\r\n    csv: 3.0.0\r\n    django: 4.5.2\r\n    factoryboy: 2.5.1\r\n    flake8: 1.1.1\r\n    html: 4.0.2\r\n    icdiff: 0.7\r\n    instafail: 0.5.0\r\n    isort: 3.1.0\r\n    metadata: 3.0.0\r\n    mock: 3.11.1\r\n    mypy: 0.10.3\r\n    ordering: 0.6\r\n    randomly: 3.15.0\r\n    subprocess: 1.5.0\r\n    timeout: 2.1.0\r\n    xdist: 3.3.1\r\n    typeguard: 2.13.3\r\n```\n", "hints_text": "~~Seeing this whenever calling pytest from inside the code https://docs.pytest.org/en/7.4.x/how-to/usage.html#calling-pytest-from-python-code . It still exits with the correct exit code but the stack trace looks terrifying~~\r\n\r\nNevermind, the issue here was setting up the logger twice by mistake.", "created_at": "2023-11-03T20:41:09Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11578, "instance_id": "pytest-dev__pytest-11578", "issue_numbers": ["11577"], "base_commit": "8fb7e8b31efaa55e760c142e26eb82b42081ca28", "patch": "diff --git a/doc/en/how-to/assert.rst b/doc/en/how-to/assert.rst\nindex cc53d001f70..1401064d772 100644\n--- a/doc/en/how-to/assert.rst\n+++ b/doc/en/how-to/assert.rst\n@@ -98,6 +98,27 @@ and if you need to have access to the actual exception info you may use:\n the actual exception raised.  The main attributes of interest are\n ``.type``, ``.value`` and ``.traceback``.\n \n+Note that ``pytest.raises`` will match the exception type or any subclasses (like the standard ``except`` statement).\n+If you want to check if a block of code is raising an exact exception type, you need to check that explicitly:\n+\n+\n+.. code-block:: python\n+\n+    def test_recursion_depth():\n+        def foo():\n+            raise NotImplementedError\n+\n+        with pytest.raises(RuntimeError) as excinfo:\n+            foo()\n+        assert type(excinfo.value) is RuntimeError\n+\n+The :func:`pytest.raises` call will succeed, even though the function raises :class:`NotImplementedError`, because\n+:class:`NotImplementedError` is a subclass of :class:`RuntimeError`; however the following `assert` statement will\n+catch the problem.\n+\n+Matching exception messages\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n You can pass a ``match`` keyword parameter to the context-manager to test\n that a regular expression matches on the string representation of an exception\n (similar to the ``TestCase.assertRaisesRegex`` method from ``unittest``):\n@@ -115,9 +136,15 @@ that a regular expression matches on the string representation of an exception\n         with pytest.raises(ValueError, match=r\".* 123 .*\"):\n             myfunc()\n \n-The regexp parameter of the ``match`` parameter is matched with the ``re.search``\n-function, so in the above example ``match='123'`` would have worked as\n-well.\n+Notes:\n+\n+* The ``match`` parameter is matched with the :func:`re.search`\n+  function, so in the above example ``match='123'`` would have worked as well.\n+* The ``match`` parameter also matches against `PEP-678 <https://peps.python.org/pep-0678/>`__ ``__notes__``.\n+\n+\n+Matching exception groups\n+~~~~~~~~~~~~~~~~~~~~~~~~~\n \n You can also use the :func:`excinfo.group_contains() <pytest.ExceptionInfo.group_contains>`\n method to test for exceptions returned as part of an ``ExceptionGroup``:\n@@ -165,32 +192,55 @@ exception at a specific level; exceptions contained directly in the top\n         assert not excinfo.group_contains(RuntimeError, depth=2)\n         assert not excinfo.group_contains(TypeError, depth=1)\n \n-There's an alternate form of the :func:`pytest.raises` function where you pass\n-a function that will be executed with the given ``*args`` and ``**kwargs`` and\n-assert that the given exception is raised:\n+Alternate form (legacy)\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+There is an alternate form where you pass\n+a function that will be executed, along ``*args`` and ``**kwargs``, and :func:`pytest.raises`\n+will execute the function with the arguments and assert that the given exception is raised:\n \n .. code-block:: python\n \n-    pytest.raises(ExpectedException, func, *args, **kwargs)\n+    def func(x):\n+        if x <= 0:\n+            raise ValueError(\"x needs to be larger than zero\")\n+\n+\n+    pytest.raises(ValueError, func, x=-1)\n \n The reporter will provide you with helpful output in case of failures such as *no\n exception* or *wrong exception*.\n \n-Note that it is also possible to specify a \"raises\" argument to\n-``pytest.mark.xfail``, which checks that the test is failing in a more\n+This form was the original :func:`pytest.raises` API, developed before the ``with`` statement was\n+added to the Python language. Nowadays, this form is rarely used, with the context-manager form (using ``with``)\n+being considered more readable.\n+Nonetheless, this form is fully supported and not deprecated in any way.\n+\n+xfail mark and pytest.raises\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+It is also possible to specify a ``raises`` argument to\n+:ref:`pytest.mark.xfail <pytest.mark.xfail ref>`, which checks that the test is failing in a more\n specific way than just having any exception raised:\n \n .. code-block:: python\n \n+    def f():\n+        raise IndexError()\n+\n+\n     @pytest.mark.xfail(raises=IndexError)\n     def test_f():\n         f()\n \n-Using :func:`pytest.raises` is likely to be better for cases where you are\n-testing exceptions your own code is deliberately raising, whereas using\n-``@pytest.mark.xfail`` with a check function is probably better for something\n-like documenting unfixed bugs (where the test describes what \"should\" happen)\n-or bugs in dependencies.\n+\n+This will only \"xfail\" if the test fails by raising ``IndexError`` or subclasses.\n+\n+* Using :ref:`pytest.mark.xfail <pytest.mark.xfail ref>` with the ``raises`` parameter is probably better for something\n+  like documenting unfixed bugs (where the test describes what \"should\" happen) or bugs in dependencies.\n+\n+* Using :func:`pytest.raises` is likely to be better for cases where you are\n+  testing exceptions your own code is deliberately raising, which is the majority of cases.\n \n \n .. _`assertwarns`:\ndiff --git a/doc/en/reference/reference.rst b/doc/en/reference/reference.rst\nindex 7764b03eb43..0240e1f4aad 100644\n--- a/doc/en/reference/reference.rst\n+++ b/doc/en/reference/reference.rst\n@@ -249,7 +249,9 @@ Marks a test function as *expected to fail*.\n     :keyword str reason:\n         Reason why the test function is marked as xfail.\n     :keyword Type[Exception] raises:\n-        Exception subclass (or tuple of subclasses) expected to be raised by the test function; other exceptions will fail the test.\n+        Exception class (or tuple of classes) expected to be raised by the test function; other exceptions will fail the test.\n+        Note that subclasses of the classes passed will also result in a match (similar to how the ``except`` statement works).\n+\n     :keyword bool run:\n         Whether the test function should actually be executed. If ``False``, the function will always xfail and will\n         not be executed (useful if a function is segfaulting).\n", "test_patch": "diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 27826863ead..07db0f234d4 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -804,11 +804,13 @@ def raises(  # noqa: F811\n def raises(  # noqa: F811\n     expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any\n ) -> Union[\"RaisesContext[E]\", _pytest._code.ExceptionInfo[E]]:\n-    r\"\"\"Assert that a code block/function call raises an exception.\n+    r\"\"\"Assert that a code block/function call raises an exception type, or one of its subclasses.\n \n     :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:\n         The expected exception type, or a tuple if one of multiple possible\n-        exception types are expected.\n+        exception types are expected. Note that subclasses of the passed exceptions\n+        will also match.\n+\n     :kwparam str | typing.Pattern[str] | None match:\n         If specified, a string containing a regular expression,\n         or a regular expression object, that is tested against the string\n@@ -826,13 +828,13 @@ def raises(  # noqa: F811\n     .. currentmodule:: _pytest._code\n \n     Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n-    type::\n+    type, or any of its subclasses::\n \n         >>> import pytest\n         >>> with pytest.raises(ZeroDivisionError):\n         ...    1/0\n \n-    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n+    If the code block does not raise the expected exception (:class:`ZeroDivisionError` in the example\n     above), or no exception at all, the check will fail instead.\n \n     You can also use the keyword argument ``match`` to assert that the\n@@ -845,7 +847,7 @@ def raises(  # noqa: F811\n         ...     raise ValueError(\"value must be 42\")\n \n     The ``match`` argument searches the formatted exception string, which includes any\n-    `PEP-678 <https://peps.python.org/pep-0678/>` ``__notes__``:\n+    `PEP-678 <https://peps.python.org/pep-0678/>`__ ``__notes__``:\n \n         >>> with pytest.raises(ValueError, match=r'had a note added'):  # doctest: +SKIP\n         ...    e = ValueError(\"value must be 42\")\n@@ -860,6 +862,20 @@ def raises(  # noqa: F811\n         >>> assert exc_info.type is ValueError\n         >>> assert exc_info.value.args[0] == \"value must be 42\"\n \n+    .. warning::\n+\n+       Given that ``pytest.raises`` matches subclasses, be wary of using it to match :class:`Exception` like this::\n+\n+           with pytest.raises(Exception):  # Careful, this will catch ANY exception raised.\n+                some_function()\n+\n+       Because :class:`Exception` is the base class of almost all exceptions, it is easy for this to hide\n+       real bugs, where the user wrote this expecting a specific exception, but some other exception is being\n+       raised due to a bug introduced during a refactoring.\n+\n+       Avoid using ``pytest.raises`` to catch :class:`Exception` unless certain that you really want to catch\n+       **any** exception raised.\n+\n     .. note::\n \n        When using ``pytest.raises`` as a context manager, it's worthwhile to\n@@ -872,7 +888,7 @@ def raises(  # noqa: F811\n            >>> with pytest.raises(ValueError) as exc_info:\n            ...     if value > 10:\n            ...         raise ValueError(\"value must be <= 10\")\n-           ...     assert exc_info.type is ValueError  # this will not execute\n+           ...     assert exc_info.type is ValueError  # This will not execute.\n \n        Instead, the following approach must be taken (note the difference in\n        scope)::\n@@ -891,6 +907,10 @@ def raises(  # noqa: F811\n \n     See :ref:`parametrizing_conditional_raising` for an example.\n \n+    .. seealso::\n+\n+        :ref:`assertraises` for more examples and detailed discussion.\n+\n     **Legacy form**\n \n     It is possible to specify a callable by passing a to-be-called lambda::\n", "problem_statement": "Document that pytest.raises matches subclasses; consider an opt-in exact mode\n#### What's the problem this feature will solve?\r\nThe [documentation for `pytest.raises`](https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-raises) makes no mention of the fact that it will pass if **any subclass** of the provided exception type is raised.\r\n\r\nIt says things like this which are arguably ambiguous, or at least unclear if you haven't thought of the subclass case:\r\n> Assert that a code block/function call raises expected_exception or raise a failure exception otherwise.\r\n> ...\r\n> If the code block does not raise the expected exception ... the check will fail instead.\r\n\r\nI had to look at the internals (it just [uses it in an `except`](https://github.com/pytest-dev/pytest/blob/8fb7e8b31efaa55e760c142e26eb82b42081ca28/src/_pytest/python_api.py#L961)) to confirm this behaviour, after realising soething was up due to coverage flagging a `raise` which was not covered despite a passing test which _appeared_ to test that code path.\r\n\r\n#### Describe the solution you'd like\r\n\r\n1. At a minimum it would help to update the documentation to make this clearer, e.g. just adding a sentence flagging that subclasses are matched too, just like in `except`.\r\n2. Additionally could we consider an option to `raises` such as `match_exact_type=True`? This would be a much more concise way to achieve the explicit exc_info.type check as shown in the workaround below.\r\n\r\n#### Alternative Solutions\r\n\r\nAlthough it was not at all obvious to me, I now realise that I can modify the test to be more specific, e.g. in my case the test did this:\r\n```\r\nwith pytest.raises(RuntimeError):\r\n    do_stuff()\r\n```\r\nand the code under test did `raise RuntimeError()`.\r\n\r\nIt passed but for the wrong reasons: `do_stuff()` was actually raising `NotImplementedError` (a subclass of RuntimeError) for an entirely unrelated reason.\r\n\r\nAs a workaround now that I've realised this, it's possible to explicitly do an exact match on the exception type like this:\r\n```\r\nwith pytest.raises(RuntimeError) as exc_info:\r\n    do_stuff()\r\n\r\n# Check it's actually RuntimeError, not just any subclass thereof\r\nassert exc_info.type is RuntimeError\r\n```\r\nHowever this is quite verbose and only useful once you realise there's a problem, which in my case was long after the test was written and only due to missing coverage being flagged.\r\n\r\nBetter documentation would hopefully make this clearer and an option to do exact type matching would be a great bonus!\n", "hints_text": "P.S. the only related issue I could find was https://github.com/pytest-dev/pytest/issues/4475 which is different but similar - clearer documentation would hopefully make it more obvious that `pytest.raises(Exception)` is potentially risky.", "created_at": "2023-11-02T21:20:52Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11574, "instance_id": "pytest-dev__pytest-11574", "issue_numbers": ["11233"], "base_commit": "c2a4a8d518b433b0b688d084bad09040bf774f70", "patch": "diff --git a/AUTHORS b/AUTHORS\nindex 67e794527fb..353489b6cd2 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -138,6 +138,7 @@ Erik Hasse\n Erik M. Bray\n Evan Kepner\n Evgeny Seliverstov\n+Fabian Sturm\n Fabien Zarifian\n Fabio Zadrozny\n Felix Hofst\u00e4tter\ndiff --git a/changelog/11233.feature.rst b/changelog/11233.feature.rst\nnew file mode 100644\nindex 00000000000..c465def84ec\n--- /dev/null\n+++ b/changelog/11233.feature.rst\n@@ -0,0 +1,5 @@\n+Improvements to how ``-r`` for xfailures and xpasses:\n+\n+* Report tracebacks for xfailures when ``-rx`` is set.\n+* Report captured output for xpasses when ``-rX`` is set.\n+* For xpasses, add ``-`` in summary between test name and reason, to match how xfail is displayed.\n", "test_patch": "diff --git a/src/_pytest/terminal.py b/src/_pytest/terminal.py\nindex ea26d9368dc..b91a97221cd 100644\n--- a/src/_pytest/terminal.py\n+++ b/src/_pytest/terminal.py\n@@ -878,8 +878,10 @@ def pytest_sessionfinish(\n     def pytest_terminal_summary(self) -> Generator[None, None, None]:\n         self.summary_errors()\n         self.summary_failures()\n+        self.summary_xfailures()\n         self.summary_warnings()\n         self.summary_passes()\n+        self.summary_xpasses()\n         try:\n             return (yield)\n         finally:\n@@ -1009,12 +1011,20 @@ def collapsed_location_report(reports: List[WarningReport]) -> str:\n             )\n \n     def summary_passes(self) -> None:\n+        self.summary_passes_combined(\"passed\", \"PASSES\", \"P\")\n+\n+    def summary_xpasses(self) -> None:\n+        self.summary_passes_combined(\"xpassed\", \"XPASSES\", \"X\")\n+\n+    def summary_passes_combined(\n+        self, which_reports: str, sep_title: str, needed_opt: str\n+    ) -> None:\n         if self.config.option.tbstyle != \"no\":\n-            if self.hasopt(\"P\"):\n-                reports: List[TestReport] = self.getreports(\"passed\")\n+            if self.hasopt(needed_opt):\n+                reports: List[TestReport] = self.getreports(which_reports)\n                 if not reports:\n                     return\n-                self.write_sep(\"=\", \"PASSES\")\n+                self.write_sep(\"=\", sep_title)\n                 for rep in reports:\n                     if rep.sections:\n                         msg = self._getfailureheadline(rep)\n@@ -1048,21 +1058,30 @@ def print_teardown_sections(self, rep: TestReport) -> None:\n                 self._tw.line(content)\n \n     def summary_failures(self) -> None:\n+        self.summary_failures_combined(\"failed\", \"FAILURES\")\n+\n+    def summary_xfailures(self) -> None:\n+        self.summary_failures_combined(\"xfailed\", \"XFAILURES\", \"x\")\n+\n+    def summary_failures_combined(\n+        self, which_reports: str, sep_title: str, needed_opt: Optional[str] = None\n+    ) -> None:\n         if self.config.option.tbstyle != \"no\":\n-            reports: List[BaseReport] = self.getreports(\"failed\")\n-            if not reports:\n-                return\n-            self.write_sep(\"=\", \"FAILURES\")\n-            if self.config.option.tbstyle == \"line\":\n-                for rep in reports:\n-                    line = self._getcrashline(rep)\n-                    self.write_line(line)\n-            else:\n-                for rep in reports:\n-                    msg = self._getfailureheadline(rep)\n-                    self.write_sep(\"_\", msg, red=True, bold=True)\n-                    self._outrep_summary(rep)\n-                    self._handle_teardown_sections(rep.nodeid)\n+            if not needed_opt or self.hasopt(needed_opt):\n+                reports: List[BaseReport] = self.getreports(which_reports)\n+                if not reports:\n+                    return\n+                self.write_sep(\"=\", sep_title)\n+                if self.config.option.tbstyle == \"line\":\n+                    for rep in reports:\n+                        line = self._getcrashline(rep)\n+                        self.write_line(line)\n+                else:\n+                    for rep in reports:\n+                        msg = self._getfailureheadline(rep)\n+                        self.write_sep(\"_\", msg, red=True, bold=True)\n+                        self._outrep_summary(rep)\n+                        self._handle_teardown_sections(rep.nodeid)\n \n     def summary_errors(self) -> None:\n         if self.config.option.tbstyle != \"no\":\n@@ -1168,8 +1187,11 @@ def show_xpassed(lines: List[str]) -> None:\n                     verbose_word, **{_color_for_type[\"warnings\"]: True}\n                 )\n                 nodeid = _get_node_id_with_markup(self._tw, self.config, rep)\n+                line = f\"{markup_word} {nodeid}\"\n                 reason = rep.wasxfail\n-                lines.append(f\"{markup_word} {nodeid} {reason}\")\n+                if reason:\n+                    line += \" - \" + str(reason)\n+                lines.append(line)\n \n         def show_skipped(lines: List[str]) -> None:\n             skipped: List[CollectReport] = self.stats.get(\"skipped\", [])\ndiff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex a002ba6e836..86940baa6fd 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -649,7 +649,7 @@ def test_foo():\n             result.stdout.fnmatch_lines(\n                 [\n                     \"*test_strict_xfail*\",\n-                    \"XPASS test_strict_xfail.py::test_foo unsupported feature\",\n+                    \"XPASS test_strict_xfail.py::test_foo - unsupported feature\",\n                 ]\n             )\n         assert result.ret == (1 if strict else 0)\ndiff --git a/testing/test_terminal.py b/testing/test_terminal.py\nindex 20392096e40..b521deea7d1 100644\n--- a/testing/test_terminal.py\n+++ b/testing/test_terminal.py\n@@ -2619,3 +2619,122 @@ def test_format_trimmed() -> None:\n \n     assert _format_trimmed(\" ({}) \", msg, len(msg) + 4) == \" (unconditional skip) \"\n     assert _format_trimmed(\" ({}) \", msg, len(msg) + 3) == \" (unconditional ...) \"\n+\n+\n+def test_summary_xfail_reason(pytester: Pytester) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.mark.xfail\n+        def test_xfail():\n+            assert False\n+\n+        @pytest.mark.xfail(reason=\"foo\")\n+        def test_xfail_reason():\n+            assert False\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"-rx\")\n+    expect1 = \"XFAIL test_summary_xfail_reason.py::test_xfail\"\n+    expect2 = \"XFAIL test_summary_xfail_reason.py::test_xfail_reason - foo\"\n+    result.stdout.fnmatch_lines([expect1, expect2])\n+    assert result.stdout.lines.count(expect1) == 1\n+    assert result.stdout.lines.count(expect2) == 1\n+\n+\n+def test_summary_xfail_tb(pytester: Pytester) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.mark.xfail\n+        def test_xfail():\n+            a, b = 1, 2\n+            assert a == b\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"-rx\")\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*= XFAILURES =*\",\n+            \"*_ test_xfail _*\",\n+            \"* @pytest.mark.xfail*\",\n+            \"* def test_xfail():*\",\n+            \"*    a, b = 1, 2*\",\n+            \"> *assert a == b*\",\n+            \"E *assert 1 == 2*\",\n+            \"test_summary_xfail_tb.py:6: AssertionError*\",\n+            \"*= short test summary info =*\",\n+            \"XFAIL test_summary_xfail_tb.py::test_xfail\",\n+            \"*= 1 xfailed in * =*\",\n+        ]\n+    )\n+\n+\n+def test_xfail_tb_line(pytester: Pytester) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.mark.xfail\n+        def test_xfail():\n+            a, b = 1, 2\n+            assert a == b\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"-rx\", \"--tb=line\")\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*= XFAILURES =*\",\n+            \"*test_xfail_tb_line.py:6: assert 1 == 2\",\n+            \"*= short test summary info =*\",\n+            \"XFAIL test_xfail_tb_line.py::test_xfail\",\n+            \"*= 1 xfailed in * =*\",\n+        ]\n+    )\n+\n+\n+def test_summary_xpass_reason(pytester: Pytester) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.mark.xfail\n+        def test_pass():\n+            ...\n+\n+        @pytest.mark.xfail(reason=\"foo\")\n+        def test_reason():\n+            ...\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"-rX\")\n+    expect1 = \"XPASS test_summary_xpass_reason.py::test_pass\"\n+    expect2 = \"XPASS test_summary_xpass_reason.py::test_reason - foo\"\n+    result.stdout.fnmatch_lines([expect1, expect2])\n+    assert result.stdout.lines.count(expect1) == 1\n+    assert result.stdout.lines.count(expect2) == 1\n+\n+\n+def test_xpass_output(pytester: Pytester) -> None:\n+    pytester.makepyfile(\n+        \"\"\"\n+        import pytest\n+\n+        @pytest.mark.xfail\n+        def test_pass():\n+            print('hi there')\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"-rX\")\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*= XPASSES =*\",\n+            \"*_ test_pass _*\",\n+            \"*- Captured stdout call -*\",\n+            \"*= short test summary info =*\",\n+            \"XPASS test_xpass_output.py::test_pass*\",\n+            \"*= 1 xpassed in * =*\",\n+        ]\n+    )\n", "problem_statement": "`-rx` and `-rX` should turn on output for xfail/xpass\n- [x] a detailed description of the bug or problem you are having\r\n\r\n* `-rx` and `-rX` (as well as `-ra` and `-rA`) should allow output for xfail and xpass, but they don't.\r\n* There seems to be no way at all to get the traceback from xfailed tests.\r\n* There seems to be no way to get the output from xfail/xpass. (other than turning all xpass into fail with xpass strict, but that still doesn't solve the xfail case).\r\n* The summary report for xfail doesn't include the assert line, as fail does\r\n\r\nThis shows up in a discussion #9834 and another issue #10618.\r\n\r\n* discussion #9834\"\r\n   * showing there is confusion in the user base about this\r\n*  issue #10618\r\n   * This is tagged \"question\". It's not a question. It's a defect.\r\n   * @RonnyPfannschmidt [notes there](https://github.com/pytest-dev/pytest/issues/10618#issuecomment-1367289285) that the way around it is to use strict. \"That's intentional, With strict, xpass gets treated as error and should have output.\"\r\n   * That's not a sufficient response because there is still no way to get the output from xfail\r\n   * Even if this is as designed, there need to be a way to see the traceback and output from xfail and xpass. And it seems like `-rx` and `-rX` are the obvious choice. \r\n\r\n**---- More detail about problem and expectations  ----**\r\n\r\n**Observations:**\r\nBased on a simple test script below that includes `test_pass`, `test_fail`, `test_xfail`, `test_xpass`.\r\n\r\n1. Output and exception for `test_fail` but not for `test_xfail`. \r\n    * I would have expected `test_xfail` to look mostly just like `test_fail`. \r\n    * If there's a reason to NOT report exception traceback and output for xfails, we should have an option to turn it on.\r\n    \r\n2. `assert 1 == 2` is displayed in summary info for `FAILED` but not for `XFAIL`.\r\n   * I can't come up with reason why this would be correct behavior.\r\n   * `assert 1 == 2` should show up for XFAIL also.\r\n\r\n3. `-rP` (which is included in `-rA`) is \"pass with output\", and it applies to `PASSED`, but not `XPASS`.\r\n\r\n**Opinion on how to fix this:**\r\n\r\n* `XFAIL` should act like `FAILED` if it's turned on with `-rx` or `-ra` or `-rA`\r\n   * output should be reported\r\n   * traceback should be reported\r\n   * assert message should be listed in summary\r\n* `XPASS` should act like `PASSED` if it's turned on with `-rX` or `-ra` or `-rA`\r\n   * output should be reported\r\n* It seems reasonable that someone might not want to see all of this extra output.\r\n  * That's why I've suggested that this extra output NOT be on by default.\r\n  * Controlling the extra output with `-r` flags seems like the right way to do this.\r\n\r\nMy opinions, of course. But this would follow the idea of \"behavior with the least surprise\". And it doesn't require any extra flags.\r\n\r\n\r\n- [x] output of `pip list` from the virtual environment you are using\r\n\r\n```\r\n$ pip list\r\nPackage    Version\r\n---------- -------\r\ncolorama   0.4.6\r\niniconfig  2.0.0\r\npackaging  23.1\r\npip        23.2\r\npluggy     1.2.0\r\npytest     7.4.0\r\nsetuptools 65.5.0\r\n```\r\n\r\n- [x] pytest and operating system versions\r\n\r\n  * pytest 7.4.0\r\n  * Windows something, but also tested on Mac, so I think OS is irrelevant.\r\n\r\n- [x] minimal example if possible\r\n\r\n\r\n**Example: test_foo.py**\r\n```python\r\nimport pytest\r\n\r\ndef test_pass():\r\n    print('in test_pass()')\r\n    a, b = 1, 1\r\n    assert a == b\r\n\r\ndef test_fail():\r\n    print('in test_fail()')\r\n    a, b = 1, 2\r\n    assert a == b\r\n\r\n@pytest.mark.xfail\r\ndef test_xfail():\r\n    print('in test_xfail()')\r\n    a, b = 1, 2\r\n    assert a == b\r\n\r\n@pytest.mark.xfail\r\ndef test_xpass():\r\n    print('in test_xpass()')\r\n    a, b = 1, 1\r\n    assert a == b\r\n```\r\n\r\n**Current output:**\r\n```\r\n$ pytest -rA test_foo.py\r\n============================= test session starts =============================\r\nplatform win32 -- Python 3.11.0, pytest-7.4.0, pluggy-1.0.0\r\nrootdir: C:\\Users\\okken\\projects\\instrument_updater\r\nconfigfile: tox.ini\r\ncollected 4 items\r\n\r\ntest_foo.py .FxX                                                         [100%]\r\n\r\n================================== FAILURES ===================================\r\n__________________________________ test_fail __________________________________\r\n\r\n    def test_fail():\r\n        print('in test_fail()')\r\n        a, b = 1, 2\r\n>       assert a == b\r\nE       assert 1 == 2\r\n\r\ntest_foo.py:11: AssertionError\r\n---------------------------- Captured stdout call -----------------------------\r\nin test_fail()\r\n=================================== PASSES ====================================\r\n__________________________________ test_pass __________________________________\r\n---------------------------- Captured stdout call -----------------------------\r\nin test_pass()\r\n=========================== short test summary info ===========================\r\nPASSED test_foo.py::test_pass\r\nXFAIL test_foo.py::test_xfail\r\nXPASS test_foo.py::test_xpass\r\nFAILED test_foo.py::test_fail - assert 1 == 2\r\n============== 1 failed, 1 passed, 1 xfailed, 1 xpassed in 0.28s ==============\r\n```\r\n\r\n\r\n\n", "hints_text": "I'd be happy to work on this, but first I was hoping for\r\n\r\n- Agreement that `-rx` and `-rX` are the right way to control output for xfail/xpass.\r\n- Some hint at where in the code the changes should go. `reports.py`? \r\n- A hint at which tests could be used as examples to test this change in behavior\r\n\r\nOf course, I'd be \"happier\" if someone else worked on this. :)\nNote that this is a significant problem for me currently, and we don't have a workable solution.\nI'm looking in `terminal.py` now. \r\nIt looks like there are sections for ERRORS, FAILURES, PASSES.\r\nSeems like there needs to be also XFAILURES and XPASSES sections, perhaps after FAILURES and before PASSES.\nI'm not sure if I'm using labels right. I think this missing functionality is a bug, and I have a proposed way it should work.", "created_at": "2023-11-01T15:02:42Z"}
{"repo": "pytest-dev/pytest", "pull_number": 11571, "instance_id": "pytest-dev__pytest-11571", "issue_numbers": ["1531"], "base_commit": "fdb8bbf15499fc3dfe3547822df7a38fcf103538", "patch": "diff --git a/changelog/1531.improvement.rst b/changelog/1531.improvement.rst\nnew file mode 100644\nindex 00000000000..d444ea2e783\n--- /dev/null\n+++ b/changelog/1531.improvement.rst\n@@ -0,0 +1,4 @@\n+Improved the very verbose diff for every standard library container types: the indentation is now consistent and the markers are on their own separate lines, which should reduce the diffs shown to users.\n+\n+Previously, the default python pretty printer was used to generate the output, which puts opening and closing\n+markers on the same line as the first/last entry, in addition to not having consistent indentation.\n", "test_patch": "diff --git a/src/_pytest/_io/pprint.py b/src/_pytest/_io/pprint.py\nindex 9923d0a6256..bb59253f70b 100644\n--- a/src/_pytest/_io/pprint.py\n+++ b/src/_pytest/_io/pprint.py\n@@ -58,7 +58,7 @@ def _safe_tuple(t):\n class PrettyPrinter:\n     def __init__(\n         self,\n-        indent=1,\n+        indent=4,\n         width=80,\n         depth=None,\n         stream=None,\n@@ -146,7 +146,6 @@ def _format(self, object, stream, indent, allowance, context, level):\n \n     def _pprint_dataclass(self, object, stream, indent, allowance, context, level):\n         cls_name = object.__class__.__name__\n-        indent += len(cls_name) + 1\n         items = [\n             (f.name, getattr(object, f.name))\n             for f in _dataclasses.fields(object)\n@@ -164,17 +163,11 @@ def _pprint_dataclass(self, object, stream, indent, allowance, context, level):\n     def _pprint_dict(self, object, stream, indent, allowance, context, level):\n         write = stream.write\n         write(\"{\")\n-        if self._indent_per_level > 1:\n-            write((self._indent_per_level - 1) * \" \")\n-        length = len(object)\n-        if length:\n-            if self._sort_dicts:\n-                items = sorted(object.items(), key=_safe_tuple)\n-            else:\n-                items = object.items()\n-            self._format_dict_items(\n-                items, stream, indent, allowance + 1, context, level\n-            )\n+        if self._sort_dicts:\n+            items = sorted(object.items(), key=_safe_tuple)\n+        else:\n+            items = object.items()\n+        self._format_dict_items(items, stream, indent, allowance, context, level)\n         write(\"}\")\n \n     _dispatch[dict.__repr__] = _pprint_dict\n@@ -185,32 +178,22 @@ def _pprint_ordered_dict(self, object, stream, indent, allowance, context, level\n             return\n         cls = object.__class__\n         stream.write(cls.__name__ + \"(\")\n-        self._format(\n-            list(object.items()),\n-            stream,\n-            indent + len(cls.__name__) + 1,\n-            allowance + 1,\n-            context,\n-            level,\n-        )\n+        self._pprint_dict(object, stream, indent, allowance, context, level)\n         stream.write(\")\")\n \n     _dispatch[_collections.OrderedDict.__repr__] = _pprint_ordered_dict\n \n     def _pprint_list(self, object, stream, indent, allowance, context, level):\n         stream.write(\"[\")\n-        self._format_items(object, stream, indent, allowance + 1, context, level)\n+        self._format_items(object, stream, indent, allowance, context, level)\n         stream.write(\"]\")\n \n     _dispatch[list.__repr__] = _pprint_list\n \n     def _pprint_tuple(self, object, stream, indent, allowance, context, level):\n         stream.write(\"(\")\n-        endchar = \",)\" if len(object) == 1 else \")\"\n-        self._format_items(\n-            object, stream, indent, allowance + len(endchar), context, level\n-        )\n-        stream.write(endchar)\n+        self._format_items(object, stream, indent, allowance, context, level)\n+        stream.write(\")\")\n \n     _dispatch[tuple.__repr__] = _pprint_tuple\n \n@@ -225,11 +208,8 @@ def _pprint_set(self, object, stream, indent, allowance, context, level):\n         else:\n             stream.write(typ.__name__ + \"({\")\n             endchar = \"})\"\n-            indent += len(typ.__name__) + 1\n         object = sorted(object, key=_safe_key)\n-        self._format_items(\n-            object, stream, indent, allowance + len(endchar), context, level\n-        )\n+        self._format_items(object, stream, indent, allowance, context, level)\n         stream.write(endchar)\n \n     _dispatch[set.__repr__] = _pprint_set\n@@ -319,7 +299,7 @@ def _pprint_bytearray(self, object, stream, indent, allowance, context, level):\n \n     def _pprint_mappingproxy(self, object, stream, indent, allowance, context, level):\n         stream.write(\"mappingproxy(\")\n-        self._format(object.copy(), stream, indent + 13, allowance + 1, context, level)\n+        self._format(object.copy(), stream, indent, allowance, context, level)\n         stream.write(\")\")\n \n     _dispatch[_types.MappingProxyType.__repr__] = _pprint_mappingproxy\n@@ -333,7 +313,6 @@ def _pprint_simplenamespace(\n             cls_name = \"namespace\"\n         else:\n             cls_name = object.__class__.__name__\n-        indent += len(cls_name) + 1\n         items = object.__dict__.items()\n         stream.write(cls_name + \"(\")\n         self._format_namespace_items(items, stream, indent, allowance, context, level)\n@@ -342,32 +321,30 @@ def _pprint_simplenamespace(\n     _dispatch[_types.SimpleNamespace.__repr__] = _pprint_simplenamespace\n \n     def _format_dict_items(self, items, stream, indent, allowance, context, level):\n+        if not items:\n+            return\n+\n         write = stream.write\n-        indent += self._indent_per_level\n-        delimnl = \",\\n\" + \" \" * indent\n-        last_index = len(items) - 1\n-        for i, (key, ent) in enumerate(items):\n-            last = i == last_index\n-            rep = self._repr(key, context, level)\n-            write(rep)\n+        item_indent = indent + self._indent_per_level\n+        delimnl = \"\\n\" + \" \" * item_indent\n+        for key, ent in items:\n+            write(delimnl)\n+            write(self._repr(key, context, level))\n             write(\": \")\n-            self._format(\n-                ent,\n-                stream,\n-                indent + len(rep) + 2,\n-                allowance if last else 1,\n-                context,\n-                level,\n-            )\n-            if not last:\n-                write(delimnl)\n+            self._format(ent, stream, item_indent, 1, context, level)\n+            write(\",\")\n+\n+        write(\"\\n\" + \" \" * indent)\n \n     def _format_namespace_items(self, items, stream, indent, allowance, context, level):\n+        if not items:\n+            return\n+\n         write = stream.write\n-        delimnl = \",\\n\" + \" \" * indent\n-        last_index = len(items) - 1\n-        for i, (key, ent) in enumerate(items):\n-            last = i == last_index\n+        item_indent = indent + self._indent_per_level\n+        delimnl = \"\\n\" + \" \" * item_indent\n+        for key, ent in items:\n+            write(delimnl)\n             write(key)\n             write(\"=\")\n             if id(ent) in context:\n@@ -378,52 +355,30 @@ def _format_namespace_items(self, items, stream, indent, allowance, context, lev\n                 self._format(\n                     ent,\n                     stream,\n-                    indent + len(key) + 1,\n-                    allowance if last else 1,\n+                    item_indent + len(key) + 1,\n+                    1,\n                     context,\n                     level,\n                 )\n-            if not last:\n-                write(delimnl)\n+\n+            write(\",\")\n+\n+        write(\"\\n\" + \" \" * indent)\n \n     def _format_items(self, items, stream, indent, allowance, context, level):\n-        write = stream.write\n-        indent += self._indent_per_level\n-        if self._indent_per_level > 1:\n-            write((self._indent_per_level - 1) * \" \")\n-        delimnl = \",\\n\" + \" \" * indent\n-        delim = \"\"\n-        width = max_width = self._width - indent + 1\n-        it = iter(items)\n-        try:\n-            next_ent = next(it)\n-        except StopIteration:\n+        if not items:\n             return\n-        last = False\n-        while not last:\n-            ent = next_ent\n-            try:\n-                next_ent = next(it)\n-            except StopIteration:\n-                last = True\n-                max_width -= allowance\n-                width -= allowance\n-            if self._compact:\n-                rep = self._repr(ent, context, level)\n-                w = len(rep) + 2\n-                if width < w:\n-                    width = max_width\n-                    if delim:\n-                        delim = delimnl\n-                if width >= w:\n-                    width -= w\n-                    write(delim)\n-                    delim = \", \"\n-                    write(rep)\n-                    continue\n-            write(delim)\n-            delim = delimnl\n-            self._format(ent, stream, indent, allowance if last else 1, context, level)\n+\n+        write = stream.write\n+        item_indent = indent + self._indent_per_level\n+        delimnl = \"\\n\" + \" \" * item_indent\n+\n+        for item in items:\n+            write(delimnl)\n+            self._format(item, stream, item_indent, 1, context, level)\n+            write(\",\")\n+\n+        write(\"\\n\" + \" \" * indent)\n \n     def _repr(self, object, context, level):\n         repr, readable, recursive = self.format(\n@@ -443,66 +398,45 @@ def format(self, object, context, maxlevels, level):\n         return self._safe_repr(object, context, maxlevels, level)\n \n     def _pprint_default_dict(self, object, stream, indent, allowance, context, level):\n-        if not len(object):\n-            stream.write(repr(object))\n-            return\n         rdf = self._repr(object.default_factory, context, level)\n-        cls = object.__class__\n-        indent += len(cls.__name__) + 1\n-        stream.write(f\"{cls.__name__}({rdf},\\n{' ' * indent}\")\n-        self._pprint_dict(object, stream, indent, allowance + 1, context, level)\n+        stream.write(f\"{object.__class__.__name__}({rdf}, \")\n+        self._pprint_dict(object, stream, indent, allowance, context, level)\n         stream.write(\")\")\n \n     _dispatch[_collections.defaultdict.__repr__] = _pprint_default_dict\n \n     def _pprint_counter(self, object, stream, indent, allowance, context, level):\n-        if not len(object):\n-            stream.write(repr(object))\n-            return\n-        cls = object.__class__\n-        stream.write(cls.__name__ + \"({\")\n-        if self._indent_per_level > 1:\n-            stream.write((self._indent_per_level - 1) * \" \")\n-        items = object.most_common()\n-        self._format_dict_items(\n-            items, stream, indent + len(cls.__name__) + 1, allowance + 2, context, level\n-        )\n-        stream.write(\"})\")\n+        stream.write(object.__class__.__name__ + \"(\")\n+\n+        if object:\n+            stream.write(\"{\")\n+            items = object.most_common()\n+            self._format_dict_items(items, stream, indent, allowance, context, level)\n+            stream.write(\"}\")\n+\n+        stream.write(\")\")\n \n     _dispatch[_collections.Counter.__repr__] = _pprint_counter\n \n     def _pprint_chain_map(self, object, stream, indent, allowance, context, level):\n-        if not len(object.maps):\n+        if not len(object.maps) or (len(object.maps) == 1 and not len(object.maps[0])):\n             stream.write(repr(object))\n             return\n-        cls = object.__class__\n-        stream.write(cls.__name__ + \"(\")\n-        indent += len(cls.__name__) + 1\n-        for i, m in enumerate(object.maps):\n-            if i == len(object.maps) - 1:\n-                self._format(m, stream, indent, allowance + 1, context, level)\n-                stream.write(\")\")\n-            else:\n-                self._format(m, stream, indent, 1, context, level)\n-                stream.write(\",\\n\" + \" \" * indent)\n+\n+        stream.write(object.__class__.__name__ + \"(\")\n+        self._format_items(object.maps, stream, indent, allowance, context, level)\n+        stream.write(\")\")\n \n     _dispatch[_collections.ChainMap.__repr__] = _pprint_chain_map\n \n     def _pprint_deque(self, object, stream, indent, allowance, context, level):\n-        if not len(object):\n-            stream.write(repr(object))\n-            return\n-        cls = object.__class__\n-        stream.write(cls.__name__ + \"(\")\n-        indent += len(cls.__name__) + 1\n+        stream.write(object.__class__.__name__ + \"(\")\n+        if object.maxlen is not None:\n+            stream.write(\"maxlen=%d, \" % object.maxlen)\n         stream.write(\"[\")\n-        if object.maxlen is None:\n-            self._format_items(object, stream, indent, allowance + 2, context, level)\n-            stream.write(\"])\")\n-        else:\n-            self._format_items(object, stream, indent, 2, context, level)\n-            rml = self._repr(object.maxlen, context, level)\n-            stream.write(f\"],\\n{' ' * indent}maxlen={rml})\")\n+\n+        self._format_items(object, stream, indent, allowance + 1, context, level)\n+        stream.write(\"])\")\n \n     _dispatch[_collections.deque.__repr__] = _pprint_deque\n \ndiff --git a/src/_pytest/assertion/util.py b/src/_pytest/assertion/util.py\nindex 4d9fd114bc2..214c321f081 100644\n--- a/src/_pytest/assertion/util.py\n+++ b/src/_pytest/assertion/util.py\n@@ -318,18 +318,6 @@ def _diff_text(left: str, right: str, verbose: int = 0) -> List[str]:\n     return explanation\n \n \n-def _surrounding_parens_on_own_lines(lines: List[str]) -> None:\n-    \"\"\"Move opening/closing parenthesis/bracket to own lines.\"\"\"\n-    opening = lines[0][:1]\n-    if opening in [\"(\", \"[\", \"{\"]:\n-        lines[0] = \" \" + lines[0][1:]\n-        lines[:] = [opening] + lines\n-    closing = lines[-1][-1:]\n-    if closing in [\")\", \"]\", \"}\"]:\n-        lines[-1] = lines[-1][:-1] + \",\"\n-        lines[:] = lines + [closing]\n-\n-\n def _compare_eq_iterable(\n     left: Iterable[Any],\n     right: Iterable[Any],\n@@ -341,20 +329,8 @@ def _compare_eq_iterable(\n     # dynamic import to speedup pytest\n     import difflib\n \n-    left_formatting = pprint.pformat(left).splitlines()\n-    right_formatting = pprint.pformat(right).splitlines()\n-\n-    # Re-format for different output lengths.\n-    lines_left = len(left_formatting)\n-    lines_right = len(right_formatting)\n-    if lines_left != lines_right:\n-        printer = PrettyPrinter()\n-        left_formatting = printer.pformat(left).splitlines()\n-        right_formatting = printer.pformat(right).splitlines()\n-\n-    if lines_left > 1 or lines_right > 1:\n-        _surrounding_parens_on_own_lines(left_formatting)\n-        _surrounding_parens_on_own_lines(right_formatting)\n+    left_formatting = PrettyPrinter().pformat(left).splitlines()\n+    right_formatting = PrettyPrinter().pformat(right).splitlines()\n \n     explanation = [\"Full diff:\"]\n     # \"right\" is the expected base against which we compare \"left\",\ndiff --git a/testing/io/test_pprint.py b/testing/io/test_pprint.py\nindex 8c15740bd41..3432c63f688 100644\n--- a/testing/io/test_pprint.py\n+++ b/testing/io/test_pprint.py\n@@ -40,15 +40,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             DataclassWithOneItem(foo=\"bar\"),\n             \"\"\"\n-            DataclassWithOneItem(foo='bar')\n+            DataclassWithOneItem(\n+                foo='bar',\n+            )\n             \"\"\",\n             id=\"dataclass-one-item\",\n         ),\n         pytest.param(\n             DataclassWithTwoItems(foo=\"foo\", bar=\"bar\"),\n             \"\"\"\n-            DataclassWithTwoItems(foo='foo',\n-                                  bar='bar')\n+            DataclassWithTwoItems(\n+                foo='foo',\n+                bar='bar',\n+            )\n             \"\"\",\n             id=\"dataclass-two-items\",\n         ),\n@@ -60,15 +64,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             {\"one\": 1},\n             \"\"\"\n-            {'one': 1}\n+            {\n+                'one': 1,\n+            }\n             \"\"\",\n             id=\"dict-one-item\",\n         ),\n         pytest.param(\n             {\"one\": 1, \"two\": 2},\n             \"\"\"\n-            {'one': 1,\n-             'two': 2}\n+            {\n+                'one': 1,\n+                'two': 2,\n+            }\n             \"\"\",\n             id=\"dict-two-items\",\n         ),\n@@ -76,18 +84,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             OrderedDict({\"one\": 1}),\n             \"\"\"\n-            OrderedDict([('one',\n-                          1)])\n+            OrderedDict({\n+                'one': 1,\n+            })\n             \"\"\",\n             id=\"ordereddict-one-item\",\n         ),\n         pytest.param(\n             OrderedDict({\"one\": 1, \"two\": 2}),\n             \"\"\"\n-            OrderedDict([('one',\n-                          1),\n-                         ('two',\n-                          2)])\n+            OrderedDict({\n+                'one': 1,\n+                'two': 2,\n+            })\n             \"\"\",\n             id=\"ordereddict-two-items\",\n         ),\n@@ -99,15 +108,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             [1],\n             \"\"\"\n-            [1]\n+            [\n+                1,\n+            ]\n             \"\"\",\n             id=\"list-one-item\",\n         ),\n         pytest.param(\n             [1, 2],\n             \"\"\"\n-            [1,\n-             2]\n+            [\n+                1,\n+                2,\n+            ]\n             \"\"\",\n             id=\"list-two-items\",\n         ),\n@@ -119,15 +132,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             (1,),\n             \"\"\"\n-            (1,)\n+            (\n+                1,\n+            )\n             \"\"\",\n             id=\"tuple-one-item\",\n         ),\n         pytest.param(\n             (1, 2),\n             \"\"\"\n-            (1,\n-             2)\n+            (\n+                1,\n+                2,\n+            )\n             \"\"\",\n             id=\"tuple-two-items\",\n         ),\n@@ -139,15 +156,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             {1},\n             \"\"\"\n-            {1}\n+            {\n+                1,\n+            }\n             \"\"\",\n             id=\"set-one-item\",\n         ),\n         pytest.param(\n             {1, 2},\n             \"\"\"\n-            {1,\n-             2}\n+            {\n+                1,\n+                2,\n+            }\n             \"\"\",\n             id=\"set-two-items\",\n         ),\n@@ -159,15 +180,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             MappingProxyType({\"one\": 1}),\n             \"\"\"\n-            mappingproxy({'one': 1})\n+            mappingproxy({\n+                'one': 1,\n+            })\n             \"\"\",\n             id=\"mappingproxy-one-item\",\n         ),\n         pytest.param(\n             MappingProxyType({\"one\": 1, \"two\": 2}),\n             \"\"\"\n-            mappingproxy({'one': 1,\n-                          'two': 2})\n+            mappingproxy({\n+                'one': 1,\n+                'two': 2,\n+            })\n             \"\"\",\n             id=\"mappingproxy-two-items\",\n         ),\n@@ -179,15 +204,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             SimpleNamespace(one=1),\n             \"\"\"\n-            namespace(one=1)\n+            namespace(\n+                one=1,\n+            )\n             \"\"\",\n             id=\"simplenamespace-one-item\",\n         ),\n         pytest.param(\n             SimpleNamespace(one=1, two=2),\n             \"\"\"\n-            namespace(one=1,\n-                      two=2)\n+            namespace(\n+                one=1,\n+                two=2,\n+            )\n             \"\"\",\n             id=\"simplenamespace-two-items\",\n         ),\n@@ -197,17 +226,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             defaultdict(str, {\"one\": \"1\"}),\n             \"\"\"\n-            defaultdict(<class 'str'>,\n-                        {'one': '1'})\n+            defaultdict(<class 'str'>, {\n+                'one': '1',\n+            })\n             \"\"\",\n             id=\"defaultdict-one-item\",\n         ),\n         pytest.param(\n             defaultdict(str, {\"one\": \"1\", \"two\": \"2\"}),\n             \"\"\"\n-            defaultdict(<class 'str'>,\n-                        {'one': '1',\n-                         'two': '2'})\n+            defaultdict(<class 'str'>, {\n+                'one': '1',\n+                'two': '2',\n+            })\n             \"\"\",\n             id=\"defaultdict-two-items\",\n         ),\n@@ -219,15 +250,19 @@ class DataclassWithTwoItems:\n         pytest.param(\n             Counter(\"1\"),\n             \"\"\"\n-            Counter({'1': 1})\n+            Counter({\n+                '1': 1,\n+            })\n             \"\"\",\n             id=\"counter-one-item\",\n         ),\n         pytest.param(\n             Counter(\"121\"),\n             \"\"\"\n-            Counter({'1': 2,\n-                     '2': 1})\n+            Counter({\n+                '1': 2,\n+                '2': 1,\n+            })\n             \"\"\",\n             id=\"counter-two-items\",\n         ),\n@@ -235,16 +270,26 @@ class DataclassWithTwoItems:\n         pytest.param(\n             ChainMap({\"one\": 1, \"two\": 2}),\n             \"\"\"\n-            ChainMap({'one': 1,\n-                      'two': 2})\n+            ChainMap(\n+                {\n+                    'one': 1,\n+                    'two': 2,\n+                },\n+            )\n             \"\"\",\n             id=\"chainmap-one-item\",\n         ),\n         pytest.param(\n             ChainMap({\"one\": 1}, {\"two\": 2}),\n             \"\"\"\n-            ChainMap({'one': 1},\n-                     {'two': 2})\n+            ChainMap(\n+                {\n+                    'one': 1,\n+                },\n+                {\n+                    'two': 2,\n+                },\n+            )\n             \"\"\",\n             id=\"chainmap-two-items\",\n         ),\n@@ -256,24 +301,29 @@ class DataclassWithTwoItems:\n         pytest.param(\n             deque([1]),\n             \"\"\"\n-            deque([1])\n+            deque([\n+                1,\n+            ])\n             \"\"\",\n             id=\"deque-one-item\",\n         ),\n         pytest.param(\n             deque([1, 2]),\n             \"\"\"\n-            deque([1,\n-                   2])\n+            deque([\n+                1,\n+                2,\n+            ])\n             \"\"\",\n             id=\"deque-two-items\",\n         ),\n         pytest.param(\n             deque([1, 2], maxlen=3),\n             \"\"\"\n-            deque([1,\n-                   2],\n-                  maxlen=3)\n+            deque(maxlen=3, [\n+                1,\n+                2,\n+            ])\n             \"\"\",\n             id=\"deque-maxlen\",\n         ),\n@@ -293,34 +343,60 @@ class DataclassWithTwoItems:\n                 \"tuple\": (1, 2),\n             },\n             \"\"\"\n-            {'chainmap': ChainMap({'one': 1},\n-                                  {'two': 2}),\n-             'counter': Counter({'2': 2,\n-                                 '1': 1}),\n-             'dataclass': DataclassWithTwoItems(foo='foo',\n-                                                bar='bar'),\n-             'defaultdict': defaultdict(<class 'str'>,\n-                                        {'one': '1',\n-                                         'two': '2'}),\n-             'deque': deque([1,\n-                             2],\n-                            maxlen=3),\n-             'dict': {'one': 1,\n-                      'two': 2},\n-             'list': [1,\n-                      2],\n-             'mappingproxy': mappingproxy({'one': 1,\n-                                           'two': 2}),\n-             'ordereddict': OrderedDict([('one',\n-                                          1),\n-                                         ('two',\n-                                          2)]),\n-             'set': {1,\n-                     2},\n-             'simplenamespace': namespace(one=1,\n-                                          two=2),\n-             'tuple': (1,\n-                       2)}\n+            {\n+                'chainmap': ChainMap(\n+                    {\n+                        'one': 1,\n+                    },\n+                    {\n+                        'two': 2,\n+                    },\n+                ),\n+                'counter': Counter({\n+                    '2': 2,\n+                    '1': 1,\n+                }),\n+                'dataclass': DataclassWithTwoItems(\n+                    foo='foo',\n+                    bar='bar',\n+                ),\n+                'defaultdict': defaultdict(<class 'str'>, {\n+                    'one': '1',\n+                    'two': '2',\n+                }),\n+                'deque': deque(maxlen=3, [\n+                    1,\n+                    2,\n+                ]),\n+                'dict': {\n+                    'one': 1,\n+                    'two': 2,\n+                },\n+                'list': [\n+                    1,\n+                    2,\n+                ],\n+                'mappingproxy': mappingproxy({\n+                    'one': 1,\n+                    'two': 2,\n+                }),\n+                'ordereddict': OrderedDict({\n+                    'one': 1,\n+                    'two': 2,\n+                }),\n+                'set': {\n+                    1,\n+                    2,\n+                },\n+                'simplenamespace': namespace(\n+                    one=1,\n+                    two=2,\n+                ),\n+                'tuple': (\n+                    1,\n+                    2,\n+                ),\n+            }\n             \"\"\",\n             id=\"deep-example\",\n         ),\ndiff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex 7c8c0155681..ce10ed8c4e6 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -451,11 +451,14 @@ def test_list(self) -> None:\n                 [0, 2],\n                 \"\"\"\n                 Full diff:\n-                - [0, 2]\n+                  [\n+                      0,\n+                -     2,\n                 ?     ^\n-                + [0, 1]\n+                +     1,\n                 ?     ^\n-            \"\"\",\n+                  ]\n+                \"\"\",\n                 id=\"lists\",\n             ),\n             pytest.param(\n@@ -463,10 +466,12 @@ def test_list(self) -> None:\n                 {0: 2},\n                 \"\"\"\n                 Full diff:\n-                - {0: 2}\n-                ?     ^\n-                + {0: 1}\n-                ?     ^\n+                  {\n+                -     0: 2,\n+                ?        ^\n+                +     0: 1,\n+                ?        ^\n+                  }\n             \"\"\",\n                 id=\"dicts\",\n             ),\n@@ -475,10 +480,13 @@ def test_list(self) -> None:\n                 {0, 2},\n                 \"\"\"\n                 Full diff:\n-                - {0, 2}\n+                  {\n+                      0,\n+                -     2,\n                 ?     ^\n-                + {0, 1}\n+                +     1,\n                 ?     ^\n+                  }\n             \"\"\",\n                 id=\"sets\",\n             ),\n@@ -542,10 +550,10 @@ def test_list_wrap_for_multiple_lines(self) -> None:\n             \"Right contains one more item: '\" + long_d + \"'\",\n             \"Full diff:\",\n             \"  [\",\n-            \"   'a',\",\n-            \"   'b',\",\n-            \"   'c',\",\n-            \"-  '\" + long_d + \"',\",\n+            \"      'a',\",\n+            \"      'b',\",\n+            \"      'c',\",\n+            \"-     '\" + long_d + \"',\",\n             \"  ]\",\n         ]\n \n@@ -555,10 +563,10 @@ def test_list_wrap_for_multiple_lines(self) -> None:\n             \"Left contains one more item: '\" + long_d + \"'\",\n             \"Full diff:\",\n             \"  [\",\n-            \"   'a',\",\n-            \"   'b',\",\n-            \"   'c',\",\n-            \"+  '\" + long_d + \"',\",\n+            \"      'a',\",\n+            \"      'b',\",\n+            \"      'c',\",\n+            \"+     '\" + long_d + \"',\",\n             \"  ]\",\n         ]\n \n@@ -574,10 +582,10 @@ def test_list_wrap_for_width_rewrap_same_length(self) -> None:\n             \"At index 0 diff: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' != 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\",\n             \"Full diff:\",\n             \"  [\",\n-            \"+  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n-            \"   'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',\",\n-            \"   'cccccccccccccccccccccccccccccc',\",\n-            \"-  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n+            \"      'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',\",\n+            \"      'cccccccccccccccccccccccccccccc',\",\n+            \"-     'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n             \"  ]\",\n         ]\n \n@@ -592,15 +600,15 @@ def test_list_dont_wrap_strings(self) -> None:\n             \"Left contains 7 more items, first extra item: 'aaaaaaaaaa'\",\n             \"Full diff:\",\n             \"  [\",\n-            \"-  'should not get wrapped',\",\n-            \"+  'a',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n-            \"+  'aaaaaaaaaa',\",\n+            \"-     'should not get wrapped',\",\n+            \"+     'a',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n+            \"+     'aaaaaaaaaa',\",\n             \"  ]\",\n         ]\n \n@@ -615,13 +623,17 @@ def test_dict_wrap(self) -> None:\n             \"Differing items:\",\n             \"{'env': {'env1': 1, 'env2': 2}} != {'env': {'env1': 1}}\",\n             \"Full diff:\",\n-            \"- {'common': 1, 'env': {'env1': 1}}\",\n-            \"+ {'common': 1, 'env': {'env1': 1, 'env2': 2}}\",\n-            \"?                                +++++++++++\",\n+            \"  {\",\n+            \"      'common': 1,\",\n+            \"      'env': {\",\n+            \"          'env1': 1,\",\n+            \"+         'env2': 2,\",\n+            \"      },\",\n+            \"  }\",\n         ]\n \n         long_a = \"a\" * 80\n-        sub = {\"long_a\": long_a, \"sub1\": {\"long_a\": \"substring that gets wrapped \" * 2}}\n+        sub = {\"long_a\": long_a, \"sub1\": {\"long_a\": \"substring that gets wrapped \" * 3}}\n         d1 = {\"env\": {\"sub\": sub}}\n         d2 = {\"env\": {\"sub\": sub}, \"new\": 1}\n         diff = callequal(d1, d2, verbose=True)\n@@ -632,10 +644,16 @@ def test_dict_wrap(self) -> None:\n             \"{'new': 1}\",\n             \"Full diff:\",\n             \"  {\",\n-            \"   'env': {'sub': {'long_a': '\" + long_a + \"',\",\n-            \"                   'sub1': {'long_a': 'substring that gets wrapped substring '\",\n-            \"                                      'that gets wrapped '}}},\",\n-            \"-  'new': 1,\",\n+            \"      'env': {\",\n+            \"          'sub': {\",\n+            f\"              'long_a': '{long_a}',\",\n+            \"              'sub1': {\",\n+            \"                  'long_a': 'substring that gets wrapped substring that gets wrapped '\",\n+            \"                  'substring that gets wrapped ',\",\n+            \"              },\",\n+            \"          },\",\n+            \"      },\",\n+            \"-     'new': 1,\",\n             \"  }\",\n         ]\n \n@@ -677,8 +695,13 @@ def test_dict_different_items(self) -> None:\n             \"Right contains 2 more items:\",\n             \"{'b': 1, 'c': 2}\",\n             \"Full diff:\",\n-            \"- {'b': 1, 'c': 2}\",\n-            \"+ {'a': 0}\",\n+            \"  {\",\n+            \"-     'b': 1,\",\n+            \"?      ^   ^\",\n+            \"+     'a': 0,\",\n+            \"?      ^   ^\",\n+            \"-     'c': 2,\",\n+            \"  }\",\n         ]\n         lines = callequal({\"b\": 1, \"c\": 2}, {\"a\": 0}, verbose=2)\n         assert lines == [\n@@ -688,8 +711,13 @@ def test_dict_different_items(self) -> None:\n             \"Right contains 1 more item:\",\n             \"{'a': 0}\",\n             \"Full diff:\",\n-            \"- {'a': 0}\",\n-            \"+ {'b': 1, 'c': 2}\",\n+            \"  {\",\n+            \"-     'a': 0,\",\n+            \"?      ^   ^\",\n+            \"+     'b': 1,\",\n+            \"?      ^   ^\",\n+            \"+     'c': 2,\",\n+            \"  }\",\n         ]\n \n     def test_sequence_different_items(self) -> None:\n@@ -699,8 +727,17 @@ def test_sequence_different_items(self) -> None:\n             \"At index 0 diff: 1 != 3\",\n             \"Right contains one more item: 5\",\n             \"Full diff:\",\n-            \"- (3, 4, 5)\",\n-            \"+ (1, 2)\",\n+            \"  (\",\n+            \"-     3,\",\n+            \"?     ^\",\n+            \"+     1,\",\n+            \"?     ^\",\n+            \"-     4,\",\n+            \"?     ^\",\n+            \"+     2,\",\n+            \"?     ^\",\n+            \"-     5,\",\n+            \"  )\",\n         ]\n         lines = callequal((1, 2, 3), (4,), verbose=2)\n         assert lines == [\n@@ -708,8 +745,27 @@ def test_sequence_different_items(self) -> None:\n             \"At index 0 diff: 1 != 4\",\n             \"Left contains 2 more items, first extra item: 2\",\n             \"Full diff:\",\n-            \"- (4,)\",\n-            \"+ (1, 2, 3)\",\n+            \"  (\",\n+            \"-     4,\",\n+            \"?     ^\",\n+            \"+     1,\",\n+            \"?     ^\",\n+            \"+     2,\",\n+            \"+     3,\",\n+            \"  )\",\n+        ]\n+        lines = callequal((1, 2, 3), (1, 20, 3), verbose=2)\n+        assert lines == [\n+            \"(1, 2, 3) == (1, 20, 3)\",\n+            \"At index 1 diff: 2 != 20\",\n+            \"Full diff:\",\n+            \"  (\",\n+            \"      1,\",\n+            \"-     20,\",\n+            \"?      -\",\n+            \"+     2,\",\n+            \"      3,\",\n+            \"  )\",\n         ]\n \n     def test_set(self) -> None:\n@@ -1844,8 +1900,8 @@ def test():\n                 assert [0, 1] == [0, 2]\n             \"\"\",\n             [\n-                \"{bold}{red}E         {light-red}- [0, 2]{hl-reset}{endline}{reset}\",\n-                \"{bold}{red}E         {light-green}+ [0, 1]{hl-reset}{endline}{reset}\",\n+                \"{bold}{red}E         {light-red}-     2,{hl-reset}{endline}{reset}\",\n+                \"{bold}{red}E         {light-green}+     1,{hl-reset}{endline}{reset}\",\n             ],\n         ),\n         (\n@@ -1857,8 +1913,8 @@ def test():\n             \"\"\",\n             [\n                 \"{bold}{red}E         {light-gray} {hl-reset} {{{endline}{reset}\",\n-                \"{bold}{red}E         {light-gray} {hl-reset}  'number-is-1': 1,{endline}{reset}\",\n-                \"{bold}{red}E         {light-green}+  'number-is-5': 5,{hl-reset}{endline}{reset}\",\n+                \"{bold}{red}E         {light-gray} {hl-reset}     'number-is-1': 1,{endline}{reset}\",\n+                \"{bold}{red}E         {light-green}+     'number-is-5': 5,{hl-reset}{endline}{reset}\",\n             ],\n         ),\n     ),\n@@ -1917,14 +1973,32 @@ def test_long_text_fail():\n             f\"{p.name} .FFF                            [100%]\",\n             \"E         At index 2 diff: 'grapes' != 'orange'\",\n             \"E         Full diff:\",\n-            \"E         - ['banana', 'apple', 'orange', 'melon', 'kiwi']\",\n-            \"E         ?                      ^  ^^\",\n-            \"E         + ['banana', 'apple', 'grapes', 'melon', 'kiwi']\",\n-            \"E         ?                      ^  ^ +\",\n+            \"E           [\",\n+            \"E               'banana',\",\n+            \"E               'apple',\",\n+            \"E         -     'orange',\",\n+            \"E         ?      ^  ^^\",\n+            \"E         +     'grapes',\",\n+            \"E         ?      ^  ^ +\",\n+            \"E               'melon',\",\n+            \"E               'kiwi',\",\n+            \"E           ]\",\n             \"E         Full diff:\",\n-            \"E         - {'0': 0, '10': 10, '20': 20, '30': 30, '40': 40}\",\n-            \"E         ?            -    -    -    -    -    -    -    -\",\n-            \"E         + {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}\",\n+            \"E           {\",\n+            \"E               '0': 0,\",\n+            \"E         -     '10': 10,\",\n+            \"E         ?       -    -\",\n+            \"E         +     '1': 1,\",\n+            \"E         -     '20': 20,\",\n+            \"E         ?       -    -\",\n+            \"E         +     '2': 2,\",\n+            \"E         -     '30': 30,\",\n+            \"E         ?       -    -\",\n+            \"E         +     '3': 3,\",\n+            \"E         -     '40': 40,\",\n+            \"E         ?       -    -\",\n+            \"E         +     '4': 4,\",\n+            \"E           }\",\n             f\"E       AssertionError: assert 'hello world' in '{long_text}'\",\n         ]\n     )\ndiff --git a/testing/test_error_diffs.py b/testing/test_error_diffs.py\nindex eb781210872..cad7a17c047 100644\n--- a/testing/test_error_diffs.py\n+++ b/testing/test_error_diffs.py\n@@ -21,10 +21,14 @@ def test_this():\n         E       assert [1, 4, 3] == [1, 2, 3]\n         E         At index 1 diff: 4 != 2\n         E         Full diff:\n-        E         - [1, 2, 3]\n+        E           [\n+        E               1,\n+        E         -     2,\n         E         ?     ^\n-        E         + [1, 4, 3]\n+        E         +     4,\n         E         ?     ^\n+        E               3,\n+        E           ]\n         \"\"\",\n         id=\"Compare lists, one item differs\",\n     ),\n@@ -40,9 +44,11 @@ def test_this():\n         E       assert [1, 2, 3] == [1, 2]\n         E         Left contains one more item: 3\n         E         Full diff:\n-        E         - [1, 2]\n-        E         + [1, 2, 3]\n-        E         ?      +++\n+        E           [\n+        E               1,\n+        E               2,\n+        E         +     3,\n+        E           ]\n         \"\"\",\n         id=\"Compare lists, one extra item\",\n     ),\n@@ -59,9 +65,11 @@ def test_this():\n         E         At index 1 diff: 3 != 2\n         E         Right contains one more item: 3\n         E         Full diff:\n-        E         - [1, 2, 3]\n-        E         ?     ---\n-        E         + [1, 3]\n+        E           [\n+        E               1,\n+        E         -     2,\n+        E               3,\n+        E           ]\n         \"\"\",\n         id=\"Compare lists, one item missing\",\n     ),\n@@ -77,10 +85,14 @@ def test_this():\n         E       assert (1, 4, 3) == (1, 2, 3)\n         E         At index 1 diff: 4 != 2\n         E         Full diff:\n-        E         - (1, 2, 3)\n+        E           (\n+        E               1,\n+        E         -     2,\n         E         ?     ^\n-        E         + (1, 4, 3)\n+        E         +     4,\n         E         ?     ^\n+        E               3,\n+        E           )\n         \"\"\",\n         id=\"Compare tuples\",\n     ),\n@@ -99,10 +111,12 @@ def test_this():\n         E         Extra items in the right set:\n         E         2\n         E         Full diff:\n-        E         - {1, 2, 3}\n-        E         ?     ^  ^\n-        E         + {1, 3, 4}\n-        E         ?     ^  ^\n+        E           {\n+        E               1,\n+        E         -     2,\n+        E               3,\n+        E         +     4,\n+        E           }\n         \"\"\",\n         id=\"Compare sets\",\n     ),\n@@ -123,10 +137,13 @@ def test_this():\n         E         Right contains 1 more item:\n         E         {2: 'eggs'}\n         E         Full diff:\n-        E         - {1: 'spam', 2: 'eggs'}\n-        E         ?             ^\n-        E         + {1: 'spam', 3: 'eggs'}\n-        E         ?             ^\n+        E           {\n+        E               1: 'spam',\n+        E         -     2: 'eggs',\n+        E         ?     ^\n+        E         +     3: 'eggs',\n+        E         ?     ^\n+        E           }\n         \"\"\",\n         id=\"Compare dicts with differing keys\",\n     ),\n@@ -145,10 +162,11 @@ def test_this():\n         E         Differing items:\n         E         {2: 'eggs'} != {2: 'bacon'}\n         E         Full diff:\n-        E         - {1: 'spam', 2: 'bacon'}\n-        E         ?                 ^^^^^\n-        E         + {1: 'spam', 2: 'eggs'}\n-        E         ?                 ^^^^\n+        E           {\n+        E               1: 'spam',\n+        E         -     2: 'bacon',\n+        E         +     2: 'eggs',\n+        E           }\n         \"\"\",\n         id=\"Compare dicts with differing values\",\n     ),\n@@ -169,10 +187,11 @@ def test_this():\n         E         Right contains 1 more item:\n         E         {3: 'bacon'}\n         E         Full diff:\n-        E         - {1: 'spam', 3: 'bacon'}\n-        E         ?             ^   ^^^^^\n-        E         + {1: 'spam', 2: 'eggs'}\n-        E         ?             ^   ^^^^\n+        E           {\n+        E               1: 'spam',\n+        E         -     3: 'bacon',\n+        E         +     2: 'eggs',\n+        E           }\n         \"\"\",\n         id=\"Compare dicts with differing items\",\n     ),\n", "problem_statement": "Better diff for asserts on dicts\nCurrently in some edge cases py.test returns utterly useless diffs for asserts on dicts, it doesn't provide the context needed to find which parts are differing in deeply nested dicts.\n\nA better, and simpler, solution would be to use a json serializer to serialize the dicts and then use difflibs unified diff to generate the final diff. this solution will produce a diff in an easy to read format that people are familiar with and provides enough context to find the right place in the dict where changes need to be made.\n\nany objects not json serializable in the dict can be adequately dealt with by using repr as serializer.\n\n[this whole function could be replaced with ~5 lines of code.](https://github.com/pytest-dev/pytest/blob/3155d0ca9c75d3c984de84251ff12d97253134f3/_pytest/assertion/util.py#L287-L313)\n\n", "hints_text": "would you like to turn that into a pull request?\n\nalso note, that for \"proper\" diff of nested structures one needs a path to the object being diffed as well\n\nI'd love to, but I can't seem to figure out the correct way to run pytest from source.\n\nI usually do something like:\n\n```\n$ virtualenv .venv\n$ ./.venv/bin/pip install -e .\n$ ./.venv/bin/python -m pytest ...\n```\n\nAnd to run the tests/linters, simply run `tox`.\n\nI'd also be interested in this :)\n\nI've had a good look at this recently, and it turns out to be a way bigger project than I had initially estimated. I'm afraid I can't quite find the time to get this done. sorry.\n\nNo problem, thanks for the heads up.\n\nI am interested in tackling this. Just now starting to look into it. \nJust to add to this old (but important to me!) issue - it seems if you call `assert {} == {}` from within a function that is called from a test, pytest doesn't really help you. If I move my assertions to within the main test body they work great, but if they are called via a function it doesn't help.\n@four43 That is unrelated to this issue and intended - pytest's assertion introspection/rewriting is only active for `test_*.py` files (and a few more cases) by default, to avoid changing the behavior of your code under test.\r\n\r\nSee the docs for details:\r\n\r\n- [Assertion introspection details](https://docs.pytest.org/en/stable/assert.html#assertion-introspection-details)\r\n- [Assertion Rewriting](https://docs.pytest.org/en/stable/writing_plugins.html#assertion-rewriting)\nHey okay that's pretty slick. Thanks for the tip, I bet that solves my problem. I appreciate it. \nJust for the record (and inspiration) there are two pytest plugins that prints better dict comparisons:\r\n* [pytest-icdiff](https://github.com/hjwp/pytest-icdiff)\r\n* [pytest-dictsdiff](https://github.com/lukaszb/pytest-dictsdiff)\r\n\r\n\r\nSource: https://eshlox.net/2020/04/07/better-diffs-in-pytest\nThanks @m-aciek,\r\n\r\nI had a few minutes so I tried `pytest-dictsdiff`, here's the output using the example on the README:\r\n\r\n```\r\nE               Failed:  => CHANGE: at key 'dob.age' values are different | Left: 44 | Right: 34\r\nE                => CHANGE: at key 'dob.date' values are different | Left: '1983-11-04T01:21:14Z' | Right: '1953-11-04T01:21:04Z'\r\nE                => CHANGE: at key 'location.city' values are different | Left: 'tholen' | Right: 'Tholen'\r\nE                => CHANGE: at key 'location.postcode' values are different | Left: 64504 | Right: 64509\r\nE                => CHANGE: at key 'name.first' values are different | Left: 'zeyneb' | Right: 'Zeyneb'\r\nE                => CHANGE: at key 'name.last' values are different | Left: 'elfring' | Right: 'Elfring'\r\n``` \r\n\r\nStyle aside, the diff is readable to me.\r\n\r\nWhile at it decided to take a stab at @SuperDoxin's idea of using json+difflib (using the same data sample from `pytest-dictsdiff`):\r\n\r\n```\r\ndef test_compare_dicts():\r\n    import json\r\n    left = json.dumps(RESULT, indent=2, sort_keys=True)\r\n    right = json.dumps(EXPECTED_DATA, indent=2, sort_keys=True)\r\n\r\n    import difflib\r\n    diff = difflib.unified_diff(left.splitlines(True), right.splitlines(True), fromfile=\"left\", tofile=\"right\")\r\n    assert 0, \"\\n\" + \"\".join(diff)\r\n```\r\n\r\nHere's the output:\r\n\r\n```\r\nE       AssertionError:\r\nE         --- left\r\nE         +++ right\r\nE         @@ -1,8 +1,8 @@\r\nE          {\r\nE            \"cell\": \"(056)-022-8631\",\r\nE            \"dob\": {\r\nE         -    \"age\": 44,\r\nE         -    \"date\": \"1983-11-04T01:21:14Z\"\r\nE         +    \"age\": 34,\r\nE         +    \"date\": \"1953-11-04T01:21:04Z\"\r\nE            },\r\nE            \"email\": \"zeyneb.elfring@example.com\",\r\nE            \"gender\": \"female\",\r\nE         @@ -11,12 +11,12 @@\r\nE              \"value\": \"36180866\"\r\nE            },\r\nE            \"location\": {\r\nE         -    \"city\": \"tholen\",\r\nE         +    \"city\": \"Tholen\",\r\nE              \"coordinates\": {\r\nE                \"latitude\": \"46.8823\",\r\nE                \"longitude\": \"175.8856\"\r\nE              },\r\nE         -    \"postcode\": 64504,\r\nE         +    \"postcode\": 64509,\r\nE              \"state\": \"groningen\",\r\nE              \"street\": \"2074 adriaen van ostadelaan\",\r\nE              \"timezone\": {\r\nE         @@ -34,8 +34,8 @@\r\nE              \"uuid\": \"37e30c59-bc79-4172-aac6-e2c640e165fa\"\r\nE            },\r\nE            \"name\": {\r\nE         -    \"first\": \"zeyneb\",\r\nE         -    \"last\": \"elfring\",\r\nE         +    \"first\": \"Zeyneb\",\r\nE         +    \"last\": \"Elfring\",\r\nE              \"title\": \"mrs\"\r\nE            },\r\nE            \"nat\": \"NL\",\r\nE\r\nE       assert 0\r\n```\r\n\r\nI like it too, but this has the problematic downside that json doesn't handle custom objects, and AFAIK there's no easy way to generalize it.\n@nicoddemus I believe the reason to use json dumping here is that the json output will format the diff with consistent `{` on their own lines and all of those small tweaks?\r\n\r\nIf so, I believe it should be doable to extend/override the pretty printer used by pytest to have the same behavior. It might be quite some code due to how the PrettyPrinter is implemented, but would continue to work as today for everything else.\r\n\r\nI'd be happy to attempt a solution with prettyprinter if no-one is actively working on this and pytest would be fine with that added code\n> @nicoddemus I believe the reason to use json dumping here is that the json output will format the diff with consistent { on their own lines and all of those small tweaks?\r\n\r\nExactly. \ud83d\udc4d \r\n\r\n> If so, I believe it should be doable to extend/override the pretty printer used by pytest to have the same behavior. It might be quite some code due to how the PrettyPrinter is implemented, but would continue to work as today for everything else.\r\n\r\nThat would be amazing!\r\n\r\n> I'd be happy to attempt a solution with prettyprinter if no-one is actively working on this and pytest would be fine with that added code\r\n\r\nOh yes, please go ahead, thanks a lot. \nhttps://github.com/pytest-dev/pytest/pull/11537 would be my proposed solution", "created_at": "2023-10-30T22:51:04Z"}
